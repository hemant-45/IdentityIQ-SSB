-- MySQL dump 10.13  Distrib 8.0.17, for Win64 (x86_64)
--
-- Host: localhost    Database: identityiq
-- ------------------------------------------------------
-- Server version	5.7.22-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `spt_rule`
--

DROP TABLE IF EXISTS `spt_rule`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `spt_rule` (
  `id` varchar(32) NOT NULL,
  `created` bigint(20) DEFAULT NULL,
  `modified` bigint(20) DEFAULT NULL,
  `owner` varchar(32) DEFAULT NULL,
  `assigned_scope` varchar(32) DEFAULT NULL,
  `assigned_scope_path` varchar(450) DEFAULT NULL,
  `name` varchar(128) NOT NULL,
  `description` varchar(1024) DEFAULT NULL,
  `language` varchar(255) DEFAULT NULL,
  `source` longtext,
  `type` varchar(255) DEFAULT NULL,
  `attributes` longtext,
  `sig_description` longtext,
  `return_type` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  KEY `FK9A438C84486634B7` (`assigned_scope`),
  KEY `FK9A438C84A5FB1B1` (`owner`),
  KEY `spt_rule_assignedscopepath` (`assigned_scope_path`(255)),
  CONSTRAINT `FK9A438C84486634B7` FOREIGN KEY (`assigned_scope`) REFERENCES `spt_scope` (`id`),
  CONSTRAINT `FK9A438C84A5FB1B1` FOREIGN KEY (`owner`) REFERENCES `spt_identity` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `spt_rule`
--

LOCK TABLES `spt_rule` WRITE;
/*!40000 ALTER TABLE `spt_rule` DISABLE KEYS */;
INSERT INTO `spt_rule` VALUES ('297e8b3d78a703490178a709f85c0004',1617710151772,1617710242755,NULL,NULL,NULL,'encrypt',NULL,'beanshell','\nimport java.util.*;\nimport sailpoint.object.*;\n\n\nString data = \"iiqdbPlugin\";\n\nreturn context.encrypt(data);\n ',NULL,' ',NULL,NULL),('297e8b3d78ab76ff0178ab789b15000d',1617784511253,1617791347971,NULL,NULL,NULL,'Application Builder','\n    A rule to build and manipulate IdentityIQ application in a bulk.\n    All duties are mentioned below.\n    1. When create mode is selected, then it creates multiple application in a bulk by parsing csv file.\n    2. When update mode is selected, then it updates the attribute map of existing application by parsing input csv file.\n    3. When read mode is selected, then it reads all existing IdentityIQ application and export them to csv file.\n       Exports considers only attributes of the application.\n  ','beanshell','\n    \n      import java.io.BufferedReader;\n      import java.io.FileNotFoundException;\n      import java.io.FileReader;\n      import java.io.FileWriter;\n      import java.io.IOException;\n      import java.util.ArrayList;\n      import java.util.Date;\n      import java.util.HashMap;\n      import java.util.LinkedHashMap;\n      import java.util.List;\n      import java.util.Map;\n      import java.util.Set;\n      import java.util.Iterator;\n      import java.util.LinkedHashMap;\n      import java.util.LinkedHashSet;\n      import sailpoint.api.SailPointContext;\n      import sailpoint.api.TaskManager;\n      import sailpoint.connector.Connector;\n      import sailpoint.connector.ConnectorFactory;\n      import sailpoint.connector.DefaultApplicationFactory;\n      import sailpoint.object.Application;\n      import sailpoint.object.Attributes;\n      import sailpoint.object.Identity;\n      import sailpoint.object.Rule;\n      import sailpoint.object.TaskDefinition;\n      import sailpoint.object.TaskItemDefinition;\n      import sailpoint.object.TaskSchedule;\n      import sailpoint.object.TaskResult;\n      import sailpoint.object.Filter;\n      import sailpoint.object.QueryOptions;\n      import sailpoint.object.Attributes;\n      import sailpoint.object.AttributeDefinition;\n      import sailpoint.object.Attributes;\n      import sailpoint.object.Field;\n      import sailpoint.object.Form;\n      import sailpoint.object.Form.Section;\n      import sailpoint.object.FormItem;\n      import sailpoint.object.Schema;\n      import sailpoint.tools.GeneralException;\n      import sailpoint.tools.Message;\n      import sailpoint.tools.Util;\n      import sailpoint.tools.RFC4180LineIterator;\n      import sailpoint.tools.RFC4180LineParser;\n      import sailpoint.tools.Rfc4180CsvBuilder;\n      import sailpoint.tools.Util;\n      import sailpoint.tools.xml.XMLObjectFactory;\n\n      // Private member variables\n      private int applicationsCreated = 0;\n      private int applicationsUpdated = 0;\n      private int applicationsScanned = 0;\n      private List applicationsExists = new ArrayList();\n      private List applicationsNotFound = new ArrayList();\n      private List applicationsFailed = new ArrayList();\n      private List applicationObjects = new ArrayList();\n      Map applicationMap = new LinkedHashMap();\n      Set uniqueHeaders = new LinkedHashSet();\n\n      // Private Input parameters\n      private String filePath;\n      private String applicationType;\n      private String operation;\n      private boolean triggerAccountAggregation;\n      private boolean triggerGroupAggregation;\n      private boolean skipTestConnection;\n      private String launcher;\n      private int applicationsPerAggregation = 10;\n\n      // Public member variables\n      /**\n      * List of secret attributes used in different connector\'s application attribute.\n      */\n      Set secreteAttributes = new LinkedHashSet();\n      String rowSeparator = \"\\n\";\n      private String docTypeHeader = \"<?xml version=\'1.0\' encoding=\'UTF-8\'?>\" +\n                             \"\\n<!DOCTYPE Application PUBLIC \\\"sailpoint.dtd\\\" \\\"sailpoint.dtd\\\">\" +\n                             \"\\n<Application>\\n\";\n      private String docTypeFooter = \"\\n</Application>\";\n      private String schemasHeader = \"Schemas\";\n      private String provisioningFormsHeader = \"ProvisioningForms\";\n      private String create = \"create\";\n      private String update = \"update\";\n      private String read = \"read\";\n\n      /////////// public methods for processing IdentityIQ applications. ///////////\n      //////////////////////////////////////////////////////////////////////////////\n\n      /**\n       * Parse the input CSV file based on fix format.\n       * and convert it to the attribute map for further processing.\n       */\n      public void parseInputFile() {\n          log.debug(\"Entering parseInputFile()...\");\n\n          BufferedReader br = null;\n\n          try {\n\n              List fileHeaders = new ArrayList();\n              Map attributeMap = null;\n              br = new BufferedReader(new FileReader(filePath));\n\n              RFC4180LineParser parser = new RFC4180LineParser(\",\");\n              RFC4180LineIterator iterator = new RFC4180LineIterator(br);\n\n              String fileRow = iterator.readLine();\n\n              // Parse file headers\n              if (Util.isNotNullOrEmpty(fileRow)) {\n                  log.debug(\"File headers: \" + fileRow);\n\n                  fileHeaders = Util.csvToList(fileRow);\n              } else {\n                  throw new GeneralException(\"Headers not found. File\'s first line should be headers.\");\n              }\n              // Parse CSV file data\n              while ((fileRow = iterator.readLine()) != null) {\n                  List fileRowList = Util.csvToList(fileRow);\n                  attributeMap = new HashMap();\n                  boolean isApplicationName = true;\n                  String applicationName = \"\";\n\n                  if (fileRowList != null) {\n                      if (fileRowList.size() > fileHeaders.size()) {\n                          throw new GeneralException(\"Mismach in row data and headers length. Affected row: \" + fileRow);\n                      }\n                      // Attribute Map received from input file\n                      for (int i = 0; i < fileRowList.size(); i++) {\n                          String fileRowData = (String)fileRowList.get(i);\n                          if (Util.isNotNullOrEmpty(fileRowData)) {\n                              if (isApplicationName) {\n                                   applicationName = fileRowData;\n                                   isApplicationName = false;\n                              } else {\n                                  if (fileRowData.equalsIgnoreCase(\"true\") || fileRowData.equalsIgnoreCase(\"false\")) {\n                                      attributeMap.put(fileHeaders.get(i), Boolean.parseBoolean(fileRowData));\n                                  } else {\n                                      attributeMap.put(fileHeaders.get(i), fileRowData);\n                                  }\n                              }\n                          }\n                      }\n\n                      if (Util.isNotNullOrEmpty(applicationName)) {\n                         applicationMap.put(applicationName, attributeMap);\n                      }\n                  }\n              }\n          } catch (FileNotFoundException e) {\n              throw new GeneralException(\"File parsing failed. \" + e.getMessage(), e);\n          } catch (IOException e) {\n              throw new GeneralException(\"File parsing failed. \" + e.getMessage(), e);\n          } finally {\n              try {\n                  if (br != null) {\n                      br.close();\n                  }\n              } catch (Exception ex) {\n                  log.warn(\"Error while closing BufferedReader object. \" + ex.getMessage);\n              }\n          }\n\n          log.debug(\"Exiting parseInputFile()...\");\n      }\n\n      /**\n       * Create multiple IdentityIQ applications based on input application data.\n       */\n      private void createApplications() {\n          log.debug(\"Entering createApplications()...\");\n\n          List aggregationappList = new ArrayList();\n\n          for (Map.Entry entry : applicationMap.entrySet()) {\n              String applicationName = (String) entry.getKey();\n              Application application = context.getObjectByName(Application.class, applicationName);\n              if (application != null) {\n                  log.warn(\"The application \'\" + applicationName +\"\' already exists on the IdentityIQ server.\");\n\n                  applicationsExists.add(applicationName);\n                  continue;\n              }\n\n              // Create new IdentityIQ application\n              log.debug(\"Creating the application: \" + applicationName);\n\n              application = DefaultApplicationFactory.getDefaultApplicationByTemplate(applicationType);\n              application.setCreated(new Date());\n              application.setModified(new Date());\n              application.setName(entry.getKey());\n              application.setAuthoritative(false);\n              application.setCaseInsensitive(true);\n              application.setIcon(\"enterpriseIcon\");\n              application.setOwner(context.getObjectByName(Identity.class, launcher));\n\n              try {\n                  createOrUpdateApplications(entry, application, aggregationappList);\n              } catch (Exception ex) {\n                  applicationsFailed.add(application.getName());\n                  log.error(\"Failed to create the application \'\" + applicationName + \"\'. \" + ex.getMessage(), ex);\n\n                  continue;\n              }\n          }\n\n          // Perform account and group aggregation for remianing applications\n          if (!aggregationappList.isEmpty()) {\n              triggerAggregation(aggregationappList);\n          }\n\n          updateTaskResult();\n\n          log.debug(\"Exiting createApplications()...\");\n      }\n\n      /**\n       * Update multiple IdentityIQ applications based on input application data.\n       */\n      private void updateApplications() {\n          log.debug(\"Entering updateApplications()...\");\n\n          List aggregationappList = new ArrayList();\n\n          for (Map.Entry entry : applicationMap.entrySet()) {\n              String applicationName = (String) entry.getKey();\n              Application application = context.getObjectByName(Application.class, applicationName);\n              if (application == null) {\n                  log.warn(\"The application \'\" + applicationName + \"\' is not found.\");\n\n                  applicationsNotFound.add(applicationName);\n                  continue;\n              }\n\n              // Update existing IdentityIQ application\n              log.debug(\"Updating the application: \" + applicationName);\n\n              try {\n                  createOrUpdateApplications(entry, application, aggregationappList);\n              } catch (Exception ex) {\n                  applicationsFailed.add(application.getName());\n                  log.error(\"Failed to update the application \'\" + applicationName + \"\'. \" + ex.getMessage(), ex);\n\n                  continue;\n              }\n          }\n\n          // Perform account and group aggregation for remianing applications\n          if (!aggregationappList.isEmpty()) {\n              triggerAggregation(aggregationappList);\n          }\n\n          updateTaskResult();\n\n          log.debug(\"Exiting updateApplications()...\");\n      }\n\n      /**\n       * Retriving the application object from IdentityIQ database for given application type and\n       * updating the applicationMap which will be exported to csv file.\n       */\n      public void updateAttributesMap() {\n          log.debug(\"Entering updateAttributesMap()...\");\n\n          Map attributeMap = null;\n          boolean encryptedAttrFound = false;\n\n          // Query filter to get list of applications for the specified application type\n          Filter filter = Filter.eq(\"type\", applicationType);\n\n          // List of application objects\n          List applicationsObjectList = context.getObjects(Application.class, new QueryOptions().addFilter(filter));\n\n          log.debug(\"Total number of applications of type \'\" + applicationType + \"\' are: \" + applicationsObjectList.size());\n\n          for (Application application : applicationsObjectList) {\n              try {\n                  log.debug(\"Application name: \" + application.getName());\n\n                  uniqueHeaders.add(\"Name\");\n                  attributeMap = new HashMap();\n                  applicationMap.put(application.getName(), attributeMap);\n                  attributeMap.put(\"Name\", application.getName());\n                  Attributes attrMap = application.getAttributes();\n\n                  // Update encrypted attribute\n                  if (!encryptedAttrFound) {\n                      if (attrMap.get(\"encrypted\") != null) {\n                          List encryptedAttrs = Util.csvToList(attrMap.get(\"encrypted\").toString());\n                          secreteAttributes.addAll(encryptedAttrs);\n                          encryptedAttrFound = true;\n                      }\n                  }\n\n                  for (Map.Entry entry : attrMap.entrySet()) {\n                      if (entry.getValue() != null) {\n                          if (entry.getValue() instanceof String || entry.getValue() instanceof Boolean) {\n\n                              // Update attribute map with key and value\n                              attributeMap.put(entry.getKey().toString(), entry.getValue());\n\n                              // Update header set\n                              uniqueHeaders.add(entry.getKey().toString());\n                          }\n                      }\n                  }\n\n                  String appXML = application.toXml(false);\n\n                  String schemasHeaderTag = \"<Schemas>\";\n                  String schemasFooterTag = \"</Schemas>\";\n                  if (appXML.indexOf(schemasHeaderTag) > 0) {\n                      String schema = appXML.substring(appXML.indexOf(schemasHeaderTag), appXML.indexOf(schemasFooterTag) + 10);\n                      uniqueHeaders.add(schemasHeader);\n                      attributeMap.put(schemasHeader, schema);\n                  }\n\n                  String provisioningFormsHeaderTag = \"<ProvisioningForms>\";\n                  String provisioningFormsFooterTag = \"</ProvisioningForms>\";\n                  if (appXML.indexOf(provisioningFormsHeaderTag) > 0) {\n                      String forms = appXML.substring(appXML.indexOf(provisioningFormsHeaderTag), appXML.indexOf(provisioningFormsFooterTag) + 20);\n                      uniqueHeaders.add(provisioningFormsHeader);\n                      attributeMap.put(provisioningFormsHeader, forms);\n                  }\n              } catch (Exception e) {\n                  log.warn(\"Failed to read application: \" + application.getName() + \". \" + e.getMessage(), e);\n              }\n          }\n\n          log.debug(\"Exiting updateAttributesMap()...\");\n      }\n\n      /**\n      * Export Applications attribute map in csv format.\n      */\n      public void exportApplications() {\n          log.debug(\"Entering exportApplications()...\");\n\n          FileWriter fileWriter = null;\n\n          if (Util.isEmpty(applicationMap)) {\n              log.warn(\"Application \'\" + applicationType + \"\' not found on the IdentityIQ server.\");\n\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n              taskResult.setAttribute(\"applicationsScanned\", applicationMap.size());\n          } else {\n              // Perform the file operation when application map is non empty.\n              try {\n                  log.debug(\"Application map size: \" + applicationMap.size());\n\n                  Rfc4180CsvBuilder csvBuilder = new Rfc4180CsvBuilder();\n                  List headers = new ArrayList(uniqueHeaders);\n\n                  // Make sure Schemas column and/or ProvisioningForms placed after configuration attributes\n                  if (headers.contains(schemasHeader)) {\n                     headers.remove(schemasHeader);\n                     headers.add(schemasHeader);\n                  }\n\n                  if (headers.contains(provisioningFormsHeader)) {\n                     headers.remove(provisioningFormsHeader);\n                     headers.add(provisioningFormsHeader);\n                  }\n\n                  fileWriter = new FileWriter(filePath);\n                  fileWriter.append(Util.listToCsv(headers));\n                  fileWriter.append(rowSeparator);\n\n                  for (Map.Entry entry : applicationMap.entrySet()) {\n                      StringBuffer attributeRow = new StringBuffer();\n                      Map innerAttrMap = (Map) entry.getValue();\n                      for (String headerName : headers) {\n                          String attrValue = (innerAttrMap.get(headerName) != null) ? innerAttrMap.get(headerName).toString() : \"\";\n\n                          if (secreteAttributes.contains(headerName)) {\n                              attrValue = \"\";\n                          }\n\n                          csvBuilder.addValue(attrValue);\n                      }\n\n                      // Update File Row\n                      fileWriter.append(csvBuilder.build());\n\n                      fileWriter.append(rowSeparator);\n                      csvBuilder.flush();\n                  }\n              } catch (Exception e) {\n                  throw new GeneralException(\"Failed to export the application attributes map to a file. \" + e.getMessage(), e);\n              } finally {\n                  try {\n                      if (fileWriter != null) {\n                          fileWriter.flush();\n                          fileWriter.close();\n                      }\n                  } catch (Exception ex) {\n                      log.warn(\"Error while closing fileWriter object. \" + ex.getMessage);\n                  }\n              }\n\n              updateTaskResult();\n          }\n\n          log.debug(\"Exiting exportApplications()...\");\n       }\n\n      /**\n       * Run Account aggregation task for the multiple IdentityIQ applications\n       * @param applicationNames comma saperated application names\n       *\n       */\n      private void executeAccountAggregation(String applicationNames) throws GeneralException {\n          log.debug(\"Entering executeAccountAggregation()...\");\n\n          TaskManager tm = new TaskManager(context);\n          HashMap taskArgs = new HashMap();\n          TaskDefinition taskDefinition = new TaskDefinition();\n          taskDefinition.setName(applicationType + \" Account Aggregation \" + new Date() + \" - \" + Util.rand(1, 10000));\n          taskDefinition.setDescription(\"Account Aggregation task for \" + applicationType);\n          taskDefinition.setType(TaskItemDefinition.Type.AccountAggregation);\n          taskDefinition.setResultAction(TaskDefinition.ResultAction.Delete);\n          taskDefinition.setFormPath(\"/monitor/tasks/accountAggregationTask.xhtml\");\n          taskDefinition.setArgument(\"applications\", applicationNames);\n          taskDefinition.setArgument(\"checkDeleted\", \"true\");\n          taskDefinition.setArgument(\"promoteManagedAttributes\", \"true\");\n          taskDefinition.setArgument(\"logAllowedActions\", null);\n          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));\n          taskDefinition.setParent(context.getObject(TaskDefinition.class, \"Account Aggregation\"));\n          context.saveObject(taskDefinition);\n          context.commitTransaction();\n          tm.run(taskDefinition, taskArgs);\n\n          log.debug(\"Account aggregation task is executed for the application \'\" + applicationNames + \"\'.\");\n          log.debug(\"Exiting executeAccountAggregation()...\");\n      }\n\n      /**\n       * Run Group aggregation task for the multiple IdentityIQ applications\n       * applicationNames comma saperated application names\n      */\n      private void executeGroupAggregation(String applicationNames) throws GeneralException {\n          log.debug(\"Entering executeGroupAggregation()...\");\n\n          TaskManager tm = new TaskManager(context);\n          HashMap taskArgs = new HashMap();\n          TaskDefinition taskDefinition = new TaskDefinition();\n          taskDefinition.setName(applicationType + \" Group Aggregation \" + new Date() + \" - \" + Util.rand(1, 10000));\n          taskDefinition.setDescription(\"Group Aggregation task for \" + applicationType);\n          taskDefinition.setType(TaskItemDefinition.Type.AccountGroupAggregation);\n          taskDefinition.setArgument(\"aggregationType\", \"group\");\n          taskDefinition.setFormPath(\"/monitor/tasks/accountGroupAggregationTask.xhtml\");\n          taskDefinition.setArgument(\"applications\", applicationNames);\n          taskDefinition.setArgument(\"checkDeleted\", \"true\");\n          taskDefinition.setOwner(context.getObjectByName(Identity.class, launcher));\n          taskDefinition.setExecutor(\"sailpoint.task.ResourceIdentityScan\");\n          taskDefinition.setResultRenderer(\"accountGroupAggregationResult.xhtml\");\n          taskDefinition.setParent(context.getObject(TaskDefinition.class, \"Account Group Aggregation\"));\n          context.saveObject(taskDefinition);\n          context.commitTransaction();\n          tm.run(taskDefinition, taskArgs);\n\n          log.debug(\"Group aggregation task is executed for the application \'\" + applicationNames + \"\'.\");\n          log.debug(\"Exiting executeGroupAggregation()...\");\n\n      }\n\n      /**\n       * Create/Update multiple IdentityIQ application from the provided csv file.\n       * Also ability to trigger test connection and aggregation based on user input.\n       * User can provide schema and provisioning form while create and/or update.\n       * The schema merge can be partial or full update.\n       * The provisioning forms is full update. i.e it will set whatever forms provided in csv file. \n       */\n      private void createOrUpdateApplications(Map.Entry entry, Application application, List aggregationappList) {\n          log.debug(\"Entering createOrUpdateApplications()...\");\n\n          Map innerMap = (Map) entry.getValue();\n          String applicationName = application.getName();\n\n          for (Map.Entry entryMap : innerMap.entrySet()) {\n              String key = (String)entryMap.getKey();\n              Object value = entryMap.getValue();\n\n              if (key != null && !applicationObjects.contains(key) && value != null) {\n                  application.setAttribute((String)entryMap.getKey(), entryMap.getValue());\n              }\n\n              if (applicationObjects.contains(key) && schemasHeader.equals(key)) {\n                  mergeSchemas(application, value.toString());\n              }\n\n              if (applicationObjects.contains(key) && provisioningFormsHeader.equals(key)) {\n                  setProvisioningForms(application, value.toString());\n              }\n          }\n\n          // Skip the test connection if the flag is true\n          if (!skipTestConnection) {\n                Connector conn = ConnectorFactory.getConnector(application, null);\n                conn.testConfiguration();\n                log.debug(\"Test connection is successful for the application: \" + applicationName);\n          } else {\n             log.debug(\"Skipping Test connection for the application: \" + applicationName);\n          }\n\n          context.saveObject(application);\n          context.commitTransaction();\n\n          if (create.equals(operation)) {\n              applicationsCreated++;\n              log.debug(\"Created the application: \" + applicationName);\n          } else if (update.equals(operation)) {\n              applicationsUpdated++;\n              log.debug(\"Updated the application: \" + applicationName);\n          }\n\n          aggregationappList.add(application.getName());\n\n          // Perform account and group aggregation task for configured applications per aggregation\n          if (aggregationappList.size() >= applicationsPerAggregation) {\n                triggerAggregation(aggregationappList);\n\n                // clear the list for the next chunk of aggregations\n                aggregationappList.clear();\n          }\n\n          log.debug(\"Exiting createOrUpdateApplications()...\");\n      }\n\n      /**\n       * Merge schema attribute definitions to specific schema.\n       */\n      private void mergeSchemas(Application app, String value) {\n          log.debug(\"Entering mergeSchemas() for: \" + app.getName());\n\n          if (value != null) {\n              String schemas = docTypeHeader + value + docTypeFooter;\n\n              try {\n                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, schemas, true);\n                  List tempAppSchemas = tempApp.getSchemas();\n    \n                  for (Schema tempSchema : tempAppSchemas) {\n                      Schema orgAppSchema = app.getSchema(tempSchema.getObjectType());\n    \n                      // Found schema, add the new attribute\n                      if (orgAppSchema != null) {\n                          List tempAttributes = tempSchema.getAttributes();\n                          List orgAttributes = orgAppSchema.getAttributes();\n                          List orgAttributesNames = orgAppSchema.getAttributeNames();\n\n                          if (tempSchema.getIdentityAttribute() != null) {\n                              orgAppSchema.setIdentityAttribute(tempSchema.getIdentityAttribute());\n                          }\n\n                          if (tempSchema.getDisplayAttribute() != null) {\n                              orgAppSchema.setDisplayAttribute(tempSchema.getDisplayAttribute());\n                          }\n\n                          if (tempSchema.getInstanceAttribute() != null) {\n                              orgAppSchema.setInstanceAttribute(tempSchema.getInstanceAttribute());\n                          }\n    \n                          for (AttributeDefinition tempAttribute : tempAttributes) {\n                              if (orgAttributesNames.contains(tempAttribute.getName())) {\n                                  log.debug(\"Found Schema attribute: \'\" + tempAttribute.getName() + \"\'.\");\n\n                                  // Attribute Definition found, remove it first.\n                                  int index = orgAttributesNames.indexOf(tempAttribute.getName());\n                                  orgAttributes.remove(orgAttributesNames.indexOf(tempAttribute.getName()));\n                                  log.debug(\"Removed Schema attribute: \'\" + tempAttribute.getName() + \"\'.\");\n\n                                  // Add attribute to specific index\n                                  orgAttributes.add(index, tempAttribute);\n                                  log.debug(\"Added Schema attribute: \'\" + tempAttribute.getName() + \"\'.\");\n                              } else {\n                                  // Add attribute, as it not present in original schema\n                                  orgAttributes.add(tempAttribute);\n                                  log.debug(\"Added Schema attribute: \'\" + tempAttribute.getName() + \"\'.\");\n                              }\n                          }\n                      } else { \n                          // add new schema\n                          // cleaning id, created, modified schema attributes for the new schema if they exists.\n                          // ideally new schema should not have those attributes.\n                          if (tempSchema.getId() != null) {\n                              tempSchema.setId(null);\n                          }\n                          if (tempSchema.getId() != null) {\n                              tempSchema.setId(null);\n                          }\n                          if (tempSchema.getCreated() != null) {\n                              tempSchema.setCreated(null);\n                          }\n                          if (tempSchema.getModified() != null) {\n                              tempSchema.setModified(null);\n                          }\n\n                          app.setSchema(tempSchema);\n                      }\n                  }\n              } catch (Exception e) {\n                  String message = \"Failed to merge Schema for the application: \'\" + app.getName() + \"\'.\";\n                  log.error(message, e);\n                  throw new GeneralException(message, e);\n              }\n          }\n\n          log.debug(\"Exiting mergeSchemas()...\");\n      }\n\n      /**\n       * Sets Provisioning forms to the application based on user input.\n       * It is full update. i.e Application will set provisioning forms defined in the csv file.\n       */\n      private void setProvisioningForms(Application app, String value) {\n          log.debug(\"Entering setProvisioningForms() for: \" + app.getName());\n\n          if (value != null) {\n              String provisioningForms = docTypeHeader + value + docTypeFooter;\n              try {\n                  Application tempApp = (Application)XMLObjectFactory.getInstance().parseXml(context, provisioningForms, true);\n                  List tempAppProvisioningForms = tempApp.getProvisioningForms();\n    \n                  if (tempAppProvisioningForms != null) {\n                      app.setProvisioningForms(tempAppProvisioningForms);\n                  }\n              } catch (Exception e) {\n                  String message = \"Failed to set Provisioning Forms for the application: \'\" + app.getName() + \"\'.\";\n                  log.error(message, e);\n                  throw new GeneralException(message, e);\n              }\n          }\n\n          log.debug(\"Exiting setProvisioningForms()...\");\n      }\n\n      /**\n       * Trigger aggregation.\n       */\n      private void triggerAggregation(List aggregationappList) {\n          String appsToaggregate = Util.listToCsv(aggregationappList);\n          // Trigger account aggregation\n          if (triggerAccountAggregation) {\n              executeAccountAggregation(appsToaggregate);\n          }\n\n          // Trigger group aggregation\n          if (triggerGroupAggregation) {\n              executeGroupAggregation(appsToaggregate);\n          }\n      }\n\n      /**\n       * Update task result of Create/Update Applications.\n       */\n      private void updateTaskResult() {\n          log.debug(\"Entering updateTaskResult()...\");\n\n          if (applicationsFailed.size() > 0) {\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n              if (create.equals(operation)) {\n                  taskResult.addMessage(Message.error(\"application_builder_create_failed_error\", applicationsFailed.size()));\n              } else if (update.equals(operation)) {\n                  taskResult.addMessage(Message.error(\"application_builder_update_failed_error\", applicationsFailed.size()));\n              }\n          } else if (applicationsExists.size() > 0) {\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);\n              taskResult.addMessage(Message.warn(\"application_builder_create_warning_msg\", filePath));\n          } else if (applicationsNotFound.size() > 0) {\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Warning);\n              taskResult.addMessage(Message.warn(\"application_builder_update_warning_msg\", filePath));\n          } else {\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n          }\n\n          if (create.equals(operation)) {\n              taskResult.setInt(\"applicationsCreated\", applicationsCreated);\n              taskResult.setAttribute(\"applicationsExists\", Util.listToCsv(applicationsExists));\n          } else if (update.equals(operation)) {\n              taskResult.setInt(\"applicationsUpdated\", applicationsUpdated);\n              taskResult.setAttribute(\"applicationsNotFound\", Util.listToCsv(applicationsNotFound));\n          } else if (read.equals(operation)) {\n              taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n              taskResult.setAttribute(\"applicationsScanned\", applicationMap.size());\n              taskResult.setAttribute(\"exportFilePath\", filePath);\n          }\n\n          taskResult.setAttribute(\"applicationsFailed\", Util.listToCsv(applicationsFailed));\n          log.debug(\"Exiting updateTaskResult()...\");\n      }\n\n      /////////////////// MAIN START /////////////////\n      ////////////////////////////////////////////////\n\n\n      log.debug(\"Application Builder Rule execution start...\");\n\n      try {\n          // Retriving input parameters\n          filePath = inputParams.get(\"filePath\");\n          applicationType = inputParams.get(\"applicationType\");\n          operation = inputParams.get(\"operation\");\n          triggerAccountAggregation = inputParams.get(\"triggerAccountAggregation\");\n          triggerGroupAggregation = inputParams.get(\"triggerGroupAggregation\");\n          launcher = inputParams.get(\"launcher\");\n          skipTestConnection = inputParams.get(\"skipTestConnection\");\n\n          if (!(filePath.trim().endsWith(\".csv\") || filePath.trim().endsWith(\".CSV\"))) {\n              throw new GeneralException(\"Invalid input file format \'\" + filePath + \"\'. Only CSV format is supported.\");\n          }\n\n          if (inputParams.get(\"applicationsPerAggregation\") != null) {\n              try {\n                  if (Integer.parseInt(inputParams.get(\"applicationsPerAggregation\")) > 0) {\n                      applicationsPerAggregation = Integer.parseInt(inputParams.get(\"applicationsPerAggregation\"));\n                  }\n              } catch (NumberFormatException e) {\n                  log.warn(\"Invalid value for the attribute \'applicationsPerAggregation\'. \" + e.getMessage() + \". Considering default value \" + applicationsPerAggregation , e);\n              }\n          }\n\n          // Update Secrete attribute list as per sailpoint.object.Application\n          secreteAttributes.add(\"password\");\n          secreteAttributes.add(\"cmdClientPassword\");\n          secreteAttributes.add(\"adminPassword\");\n          secreteAttributes.add(\"apikey\");\n          secreteAttributes.add(\"kid\");\n          secreteAttributes.add(\"secret\");\n          secreteAttributes.add(\"keystorePwd\");\n          secreteAttributes.add(\"token\");\n          secreteAttributes.add(\"transportUserPassword\");\n          secreteAttributes.add(\"group.password\");\n          secreteAttributes.add(\"accountId\");\n          secreteAttributes.add(\"keystorepassword\");\n          secreteAttributes.add(\"pkeypassword\");\n          secreteAttributes.add(\"admin_password\");\n          secreteAttributes.add(\"SudoUserPassword\");\n          secreteAttributes.add(\"PassphraseForPrivateKey\");\n          secreteAttributes.add(\"passwd\");\n\n          // Add application objects to list, special handling for merge is required.\n          applicationObjects.add(schemasHeader);\n          applicationObjects.add(provisioningFormsHeader);\n\n          // Perform Task based on operation type\n          switch (operation) {\n              case create:\n                  parseInputFile();\n                  createApplications();\n                  break;\n              case update:\n                  parseInputFile();\n                  updateApplications();\n                  break;\n              case read:\n                  updateAttributesMap();\n                  exportApplications();\n                  break;\n              default:\n                  log.debug(\"Invalid Operation.\");\n                  break;\n          }\n      } catch (GeneralException e) {\n          log.error(Message.error(\"application_builder_task_error\", e.getMessage()), e);\n\n          // Update taskResult object with error details\n          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n          taskResult.addMessage(Message.error(\"application_builder_task_error\", e.getMessage()));\n      } catch (Exception e) {\n          GeneralException ex = new GeneralException(Message.error(\"application_builder_task_error\", e.getMessage()), e);\n          log.error(ex.getMessage(), ex);\n\n          // Update taskResult object with error details\n          taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n          taskResult.addMessage(Message.error(\"application_builder_task_error\", e.getMessage()));\n      }\n\n      return taskResult;\n    \n  ',NULL,' ',NULL,'TaskResult'),('4028810371de849b0171dedd0aec0018',1588581960428,1739425338747,NULL,NULL,NULL,'UserID-and-Password-Creation','Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.\n\nOne common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).\n\nAnother common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.','beanshell','import java.util.List;\n  import java.util.Random;\n  import sailpoint.object.Custom;\n  import sailpoint.object.Filter;\n  import sailpoint.object.Identity;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.tools.GeneralException;\n\n  // change the name to a combination of firstname and lastname\n  String firstname = account.getStringAttribute(\"givenName\");\n  String lastname = account.getStringAttribute(\"sn\");\n\n  static String getRandomUID(){\n      String id =  firstname.substring(0,1) + lastname.substring(0,3);\n\n      Random random = new Random();\n      //array that will hold the symbols\n      char[] symbols = null;\n\n      StringBuilder tmp = new StringBuilder();\n      for (char ch = \'0\'; ch <= \'9\'; ++ch){\n      tmp.append(ch);\n      }\n\n      symbols = tmp.toString().toCharArray();\n\n      for (int idx = 0; idx < 3; ++idx) \n        id += symbols[random.nextInt(symbols.length)];\n\n  return id;\n\n  }\n\n  String getNewEnterpriseUUID( ) throws GeneralException{\n  int count = 0;\n  String uuid = getRandomUID();\n    \n  while( isDuplicate( uuid ) ){\n  	uuid = getRandomUID();\n  }\n  return uuid.toLowerCase();\n  }  \n\n  boolean isDuplicate( String uuid ) throws GeneralException{\n   \n 		return isPresentInIIQ(uuid);\n  }  \n\n  boolean isPresentInIIQ(String uuid) throws GeneralException{\n\n  QueryOptions ops = new QueryOptions();\n  Filter nameFilter = Filter.or(Filter.eq(\"name\", uuid), Filter.eq(\"name\", uuid.toLowerCase()));\n  Filter concatFilter=Filter.or(nameFilter,Filter.eq(\"name\", uuid.toUpperCase()) );\n  Filter caseFilter = Filter.ignoreCase(concatFilter);\n  ops.addFilter(caseFilter);\n  int numMatched = context.countObjects(Identity.class, ops);\n  if(numMatched > 0) {\n  return true;\n  }\n  else {\n  return false;\n  }\n  }  \n\n  String mail= firstname + \".\" + lastname + \"@sweinc.4u.com\";\n\n  identity.setEmail(mail);\n\n  String uuid = getNewEnterpriseUUID();\n\n  if( uuid != null )\n       identity.setName( uuid );\n\n  identity.setAttribute(\"employeeid\",uuid);\n  identity.setPassword(\"Smile@123\");','IdentityCreation',' ',NULL,'void'),('4028810371e92d520171ee632e74002d',1588842409588,1739425317326,NULL,NULL,NULL,'Decrypt',NULL,'beanshell','\nimport java.util.*;\nimport sailpoint.object.*;\n\n\nString data = \"1:nbZ1jQGAlhhtDW7kpGiVaw==\";\n\nreturn context.decrypt(data);\n ',NULL,' ',NULL,NULL),('402881866e97d43a016e9c4722970007',1574579937944,1739425306014,NULL,NULL,NULL,'Add Users to Workgroup',NULL,'beanshell','\n	import java.io.*;\n	import java.util.*;\n	import sailpoint.object.*;\n\n\n	String tskMsg = \"\";\n	String filePath=\"\\\\\\\\E:\\\\Data\\\\test.csv\";\n\n	if(config.get(\"filePath\") != null){\n	filePath =  config.get(\"filePath\").toString();\n	}\n\n	File testFile = new File(filePath);\n\n	if ((!testFile.exists()) || (testFile.isDirectory())) {\n		System.out.println(\"Unable to find file: \" + filePath);\n		taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n		taskResult.setProgress(\"Done launching task: \"+tskMsg);\n		taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n		return;\n	}\n\n	BufferedReader fileIn = new BufferedReader(new FileReader(filePath));\n	String l=\"\";    \n	  \n	while((l=fileIn.readLine())!=null){  \n	System.out.print(l+\"\\n\"); \n\n	String user = l.split(\",\")[0];\n	String group = l.split(\",\")[1];\n\n	if(null != user && null != group){\n		Identity identity = context.getObjectByName(Identity.class,user);\n		Identity workgroupIdentity = context.getObjectByName(Identity.class,group);\n					\n		if(null != identity && null != workgroupIdentity){\n		  tskMsg = tskMsg + \"user: \"+user+\" to workgroup: \"+group+\"\\r\\n\";\n		  identity.add(workgroupIdentity);\n		  context.saveObject(identity);\n		  context.commitTransaction();\n		  context.decache(identity);\n		  context.decache(workgroupIdentity);\n		}\n	}\n\n	}  \n\n\n\n	fileIn.close(); \n\n\n	taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n	taskResult.setProgress(\"Done launching task: \"+tskMsg);\n    taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n    context.saveObject(taskResult); 	\n	\n	return \"Success\";\n','Correlation',' ',NULL,NULL),('4028ab1063f427af0163f428e5610131',1528809710945,1617705337989,NULL,NULL,NULL,'No Correlator',NULL,'beanshell',NULL,'Correlation',' ',NULL,NULL),('4028ab1063f427af0163f428e67b0132',1528809711228,1739425316209,NULL,NULL,NULL,'Clear CustomGlobal',NULL,'beanshell','\n      \n        import sailpoint.object.CustomGlobal;\n\n        List results = new ArrayList();\n        results.add(\"CustomGlobal BEFORE clear had [\"+\n                    CustomGlobal.size() + \"] keys.\");\n        CustomGlobal.clear();\n        results.add(\"CustomGlobal AFTER clear has [\" +\n                   CustomGlobal.size()+\"] keys.\");\n\n        return results;\n      \n    ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f428f1ca0152',1528809714123,1739425322486,NULL,NULL,NULL,'IdentityNowSAML',NULL,'beanshell','\n        \n            // Imports\n            import sailpoint.object.Identity;\n\n            // Making a BIG assumption here that the nameid-format is unspecified/persitent\n\n            // Get the nameId from the assertionAttributes\n            String nameId = (String)assertionAttributes.get(\"nameId\");\n\n            Identity ident;\n\n            if(nameId != null) {\n                // Lookup the identity based on nameId\n                ident = context.getObject(Identity.class, nameId);\n            }\n\n            return ident;\n\n        \n    ','SAMLCorrelation',' ',NULL,NULL),('4028ab1063f427af0163f428ff3d017b',1528809717566,1739425342200,NULL,NULL,NULL,'Workflow Library',NULL,'beanshell','\n    \n      import sailpoint.object.Filter;\n      import sailpoint.object.Identity;\n      import sailpoint.object.ProvisioningPlan;\n      import sailpoint.object.ProvisioningPlan.AccountRequest;\n      import sailpoint.object.ProvisioningPlan.AttributeRequest;\n      import sailpoint.object.QueryOptions;\n      import sailpoint.tools.Util;\n\n      boolean otob(Object o) { return Util.otob(o); }\n      boolean isTrue(Object o) {otob(o); } \n      boolean isFalse(Object o) {!otob(o); }\n      boolean isNull(Object o) {o == null; } \n      int size(Collection o) { return Util.size(o); }\n      String toString(Object o) {(o == null) ? \"*null*\" : o.toString(); }\n      void println(Object o) {System.out.println(o); }\n      void print(String str) { System.out.print(str); }\n      void printval(String n, Object o) {println(n + \" = \" + toString(o)); }\n\n\n      public List csvToList(String csv) {\n        return Util.csvToList(csv);\n      }\n\n      /** \n       * resolve displayName by doing a projection query.\n       */ \n      public String resolveDisplayName(String identityName) {\n          String displayName = getIdentityProperty(identityName, \"displayName\"); \n          if ( displayName == null ) {\n              displayName = identityName;\n          }\n          return displayName;\n      }\n      \n      /** \n       * If the identityDisplayName is null resolve it by doing\n       * a projection query.\n       */ \n      public String resolveDisplayName(String identityName, String currentDisplayName) {\n          // allow it to be passed in to avoid the query\n          String displayName = null;\n          if ( currentDisplayName != void ) {\n              displayName = currentDisplayName;\n          }\n          if ( displayName == null ) {\n              displayName = resolveDisplayName(identityName);\n          }\n          return displayName;\n      }\n\n      /**\n       * Given an Identity\'s name, return the email address.\n       */\n      public String getEmail(String name) {\n          return getIdentityProperty(name, \"email\");\n      }\n\n      /**\n       * Given an Identity\'s name and a ProvisioningPlan, return the email address.\n       * This can be used for user notifications when a request to create an\n       * identity was rejected.  In this case there will not be an identity in\n       * the database, so we will try to extract the email address from the plan.\n       */\n      public String getUserEmail(String name, ProvisioningPlan plan) {\n          String email = getEmail(name);\n\n          if (null == email) {\n              email = getIIQCreateRequestValue(plan, \"email\");\n          }\n\n          return email;\n      }\n\n      /**\n       * Given an Identity\'s name, return the manager\'s email address.\n       */\n      public String getManagersEmail(String name) {\n          return getIdentityProperty(name, \"manager.email\"); \n      }\n\n      /**\n       * Given an Identity\'s name, return the manager\'s email address.\n       * This can be used for user notifications when a request to create an\n       * identity was rejected.  In this case there will not be an identity in\n       * the database, so we will try to extract the manager from the plan to\n       * lookup the email address.\n       */\n      public String getManagersEmail(String name, ProvisioningPlan plan) {\n          String email = getManagersEmail(name);\n\n          if (null == email) {\n              String manager = getIIQCreateRequestValue(plan, \"manager\");\n              if (null != manager) {\n                  Identity identity = context.getObject(Identity.class, manager);\n                  if (null != identity) {\n                      email = identity.getEmail();\n                  }\n              }\n          }\n\n          return email;\n      }\n\n      /**\n       * Return the value for the requested attribute from the ProvisioningPlan\n       * if this is an identity creation request.\n       */\n      private String getIIQCreateRequestValue(ProvisioningPlan plan, String attr) {\n          String value = null;\n\n          if (null != plan) {\n              AccountRequest acctReq = plan.getIIQAccountRequest();\n              if ((null != acctReq) &&\n                  AccountRequest.Operation.Create.equals(acctReq.getOperation())) {\n                  AttributeRequest attrReq = acctReq.getAttributeRequest(attr);\n                  if (null != attrReq) {\n                      value = (String) attrReq.getValue();\n                  }\n              }\n          }\n\n          return value;\n      }\n\n      /** \n       * Return a single string property value from an identity.\n       */\n      public String getIdentityProperty(String identity, String property) {\n          QueryOptions ops = new QueryOptions();\n          Filter nameFilter = Filter.eq(\"name\", identity);\n          ops.add(new Filter[]{nameFilter});\n\n          String val = null; \n          Iterator it = context.search(Identity.class, ops, property);\n          while ( it.hasNext() ) {\n              Object[] row = (Object[])it.next();\n              val = (String)row[0];\n              if ( it.hasNext() ) {\n                  // shouldn\'t happen but guard\n                  throw new GeneralException(\"More then one [\"+property+\"] value returned for [\"+identity+\"]\");\n              }\n          } \n          return val;\n      }\n\n      /**\n       * Return the value of a system configuration property.\n       * The value is always returned as a string.\n       */\n      public String getConfiguration(String name) {\n          return context.getConfiguration().getString(name);\n      }\n\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f429000d017c',1528809717774,1739433078000,NULL,NULL,NULL,'Approval Library',NULL,'beanshell','\n    \n\n    import sailpoint.api.ManagedAttributer;\n    import sailpoint.object.Application;\n    import sailpoint.object.ApprovalSet;\n    import sailpoint.object.ApprovalItem;\n    import sailpoint.object.AttributeDefinition;\n    import sailpoint.object.Attributes;\n    import sailpoint.object.Bundle;\n    import sailpoint.object.Identity;\n    import sailpoint.object.ManagedAttribute;\n    import sailpoint.object.ProvisioningPlan;\n    import sailpoint.object.ProvisioningPlan.AccountRequest;\n    import sailpoint.object.ProvisioningPlan.AttributeRequest;\n    import sailpoint.object.ProvisioningPlan.PermissionRequest;\n    import sailpoint.object.ProvisioningPlan.GenericRequest;\n    import sailpoint.object.ProvisioningProject;\n    import sailpoint.object.Scope;\n    import sailpoint.object.WorkItem;\n    import sailpoint.object.Workflow;\n    import sailpoint.object.Workflow.Approval;\n    import sailpoint.tools.Util;\n    import sailpoint.tools.xml.XMLObjectFactory;\n    \n    /** \n    * Take a list of AttributeRequests and return a List of Attributes\n    * to store on the approval item so that we can get at the attributes of\n    * each attribute request in case we need information about that attribute request\n    */\n    public Attributes getAttributeRequestArguments(List attributeRequests) {\n      Attributes attributes = new Attributes();\n      for(AttributeRequest attr : attributeRequests) {\n        String key = attr.getName()+\":\"+attr.getValue();\n        Attributes arguments = attr.getArguments();\n        attributes.put(key, arguments);\n      }\n      return attributes;\n    }\n\n    /**\n     * Turn a list of AttributeRequests into simple\n     * name = \'value\' format. Represent this as a list\n     * so we can display it neatly in the ui tier and\n     * still not mess with dn strings.\n     *\n     * A general utility method used both by rules and workflow\n     * scripts.  \n     */\n    public List flattenAttributeRequests(List attributeRequests) {\n        List flat = new ArrayList();\n        flattenAttributeRequests(attributeRequests, flat);\n        return flat;\n    }\n    \n    /**\n    *  Bug 15833, ensure requester comments make it into manual actions\n    */\n    public String getRequesterComments(List requests) {\n        String comment = \"\";\n        if(requests != null) {\n            for(GenericRequest request : requests) {\n                String innerComment = request.getComments();\n                if ( Util.getString(innerComment) != null ) {\n                    comment += innerComment;\n                }\n            }\n        }\n        return comment;\n    }\n        \n    public void flattenAttributeRequests(List attributeRequests, List flat) {\n        if ( Util.size(attributeRequests) > 0 ) {\n            for (AttributeRequest attr : attributeRequests ) {\n                if( !attr.getName().equals(ProvisioningPlan.ATT_IIQ_PASSWORD) &&\n                    !attr.getBoolean(ProvisioningPlan.ARG_SECRET) &&\n                    !attr.getName().equals(Identity.PRF_USE_BY_DATE)) {\n                    if (attr.getDisplayValue() == null) {\n                        String displayName = attr.getName();\n                        List val = Util.asList(attr.getValue());\n                        if ( val != null ) {\n                            if ( attr.getName().equals(\"manager\") ) { \n                                String managerName = null;\n                                if ( Util.size(val) == 1 ) {\n                                    // For manager convert the name into a displayName so it looks \n                                    // reasonable in the ui\n                                    managerName = (String)val.get(0);\n                                    if ( manager != null ) {\n                                        String displayName = getIdentityProperty(managerName, \"displayName\");\n                                        if ( displayName != null ) {\n                                            val = Util.csvToList(displayName);\n                                        }\n                                    }\n                                }\n                            }\n                            \n                            String type = (String)attr.get(ProvisioningPlan.ARG_TYPE);\n                            if (type!=null && type.equals(ProvisioningPlan.ARG_TYPE_DATE)) {\n                              Object obj = val.get(0);\n                              \n                              Date date = null;\n                              \n                              if(obj instanceof java.util.Date) {\n                                date = obj;\n                              } else {\n                                date = new Date((Long)obj);\n                              }\n                              val = new ArrayList();                         \n                              val.add(Util.dateToString(date, \"M/d/y\"));\n                            } else if (AttributeDefinition.TYPE_SCOPE.equals(type)) {\n                              val = getScopeNames(val);  \n                            }\n                            \n                        }\n                        if ( Util.size(val) > 0 ) \n                            flat.add(displayName+ \" = \'\"+Util.listToCsv(val)+\"\'\");\n                    } else {\n                        flat.add(attr.getDisplayValue());\n                    }\n                }\n            }\n        }\n    }\n    \n    /*\n     * Given a list of scope ids it will return a list of \n     * scope names.\n     *\n     */\n    public List getScopeNames(List val) {\n        \n        if (val == null) {\n            return null;\n        }\n\n        List scopeNames = new ArrayList();\n        for (int i=0; i<val.size(); ++i) {\n            scopeNames.add(fetchScopeName((String) val.get(i)));\n        }\n        \n        return scopeNames;\n    }\n\n    /**\n     * Fetches a scope name from scope id\n     *\n     */    \n    private String fetchScopeName(String id) {\n        \n        Scope scope =  context.getObjectById(Scope.class, id);\n        \n        if (scope == null) {\n            return null;\n        }\n        \n        return scope.getDisplayableName();\n    }\n\n    /**\n     * Convert a List<PermissionRequests> into a List<String>\n     * with each string formatted as \"target=\'right,right,right\'\"\n     * This is similar to flattenAttributeRequests above but \n     * kept distinct in case we need to change the rendering of permissions.\n     * Currently it\'s ambiguous whether this is an attribute or a permission\n     */\n    public void flattenPermissionRequests(List permRequests, List flat) {\n\n        if (permRequests != null) {\n            for (PermissionRequest perm : permRequests ) {\n\n              // we dont\' have display names for targets, do we?\n              flat.add(perm.getTarget() + \" = \'\" + perm.getRights() + \"\'\");\n            }\n        }\n    }\n\n    /**\n     * Convert a Map<String,ApprovalSet> into Approval objects. \n     * One Approval object for each of the keys in the map.\n     *\n     * Used only by rules that calculate approval structures such\n     * as LCM Build Owner Approvals.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    public List buildApprovalsFromMap(Map ownerToSet, String identityName, String launcher) {\n        List approvals = new ArrayList();\n        if ( ownerToSet == null ) \n            return null;\n\n        Iterator keys = null;\n        Set keySet = ownerToSet.keySet();\n        if ( keySet != null )  \n            keys = keySet.iterator();\n\n        if ( keys != null ) {\n            while ( keys.hasNext() ) {\n                String key = (String)keys.next();\n                if ( key == null ) continue;\n                ApprovalSet set = ownerToSet.get(key);\n                if ( set != null ) {\n                    if ( log.isDebugEnabled() ) {\n                        log.debug(\"Owner[\"+key+\"] \" + set.toXml());\n                    }\n                    // djs: check here to make sure this isn\'t an auto-approved \n                    // item because the approver is the launcher\n                    if ( !sailpoint.workflow.IdentityLibrary.isElectronicSignatureEnabled(wfcontext) && \n                         key.compareTo(launcher) == 0 && \n                         set.isAllApproved() ) {\n                        // self approved continue;\n                        continue;\n                    } else {\n                        Approval newApproval = new Approval();\n                        newApproval.setOwner(\"\\\"\" + key + \"\\\"\");  // quote the owner in case the user name has a comma\n                        newApproval.setApprovalSet(set);\n                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_CLASS, \"sailpoint.object.Identity\");\n                        newApproval.addArg(Workflow.ARG_WORK_ITEM_TARGET_NAME, identityName);\n                        approvals.add(newApproval);\n                    } \n                }\n            }\n        }\n        if ( log.isDebugEnabled() ) {\n            if ( approvals != null )\n                log.debug(\"Approvals: \" + XMLObjectFactory.getInstance().toXml(approvals));\n            else\n                log.debug(\"Approvals EMPTY.\");\n        }\n        return approvals;\n    }\n\n    /**\n     * Build a Map<String,ApprovalSet> each key representing a unique owner.\n     * Use a Map here to allow us to easily merge any items for the same owner.\n     *\n     * Used by rules to build approval structures, normally followed by\n     * a call to buildApprovalsFromMap.\n     * \n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    public Map buildOwnerMap(String scheme, ApprovalSet approvalSet, \n                             ProvisioningPlan plan, String fallbackApprover, \n                             String identity, boolean autoApprove) {\n\n        // djs: use a LinkedHashMap here to perserve the order of the\n        // approvers in the list.  This is important for manager transfer\n        // approvals.\n        Map ownerToSet = new LinkedHashMap();\n        List items = approvalSet.getItems();\n        for ( ApprovalItem item : items ) {\n            List approvers = getApproverNames(scheme, item, plan, identity);\n            if ( approvers != null && approvers.size() == 0 && fallbackApprover != null ) {\n                if ( log.isDebugEnabled() ) {\n                    log.debug(\"Approver could not be resolved using fallbackApprover \'\"+fallbackApprover+\"\'.\");\n                }\n                approvers.add(fallbackApprover);\n            }\n            //\n            // Build an approval set or add an ApprovalItem \n            // to an existing set\n            //\n            if ( Util.size(approvers) > 0 ) {\n                for ( String approver : approvers ) {\n                    ApprovalSet set = (ApprovalSet)ownerToSet.get(approver);\n                    if ( set == null ) {\n                        set = new ApprovalSet();\n                    }\n\n                    // Make a copy of the item here so they are independent of the the\n                    // cart\'s item.  \n                    ApprovalItem itemCopy = XMLObjectFactory.getInstance().clone(item, context);\n                    set.add(itemCopy);\n                    ownerToSet.put(approver, set);\n                    if ( autoApprove ) {\n                        // djs: when we come across the launcher who is also the approver\n                        // auto approve the item, this will allow us to audit/report on\n                        // the request but not force an approval.  We won\'t create an \n                        // Approval object if all of the items are acccepted\n                        if ( approver.equals(launcher) ) {\n                            itemCopy.setState(WorkItem.State.Finished);\n                            if ( log.isDebugEnabled() ) {\n                                log.debug(\"Launcher was also approver and was removed.\");\n                            }\n                            // If there is just one approver AND we are marking this \n                            // Auto-Approved also mark the master approvalSets item \n                            // finished\n                            if ( approvers.size() == 1 ) {\n                                item.setState(WorkItem.State.Finished);\n                            }\n                        }\n                    }\n                }\n                //\n                // Update the \"cart\" representation\n                //\n                // set the item\'s owner so we have an update\n                // version in the \"registry\"\n                // Should we store a csv Multiple approvers ?\n                item.setOwner(approvers.get(0));\n            }\n        }\n        if ( log.isDebugEnabled() ) {\n            if ( ownerToSet != null )\n                log.debug(\"OwnerSetMap: \" + XMLObjectFactory.getInstance().toXml(ownerToSet));\n            else\n                log.debug(\"OwnerSetMap EMPTY.\");\n        }\n        return ownerToSet;\n    }\n\n    /**\n     * Return a list of names that represent the names of the Identities that should\n     * approve the item.  We need the Plan during manager transfers when we need to figure\n     * out what the new value is for the manager attribute.\n     *\n     * Only time the returned list is null is when we have \"none\"\n     * approval scheme.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan, String identity) {\n        return getApproverNames(scheme, item, plan, identity, null);\n    }\n\n    /**\n     * Return a list of names that represent the names of the Identities that should\n     * approve the item.  We need the Plan during manager transfers when we need to figure\n     * out what the new value is for the manager attribute.\n     *\n     * Only time the returned list is null is when we have \"none\"\n     * approval scheme.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    public List getApproverNames(String scheme, ApprovalItem item, ProvisioningPlan plan,\n                                 String identity, String securityOfficerName) { \n\n        List owners = new ArrayList();\n        String schemeToUse = scheme;\n        if ( schemeToUse == null ) {\n            schemeToUse = \"manager\";\n            log.warn(\"Approval Scheme was not defined defaulting to manager.\");\n        }\n        List schemes = Util.csvToList(schemeToUse);\n\n        // None will short-circuit and cause no approvals.\n        if ( schemes.contains(\"none\") ) {\n            return null;\n        } \n\n        if ( ( schemes.contains(\"manager\") ) || ( schemes.contains(\"newManager\") ) ) {\n            List managers = getManagers(schemes, plan, identity);\n            if ( null != managers ) { \n                owners.addAll(managers);\n            } \n        }\n\n        if ( schemes.contains(\"owner\") ) {\n            String app = item.getApplication(); \n            String op = item.getOperation();\n            if ( ProvisioningPlan.APP_IIQ.compareTo(app) == 0 ) { \n                if ( ( ProvisioningPlan.Operation.Add.toString().equals(op) ) || \n                     ( ProvisioningPlan.Operation.Remove.toString().equals(op) ) ) {\n                    // this is a role requst, entitlement request or identity update\n                    if ( ( ProvisioningPlan.ATT_IIQ_DETECTED_ROLES.equals(item.getName()) ) ||\n                         ( ProvisioningPlan.ATT_IIQ_ASSIGNED_ROLES.equals(item.getName()) ) ) {\n                        String owner = resolveRoleOwner(item);\n                        if ( owner != null ) owners.add(owner);\n                    } \n                }\n           } else {\n               String owner = resolveAppRequestOwner(item);\n               if ( owner != null ) \n                  owners.add(owner);\n           }\n        }\n\n        if ( schemes.contains(\"securityOfficer\") ) {\n            if (null == securityOfficerName) {\n                log.warn(\"Security officer approval is configured but securityOfficerName is not defined.\");\n            }\n            else {\n                // Only use the security officer if it is a real identity.\n                Identity officer = context.getObjectByName(Identity.class, securityOfficerName);\n                if (null == officer) {\n                    log.warn(\"Could not find securityOfficer: \" + securityOfficerName);\n                }\n                else {\n                    owners.add(securityOfficerName);\n                }\n            }\n        }\n\n        return owners;\n    }\n\n    /**\n     * Helper for getApproverNames.\n     * From the item figure out the owner that should be assigned\n     * to this application request.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    private String resolveAppRequestOwner(ApprovalItem item) {\n        String approverName = null;\n\n        String appName = item.getApplication();\n        if ( appName == null ) return null;\n\n        Application application = context.getObjectByName(Application.class, appName);\n        if ( application == null ) \n            throw new Exception(\"Couldn\'t find application [\"+appName+\"]\");\n\n        Identity owner = application.getOwner();\n        if ( owner != null ) {\n            approverName = owner.getName();\n        } else {\n            // unable to find owner for application foo...\n            log.debug(\"Unable to find owner for application [\"+appName+\"]\");\n        }\n\n        // Check the attributeName and value and check to see if we are dealing with \n        // a ManagedAttribute \n        String attrName = item.getName();\n        List vals = item.getValueList();\n        if ( ( attrName != null ) && ( Util.size(vals) > 0 ) ) {\n            // there should just be one value in each record... \n            // log something\n            String val = (String)vals.get(0);\n            String maOwner = getManagedAttributeOwner(application, attrName, val);\n            if ( maOwner == null) {\n                log.debug(\"Managed Attribute owner not found.. falling back to app owner.\");\n            } else {\n                approverName = maOwner;\n            }\n        }\n        return approverName;\n    }\n\n    /**\n     * Helper for resolveAppRequestOwner.\n     * Use the ManagedAttributer to find the managed attribute and get the\n     * owner from the ManagedAttribute.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    private String getManagedAttributeOwner(Application app, String name, String value ) {\n        String owner = null;\n        ManagedAttribute ma = ManagedAttributer.get(context, app.getId(), name, value);\n        if ( ma != null ) {\n            Identity maOwner = ma.getOwner();\n            if ( maOwner != null ) \n                owner = maOwner.getName();\n        }\n        return owner;\n    }\n\n    /**\n     * Helper for getApproverNames.\n     * If its a role request look up the role by name and get the owner\n     * from the Role object.  \n     *\n     * TODO: should I walk up the hierarchy here if ther isn\'t \n     * one on the Bundle?\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    private String resolveRoleOwner(ApprovalItem item) {\n        String approverName = null;\n        List values = item.getValueList();\n        if ( Util.size(values) > 0 ) {\n            if ( Util.size(values) != 1 ) \n                throw new Exception(\"More then one value found in an approval item\");\n\n            String roleName = (String)values.get(0);\n            if ( roleName != null ) {\n                Bundle b = context.getObjectByName(Bundle.class, roleName);\n                if ( b != null ) {\n                    Identity id = b.getOwner();\n                    if ( id != null ) {\n                        approverName = id.getName();\n                    }\n                }\n            }\n        }\n        return approverName;\n    }\n\n    /**\n     * Helper for getApproverNames.\n     * Get the value for manager or other by resolving the identity\n     * and computing the manager, or validating the value\n     * in the approvalScheme variable;\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    private List getManagers(List schemes, ProvisioningPlan plan, String identity) {\n        //  \n        //  During Identity Creates the Identity object does not exist\n        //    In this case we have to look at the plan and see if one is assigned\n        //    if not assigned default to the fallbackApprover\n        // \n        //  During Updates there could be one or two managers in play\n        //    1) Newly assigned manager (which is still in the plan)\n        //    2) Currently assigned manager ( assigned to the identity )\n        //    \n        List approverNames = new ArrayList();\n\n        String currentManager = null;\n        // Use the identities manager to resolve the approval\n        Identity identityObject = context.getObject(Identity.class, identity);\n        if ( identityObject != null ) {\n            Identity manager = identityObject.getManager();\n            if ( manager != null ) {\n                currentManager = manager.getName();\n            } else {\n                log.debug(\"Manager not found for [\"+identityObject.getName()+\"] while computing approval\");\n            }\n        }\n\n        String planManager = resolveManagerFromPlan(plan);\n        if ( ( currentManager == null ) && ( planManager != null ) ) {\n            // likely Identity Create case\n            approverNames.add(planManager);\n        } else\n            if ( ( currentManager != null ) && ( planManager == null ) ) {\n                // normal case\n                approverNames.add(currentManager);\n            } else\n                if ( ( currentManager != null ) && ( planManager != null ) ) {\n                    // Manager Transfer\n                    if ( schemes.contains(\"manager\") ){\n                        approverNames.add(currentManager);\n                    }\n                    if ( schemes.contains(\"newManager\") ){\n                        approverNames.add(planManager);\n                    } \n                }\n        return ( approverNames.size() > 0 ) ? approverNames : null;\n    }\n\n    /**\n     * Helper for getManagers.\n     * Dig into the plan and find the manager attribute for the IIQ\n     * app if present. This is used during manager transfers\n     * where we need to know the new manager so they can be \n     * part of the approval process.\n     *\n     * NOTE:\n     * As of 6.2 this rule has been deprecated and replaced with\n     * IdentityLibrary.buildXYZApproval methods.  Most of the\n     * logic here has been moved to \n     * sailpoint.workflow.IdentityApprovalGenerator.\n     */\n    private String resolveManagerFromPlan(ProvisioningPlan plan )  {\n        String managerName = null;\n        if ( plan != null ) {\n            AccountRequest iiq = plan.getAccountRequest(ProvisioningPlan.APP_IIQ);\n            if ( iiq != null ) {\n                AttributeRequest manager = iiq.getAttributeRequest(\"manager\");\n                if ( manager != null ) {\n                    Object obj = manager.getValue();\n                    if ( obj != null ) {\n                        managerName = Util.getString(obj.toString());\n                    }\n                }\n            }\n        }\n        return managerName;\n    }\n\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f4290117017d',1528809718039,1739425311660,NULL,NULL,NULL,'Build Manual Action Approvals',NULL,'beanshell','\n    \n       import sailpoint.object.ApprovalSet;\n       import sailpoint.object.ApprovalItem;\n       import sailpoint.object.ProvisioningPlan;\n       import sailpoint.object.ProvisioningPlan.AccountRequest;\n       import sailpoint.service.ProvisioningTransactionService;\n       import sailpoint.service.ProvisioningTransactionService.TransactionDetails;\n       import sailpoint.workflow.IdentityLibrary;\n\n       //\n       // Attributes needed in the rule context: \n       //\n       // project - Provisioning Project\n       //\n       // fallbackApprover - String representing who gets the approval\n       //                    if we can\'t resolve one.  \n       //\n       // identityName - name of the identity being operated on\n       //\n\n       List approvals = null;\n       ProvisioningPlan unmanaged = project.getUnmanagedPlan();\n       if ( unmanaged != null ) {\n           // \n           // Build an ApprovalSet from each of the things in the plan \n           // \n           Identity id = context.getObject(Identity.class, identityName);\n           ApprovalSet set = new ApprovalSet();\n           for ( AccountRequest acctReq : unmanaged.getAccountRequests() ) {\n               ProvisioningTransactionService transService = new ProvisioningTransactionService(context);\n\n               AccountRequest account = new AccountRequest(acctReq.toMap());\n               if ( AccountRequest.Operation.Create.equals(account.getOperation()) ) {\n                   ApprovalItem item = new ApprovalItem();\n                   // need to deal with this \n                   item.setApplication(account.getApplication());\n                   item.setInstance(account.getInstance());\n                   item.setNativeIdentity(account.getNativeIdentity());\n                   AccountRequest.Operation op = account.getOperation();\n                   if (op == null) {\n                       // shouldn\'t be here but assume modify\n                       op = AccountRequest.Operation.Modify;\n                   }\n                   item.setOperation(op.toString());\n                   \n                   //MEH 15833, get those comments transferred to the new approval item!\n                   String requesterComments = null;\n                   String attrComments = getRequesterComments(account.getAttributeRequests());\n                   String permComments = getRequesterComments(account.getPermissionRequests());\n                   \n                   //only one of these should be set... ideally\n                   if(attrComments.length() > 0) {\n                      requesterComments = attrComments;\n                   }\n                   \n                   if(permComments.length() > 0) {\n                      requesterComments = permComments;\n                   }\n\n                   if(requesterComments == null) {\n                      if(account.getComments() != null) {\n                         requesterComments = account.getComments();\n                      }\n                   }\n\n                   item.setRequesterComments(requesterComments);\n\n                   List reqs = new ArrayList();\n                   \n                   flattenAttributeRequests(account.getAttributeRequests(), reqs);\n                   flattenPermissionRequests(account.getPermissionRequests(), reqs);\n\n                   item.setValue(reqs);\n                   set.add(item);\n               } else {\n                   // The default ApprovalSet builder creates an ApprovalItem for\n                   // every attribute/permission request\n                   IdentityLibrary.addApprovalItems(id, account, set);\n               }\n\n               TransactionDetails details = new TransactionDetails();\n               details.setIdentityName(identityName);\n               details.setProject(project);\n               details.setRequest(account);\n               details.setPartitionedPlan(unmanaged);\n               details.setManual(true);\n\n               if (project.getMasterPlan() != null) {\n                   details.setSource(project.getMasterPlan().getSource());\n               }\n\n               transService.logTransaction(details);\n           }\n           // \n           // Build a map of owner to ApprovalSet from each of the items\n           // in the unmanaged plan \n           // \n           // Default to the owner scheme, but we might need an option \n           // \n           Map ownerMap = buildOwnerMap(\"owner\", set, unmanaged, fallbackApprover, identityName, false);\n           if ( ownerMap != null ) {\n               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);\n           }\n       }\n       return approvals;\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f4290a5b018f',1528809720412,1739425325663,NULL,NULL,NULL,'LCM Workflow Library',NULL,'beanshell','\n    \n      import sailpoint.api.Provisioner;\n      import sailpoint.api.SailPointFactory;\n      import sailpoint.api.SailPointContext;\n      import sailpoint.object.ApprovalSet;\n      import sailpoint.object.ApprovalItem;\n      import sailpoint.object.AuditEvent;\n      import sailpoint.object.Comment;\n      import sailpoint.object.Field;\n      import sailpoint.object.Form;\n      import sailpoint.object.Filter;\n      import sailpoint.object.Identity;\n      import sailpoint.object.ProvisioningPlan;\n      import sailpoint.object.ProvisioningPlan.AccountRequest;\n      import sailpoint.object.ProvisioningPlan.AttributeRequest;\n      import sailpoint.object.ProvisioningProject;\n      import sailpoint.object.QueryOptions;\n      import sailpoint.object.SignOffHistory;\n      import sailpoint.object.Source;\n      import sailpoint.object.Workflow;\n      import sailpoint.object.Workflow.Approval;\n      import sailpoint.object.WorkItem;\n      import sailpoint.object.WorkItem.OwnerHistory;\n      import sailpoint.server.Auditor;\n      import sailpoint.tools.Util;\n      import sailpoint.workflow.IdentityLibrary;\n      import sailpoint.workflow.WorkflowContext;\n\n      /**\n       * Build an event per forward so there is a record \n       * that the owner changed from the original \n       * owner.\n       */\n      public void auditWorkItemOwnerHistory(WorkItem item) {\n          List ownerHistories = item.getOwnerHistory();\n          if ( Util.size(ownerHistories) > 0 ) {\n              String action = \"Forward\";\n              if ( Auditor.isEnabled(action) ) {\n                  for ( OwnerHistory history : ownerHistories ) {\n                      AuditEvent event = new AuditEvent();\n                      event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());\n                      event.setAction(action);\n                      event.setTarget(item.getTargetName());\n                      event.setAttribute(\"workitem\", item.getName());\n                      String oldOwner = history.getOldOwner();\n                      if ( oldOwner != null ) \n                          event.setAttribute(\"oldOwner\", oldOwner);\n                      String source = history.getEffectiveSource();\n                      event.setSource(source);\n                      String comment = history.getComment();\n                      if ( comment != null ) \n                          event.setAttribute(\"comment\", comment);\n                      String newOwner = history.getNewOwner();\n                      if ( newOwner != null ) \n                          event.setAttribute(\"newOwner\", newOwner);\n\n                      // djs: for now set this in both places to avoid needing\n                      // to upgrade.  Once we have ui support for \"interface\"\n                      // we can remove the map version\n                      event.setAttribute(\"interface\", Source.LCM.toString());\n                      event.setInterface(Source.LCM.toString());\n\n                      Auditor.log(event);\n                  }\n              }\n          }\n      }\n\n      /**\n       * Build a single \"comment\" event for all of the comments\n       * that were entered during a workitems lifecycle.\n       */\n      public void auditWorkItemComments(WorkItem item) {\n          List comments = item.getComments();\n          if ( Util.size(comments) > 0 ) {\n              String action = \"Comment\";\n              if ( Auditor.isEnabled(action) ) {\n                  AuditEvent event = new AuditEvent();\n                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());\n                  event.setAction(action);\n                  event.setTarget(item.getTargetName());\n                  event.setAttribute(\"workitem\", item.getName());\n\n                  List commentStrings = new ArrayList();\n                  for ( Comment comment : comments ) {\n                      commentStrings.add(comment.toString());\n                  }\n                  event.setAttribute(\"comments\", commentStrings);\n                  // djs: for now set this in both places to avoid needing\n                  // to upgrade.  Once we have ui support for \"interface\"\n                  // we can remove the map version\n                  event.setAttribute(\"interface\", Source.LCM.toString());\n                  event.setInterface(Source.LCM.toString());\n                  Auditor.log(event);\n              }\n          }\n      }\n\n      /**\n       * Determine the name to use as the \"source\" of an LCM work item\n       * completion audit.  This should be the name of the identity that\n       * closed the item.  This will be different than the item owner if the\n       * owner is a work group.\n       */\n     public String getAuditSource(WorkItem item) {\n\n         String actor = context.getUserName();\n         Identity ident = context.getObjectByName(Identity.class, actor);\n         if (ident != null)\n             actor = ident.getDisplayName();\n         else {\n             // must be in the background with a pseudo system name\n             // fall back to item owner\n             ident = item.getOwner();\n             if (ident != null)\n                 actor = ident.getDisplayName();\n             else \n                 actor = launcher;\n         }\n\n         return actor;\n     }\n\n      public void auditDecisions(WorkItem item) {\n          if ( item == null )  return; \n\n          // there is only one Signoff, duplicated for each approval item\n          SignOffHistory signoff = null;\n          List signoffs = item.getSignOffs();\n          if (signoffs != null && signoffs.size() > 0)\n              signoff = (SignOffHistory)signoffs.get(0);\n\n          ApprovalSet approvalSet = (ApprovalSet)item.get(\"approvalSet\");\n          if ( ( approvalSet != null ) && ( !approvalSet.isEmpty() ) ) {\n              for ( ApprovalItem it : approvalSet.getItems() ) {\n\n                  /** Assimilate the form field changes back into the attribute requests before\n                  * creating the audit event so that the correct data is stored in the audit event. **/\n                  List attrs = it.getIIQAttributes();\n                  Form form = (Form)item.get(\"workItemForm\");\n                  if(attrs!=null && form!=null) {\n                    for(AttributeRequest attr : attrs) {\n                      \n                      Field field = form.getField(it.getApplication()+\":\"+attr.getName());\n                      if(field!=null) {\n                        attr.setValue(field.getValue());\n                      }\n                    }\n                    it.setValue(flattenAttributeRequests(attrs));                 \n                  }\n                                    \n                  AuditEvent event = new AuditEvent();\n                  event.setAction(AuditEvent.ActionApproveLineItem);\n                  event.setSource(getAuditSource(item));\n                  event.setTarget(identityName);\n\n                  event.setApplication(it.getApplication());\n                  event.setAccountName(it.getNativeIdentity());\n                  event.setInstance(it.getInstance());\n                  event.setAttributeName(it.getName());\n                  event.setAttributeValue(it.getCsv());                  \n                  \n                  // electronic signature\n                  if (signoff != null) {\n                     String meaning = signoff.getText();\n                     if (meaning != null) {\n                         event.setAttribute(\"esignatureSigner\", \n                                            signoff.getSignerDisplayableName());\n                         event.setAttribute(\"esignatureText\", meaning);\n                         // what else, date?\n                     }\n                 }\n\n                  Date start = it.getStartDate();\n                  if ( start != null ) \n                      event.setAttribute(\"startDate\", start);\n                  Date end = it.getEndDate();\n                  if ( end != null ) \n                      event.setAttribute(\"endDate\", end);\n\n                  event.setAttribute(\"currentStep\", wfcontext.getStep().getName());\n\n                  // group them by a generatedId\n                  event.setTrackingId(wfcontext.getWorkflow().getProcessLogId());\n                  String interfaceName = wfcontext.getString(\"interface\");\n                  if ( interfaceName == null)\n                      interfaceName = Source.LCM.toString();\n\n                  // djs: for now set this in both places to avoid needing\n                  // to upgrade.  Once we have ui support for \"interface\"\n                  // we can remove the map version\n                  event.setAttribute(\"interface\", interfaceName);\n                  event.setInterface(interfaceName);\n\n                  event.setAttribute(\"operation\", it.getOperation());\n                  event.setAttribute(\"requester\", launcher);\n\n                  List comments = it.getComments();\n                  if ( Util.size(comments) > 0 ) {\n                      event.setAttribute(\"completionComments\", comments);\n                  }\n\n                  String requesterComments = it.getRequesterComments();\n                  if ( Util.getString(requesterComments) != null )\n                      event.setAttribute(\"requesterComments\", requesterComments);\n\n                  String taskResultId = wfcontext.getString(Workflow.VAR_TASK_RESULT);\n                  if ( taskResultId != null ) {\n                      event.setAttribute(Workflow.VAR_TASK_RESULT, taskResultId);\n                  }\n\n                  if ( !it.isApproved() ) {\n                      event.setAction(AuditEvent.ActionRejectLineItem);\n                  }\n\n                  if ( Auditor.isEnabled(event.getAction()) ) {\n                      Auditor.log(event);\n                      wfcontext.getSailPointContext().commitTransaction();\n                  }\n              }\n          }\n      }\n\n      public void auditManualAction(WorkItem item) {\n          if ( Auditor.isEnabled(AuditEvent.ManualChange) ) {\n              ApprovalSet set = (ApprovalSet)item.get(\"approvalSet\");\n              if ( set != null ) {\n                  List items = set.getItems();\n                  if ( Util.size(items) > 0 ) {\n                      int num = 0 ;\n                      for ( ApprovalItem it : items  ) { \n                          num++;\n                          AuditEvent event = IdentityLibrary.buildBaseEvent(wfcontext, it);\n                          event.setSource(getAuditSource(item));\n                          event.setAction(AuditEvent.ManualChange);\n                          event.setAttribute(\"requester\", wfcontext.getString(\"launcher\"));\n                          event.setAttribute(\"op\", it.getOperation());\n                          List comments = it.getComments();\n                          if ( Util.size(comments) > 0 ) {\n                              event.setAttribute(\"completionComments\", comments);\n                          }\n                          Auditor.log(event);\n                      }\n                      if ( num > 0 ) \n                          wfcontext.getSailPointContext().commitTransaction();\n                  }\n              } else {\n                  throw new GeneralException(\"ApprovalSet not found in the afterscript.\");\n              }\n          } \n      }\n\n      /**\n       * After an approval has been made apply the changes from the workitem back into the\n       * cart. (approvalSet)\n       */\n      public void assimilateWorkItemApprovalSet(WorkflowContext wfcontext, WorkItem item, ApprovalSet approvalSet) {\n         if (item == null) {\n              // must not be a leaf approval...\n              return;\n          }\n          // Assimilate all of the approvalItem changes into our gloval\n          // approval set\n          // \n          // Also audit the comments and forwarding thats happend\n          ApprovalSet set = (ApprovalSet)item.get(\"approvalSet\");\n          if ( set != null ) {\n              // Global completion comments will apply to each of the items\n              // If there are completion comments append them\n              // to any other completion comments, but typically its \n              // one or the other\n              String completionComments = item.getCompletionComments();\n              String ownerName = null;\n              Identity id = item.getOwner();\n              if ( id != null ) {\n                  ownerName = id.getName();\n              }\n              approvalSet.assimilate(set, ownerName, completionComments, true);\n          } else {\n              throw new GeneralException(\"ApprovalSet not found in the afterscript.\");\n          }\n          auditWorkItemOwnerHistory(item);\n          auditWorkItemComments(item);\n          wfcontext.getSailPointContext().commitTransaction();\n      }\n\n      /**\n       * Convert the approvalScheme to csv and check for the approvalType.\n       */\n      public boolean isApprovalEnabled(String approvalScheme, String approvalType) {\n          if ( approvalScheme != null )  {\n              List schemes = Util.csvToList(approvalScheme);\n              if ( Util.size(schemes) > 0 ) {\n                  if ( schemes.contains(approvalType) ) {\n                      return true;\n                  }\n              }\n          }\n          return false;\n      }\n\n      public String getManagerName(String identityName, String launcher, String fallbackApprover) {\n          String managerName = getIdentityProperty(identityName, \"manager.name\");\n          if ( managerName != null ) {\n              if ( managerName.compareTo(launcher) == 0 ) {\n                  managerName = null;\n              } \n          } else {\n             managerName = fallbackApprover;\n          }\n          return managerName;\n      }\n\n      /**\n       * Take an ApprovalSet and allow filtering of rejected items and \n       * allow clearing decisions. If includeRejected is false, only non rejected \n       * items will be copied into the new approvalSet.   If forceDecision is\n       * true all of the previous decisions will be cleared forcing the new\n       * approver to make a decision on all items.\n       */\n      public ApprovalSet filterApprovalSet(ApprovalSet masterSet, String includeRejected, \n                                           boolean forceDecision) {\n          ApprovalSet filtered = new ApprovalSet();\n          if ( masterSet != null ) {\n              List items = masterSet.getItems();\n              if ( !Util.otob(includeRejected) ) {\n                  items = new ArrayList();\n                  for ( ApprovalItem item : masterSet.getItems() ) {\n                      if ( !item.isRejected() ) {\n                          items.add(item);\n                      }\n                  }\n              }\n \n              if ( Util.size(items) > 0 )  {\n                  for ( ApprovalItem item : items ) {\n                      if ( forceDecision ) { \n                          item.setState(null);\n                      }\n                      filtered.add(item); \n                  } \n              } \n          }\n          return filtered;\n      }\n\n      //Filter items from the currentSet that are rejected in the masterSet\n      public void filterRejectsFromApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {\n        if (currentSet != null && !Util.isEmpty(currentSet.getItems())) {\n            Iterator it = currentSet.getItems().iterator();\n            while(it.hasNext()) {\n                ApprovalItem currentItem = (ApprovalItem)it.next();\n                //Find the item in the global ApprovalSet\n                ApprovalItem globalItem = masterSet.find(currentItem);\n                if (globalItem != null && globalItem.isRejected()) {\n                    //remove from the current approval\n                    it.remove();\n                }\n            }\n        }\n\n      }\n\n      //Set decisions on the currentSet to those in the masterSet\n      public void setPreviousDecisionsOnApprovalSet(ApprovalSet masterSet, ApprovalSet currentSet) {\n        if (currentSet != null && !Util.isEmpty(currentSet.getItems())) {\n            Iterator it = currentSet.getItems().iterator();\n            while(it.hasNext()) {\n                ApprovalItem currentItem = (ApprovalItem)it.next();\n                //Find the item in the global ApprovalSet\n                ApprovalItem globalItem = masterSet.find(currentItem);\n                if (globalItem != null) {\n                    currentItem.setState(globalItem.getState());\n                }\n            }\n        }\n      }\n\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f429108e019d',1528809721998,1739425315809,NULL,NULL,NULL,'Check Password Policy',NULL,'beanshell','\n    \n       import sailpoint.api.PasswordPolice;\n       import sailpoint.object.Application;\n       import sailpoint.object.Identity;\n       import java.util.List;\n       import java.util.ArrayList;\n       import sailpoint.api.PasswordPolicyException;\n       import sailpoint.tools.Util;\n       import sailpoint.tools.Message;\n       import sailpoint.tools.GeneralException;\n\n       List msgs = new ArrayList();\n\n       String passVal = (String)value;\n\n       try {\n           String appname = field.getApplication();\n           if (appname == null) {\n              // temporary support old WorkItems\n              String fname = field.getName();\n              int colon = fname.indexOf(\":\");\n              if (colon > 0)\n                 appname = fname.substring(0, colon);\n              else\n                 log.error(\"Unable to determine application name from field\");\n           }\n           Application app = context.getObjectByName(Application.class, appname);\n          \n           PasswordPolice police = new PasswordPolice(context);\n           police.checkPassword(app, identity, passVal);\n       }\n       catch (PasswordPolicyException pe) {\n           List messages = pe.getAllMessages();\n           for (Message msg : messages) {\n               msgs.add(msg.getMessage());\n           }\n       }\n       catch (GeneralException ge) {\n           msgs.add(ge.getMessage());\n       }\n\n       return ( Util.size(msgs) > 0 ) ? msgs: null;\n    \n  ','FieldValue',' ',NULL,NULL),('4028ab1063f427af0163f4291124019e',1528809722148,1739425324893,NULL,NULL,NULL,'LCM Build Owner Approvals',NULL,'beanshell','\n    \n       import sailpoint.object.ApprovalSet;\n       import sailpoint.object.ProvisioningPlan;\n       import sailpoint.workflow.IdentityLibrary;\n\n       //\n       // Attributes needed in the rule context: \n       //\n       // plan - ProvisioningPlan object \n       //\n       // approvalSet - An ApprovalSet representing the \"cart\"\n       // \n       // fallbackApprover - String representing who gets the approval\n       //                    if we can\'t resolve one.  \n       //\n       // identityName - name of the identity being operated on\n       //\n       //\n       List approvals = new ArrayList();\n       if ( approvalSet != null ) {\n           // \n           // Build a map of owner to ApprovalSet from each of the things in the plan \n           // \n           Map ownerMap = buildOwnerMap(\"owner\", approvalSet, plan, fallbackApprover, identityName, !IdentityLibrary.isElectronicSignatureEnabled(wfcontext));\n           if ( ownerMap != null) {\n               approvals = buildApprovalsFromMap(ownerMap, identityName, launcher);\n           } \n       }\n       return ( Util.size(approvals) > 0 ) ? approvals : null;\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f42911df019f',1528809722335,1739425324605,NULL,NULL,NULL,'LCM Build Identity Approvers',NULL,'beanshell','\n    \n       import sailpoint.object.ApprovalSet;\n       import sailpoint.object.ProvisioningPlan;\n       import sailpoint.object.WorkItem.State;\n       import sailpoint.workflow.IdentityLibrary;\n       import sailpoint.tools.Util;\n\n       //\n       // Attributes needed in the rule context: \n       //\n       // plan - ProvisioningPlan object \n       //\n       // approvalScheme - String indicating how approvals should be generated\n       //   none - disabled\n       //   manager - the current manager gets the approval\n       //   newManager - the current manager if the manager changd\n       //   securityOfficer - the configured security officer\n       // \n       // approvalSet - An ApprovalSet representing the \"cart\"\n       //\n       // fallbackApprover - String representing who gets the approval\n       //                    if we can\'t resolve one.  \n       //\n       // identityName - name of the identity being operated on\n       //\n       // launcher - name of the identity that launched the request\n       //\n       // securityOfficerName - The name of the securityOfficer to be used\n       //                       for approvals.\n       //\n\n       // Not all callers pass in securityOfficerName.  If not defined, just set\n       // it to null so we don\'t run into an error when we try to reference it.\n       if (void == securityOfficerName) {\n           securityOfficerName = null;\n       }\n\n       List approvers = new ArrayList();\n       if ( approvalSet != null ) {\n           List items = approvalSet.getItems();\n           // By default there is one item for all of the edits\n           ApprovalItem item = null;\n           if ( Util.size(items) > 0 ) \n               item = items.get(0); \n\n           if ( item != null ) {\n               approvers = getApproverNames(approvalScheme, item, plan, identityName, securityOfficerName);\n               if ( approvers != null && approvers.size() == 0 && fallbackApprover != null ) {\n                   if ( log.isDebugEnabled() ) { \n                       log.debug(\"Approver could not be resolved using fallbackApprover \'\"+fallbackApprover+\"\'.\");\n                   }\n                   approvers.add(fallbackApprover);\n               } \n               // If the launcher is an approver remove them from the list\n               if ( approvers != null && approvers.contains(launcher) ) {\n                   Map args = wfcontext.getArguments();\n                   String esig = null;\n                   if ( args != null ) \n                       esig = (String)args.get(\"approverElectronicSignature\");\n \n                   if ( !IdentityLibrary.isElectronicSignatureEnabled(wfcontext) && Util.isNullOrEmpty(esig) ) {\n                       approvers.remove(launcher);\n                       // If this is the only approver automaticaly\n                       // mark the item approved.\n                       if ( Util.size(approvers) == 0 ) {\n                           item.setState(WorkItem.State.Finished);\n                           item.setOwner(launcher);\n                       }\n                   }\n               }\n           }\n       }\n       return approvers;\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f42912a001a0',1528809722528,1739425325135,NULL,NULL,NULL,'LCM Validate Identity Name',NULL,'beanshell','\n    \n      import sailpoint.api.*;\n      import sailpoint.object.*;\n      import sailpoint.tools.*;\n      import sailpoint.api.*;\n      import sailpoint.web.messages.MessageKeys;\n\n      QueryOptions qo = new QueryOptions();\n      Filter filter  = Filter.ignoreCase(Filter.eq(\"name\", value));\n      qo.add(new Filter[]{filter});\n      qo.addFilter(ObjectUtil.buildWorkgroupInclusiveIdentityFilter());\n      int count = SailPointFactory.getCurrentContext().countObjects(Identity.class,qo);\n      List messages = new ArrayList();\n      if (count>0) {\n          Message msg = new Message();\n          msg.setKey(MessageKeys.LCM_CREATE_IDENTITY_NAME_ERROR);\n          messages.add(msg);\n      }\n      return messages;\n    \n  ','Validation',' ',NULL,NULL),('4028ab1063f427af0163f429133b01a1',1528809722683,1739425325387,NULL,NULL,NULL,'LCM Validate Password',NULL,'beanshell','\n    \n      import java.util.*;\n      import sailpoint.api.PasswordPolice;\n      import sailpoint.api.PasswordPolicyException; \n      \n      List errors = null;\n      \n      try {\n          PasswordPolice pp = new PasswordPolice(context);\n          pp.checkPassword(null, value, false);\n      }\n      catch (PasswordPolicyException ppe) {\n          errors = new ArrayList();\n          errors.addAll(ppe.getAllMessages());\n      }\n      \n      return errors;\n    \n  ','Validation',' ',NULL,NULL),('4028ab1063f427af0163f42914f101a2',1528809723121,1739425324345,NULL,NULL,NULL,'LCM Build Identity ApprovalSet',NULL,'beanshell','\n    \n      import sailpoint.object.ProvisioningPlan;\n      import sailpoint.object.ProvisioningPlan.AttributeRequest;\n      import sailpoint.object.ProvisioningPlan.AccountRequest;\n      import sailpoint.object.ApprovalSet;\n      import sailpoint.object.ApprovalItem;\n      import sailpoint.object.Attributes;\n      import sailpoint.tools.Util;\n\n      ApprovalSet set = new ApprovalSet();\n      if ( plan != null ) {\n          List accountRequests = plan.getAccountRequests();\n          for ( AccountRequest request : accountRequests ) {\n              ApprovalItem item = new ApprovalItem();\n              item.setApplication(request.getApplication());\n              item.setInstance(request.getInstance());\n              item.setNativeIdentity(request.getNativeIdentity());\n              item.setOperation(request.getOperation().toString());\n              List attrRequestFlat = flattenAttributeRequests(request.getAttributeRequests());\n              if ( attrRequestFlat != null ) {\n                  item.setValue(attrRequestFlat);\n              } \n              Attributes attributes = getAttributeRequestArguments(request.getAttributeRequests());\n              item.setAttributes(attributes);\n              \n              // for these requests comments come in on the plan\n              String comments = plan.getComments();\n              if ( Util.getString(comments) != null ) {\n                  item.setRequesterComments(comments);\n              }\n              set.add(item);\n          }\n\n          // while we are here lets annotate the plan with previousValues\n          if ( flow.equals(\"IdentityEditRequest\") ) {\n              AccountRequest iiqRequest = plan.getAccountRequest(\"IIQ\");    \n              if ( iiqRequest != null ) {\n                  List attributeRequests = iiqRequest.getAttributeRequests();\n                  if ( Util.size(attributeRequests) > 0 ) {\n                      Identity id = context.getObject(Identity.class, identityName);\n                      if ( id != null )  {\n                          for ( AttributeRequest req : attributeRequests ) {\n                              String name = req.getName();\n                              if ( name != null ) {\n                                  // We have to be carefull here, if we see manager display\n                                  // the displayName\n                                  Object prevValue = id.getAttribute(name);\n                                  if ( prevValue != null ) {\n                                      if (name.equals(\"manager\") ) {\n                                          String displayName = getIdentityProperty((String)prevValue, \"displayName\");\n                                          if ( displayName != null ) {\n                                              prevValue = displayName;\n                                          }\n                                      }\n                                      else if (prevValue instanceof Identity) {\n                                          prevValue = (String)prevValue.getDisplayableName();\n                                      }\n                                      else  if(prevValue instanceof List) {\n                                          /* Thanks to type erasure there is no way for us to write something like\n                                           * prevValue instanceof List<Identity> so break it into steps.  Check if\n                                           * prevValue is a List.  If it has any elements get the first one. If that\n                                           * is an instance of Identity then assume the rest of the elements are too\n                                           * and then build a List of displayable names, because that is what we do\n                                           * with Identitys. */\n                                          List prevValueList = (List) prevValue;\n                                          if(prevValueList.size() > 0) {\n                                              if(prevValueList.get(0) instanceof Identity) {\n                                                  List identityIds = new ArrayList(prevValueList.size());\n                                                  for (Object value : prevValueList) {\n                                                      Identity identity = (Identity) value;\n                                                      identityIds.add(identity.getDisplayableName());\n                                                  }\n                                                  prevValue = identityIds;\n                                              }\n                                          }\n                                      }\n                                      req.put(ProvisioningPlan.ARG_PREVIOUS_VALUE, prevValue);\n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n      }\n      return set;\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f42915d801a3',1528809723352,1739425328130,NULL,NULL,NULL,'Objects in Requestor\'s Authorized Scopes','\n    This rule returns either a Filter object that will be used to search for objects in the requestor\'s authorized scopes,\n    the boolean value \'true\' to indicate that everything should be returned (i.e. no restrictions) \n    or the boolean value \'false\' to indicate that no objects are available for this user\n  ','beanshell','\n    \n      import sailpoint.api.ScopeService;\n      \n      ScopeService scopeService = new ScopeService(context);\n      return scopeService.getControlledScopesQueryInfo(requestor);\n    \n  ','RequestObjectSelector',' ',NULL,'sailpoint.object.QueryInfo'),('4028ab1063f427af0163f42916ab01a4',1528809723563,1739425327710,NULL,NULL,NULL,'Objects in Requestee\'s Assigned Scope','This rule returns a Filter that restricts objects to those in the requestee\'s assigned scope','beanshell','\n    \n      import sailpoint.api.ScopeService;\n      import sailpoint.object.Identity;\n      import sailpoint.object.Scope;\n      import sailpoint.object.QueryOptions;\n      import sailpoint.object.QueryInfo;\n\n      ScopeService scopeService = new ScopeService(context);\n      QueryInfo scopeQueryInfo;\n      if (requestee == null) {\n          scopeQueryInfo = new QueryInfo(new QueryOptions());\n      } else {\n          scopeQueryInfo = scopeService.getAssignedScopeQueryInfo(requestee);\n      }\n      \n      return scopeQueryInfo;\n    \n  ','RequestObjectSelector',' ',NULL,'sailpoint.object.QueryInfo'),('4028ab1063f427af0163f429174101a5',1528809723713,1617791360968,NULL,NULL,NULL,'Objects in Requestor\'s Authorized Scopes or Requestee\'s Assigned Scope','This rule returns a Filter that restricts roles to those in the requestor\'s authorized scopes or the requestee\'s assigned scope','beanshell','\n    \n        import sailpoint.api.ScopeService;\n        import sailpoint.object.Filter;\n        import sailpoint.object.Identity;\n        import sailpoint.object.QueryInfo;\n        import sailpoint.object.QueryOptions;        \n\n        ScopeService scopeService = new ScopeService(context);\n        QueryInfo requestorQueryInfo =  scopeService.getControlledScopesQueryInfo(requestor);\n        QueryInfo requesteeQueryInfo;\n        if (requestee == null) {\n            requesteeQueryInfo = null;\n        } else {\n            requesteeQueryInfo =  scopeService.getAssignedScopeQueryInfo(requestee);\n        }\n\n        QueryInfo scopeQueryInfo;\n        if (requesteeQueryInfo == null || requesteeQueryInfo.isReturnNone()) {\n            // Either no requestee was available or the requestee doesn\'t have anything in scope.  \n            // Only apply the requestor QueryInfo in either case.\n            scopeQueryInfo = requestorQueryInfo;\n        } else if (requestorQueryInfo != null && !requestorQueryInfo.isReturnNone()) {\n            if (requestorQueryInfo.isReturnAll() || requesteeQueryInfo.isReturnAll()) {\n                // If either the requestor or requestee has access to everything create a QueryInfo that grants\n                // access to everything\n                scopeQueryInfo = new QueryInfo(new QueryOptions());\n            } else {\n                // Both requestee and requestor filters exist so \'or\' them\n                scopeQueryInfo = new QueryInfo(Filter.or(requestorQueryInfo.getFilter(), requesteeQueryInfo.getFilter()), false);\n            }\n        } else {\n            // The requestor doesn\'t have access to anything so only return whatever the requestee has access to\n            scopeQueryInfo = requesteeQueryInfo;\n        }\n\n        return scopeQueryInfo;\n    \n  ','RequestObjectSelector',' ',NULL,'sailpoint.object.QueryInfo'),('4028ab1063f427af0163f42917c601a6',1528809723846,1739425327380,NULL,NULL,NULL,'Objects Owned by the Requestor','This rule returns a Filter that restricts objects to those that the requestor or one of their workgroups owns','beanshell','\n    \n      import sailpoint.object.Filter;\n      import sailpoint.object.Identity;\n      import sailpoint.object.QueryOptions;\n      import sailpoint.object.QueryInfo; \n      return new QueryInfo(QueryOptions.getOwnerScopeFilter(requestor, \"owner\"), false);\n    \n  ','RequestObjectSelector',' ',NULL,'sailpoint.object.QueryInfo'),('4028ab1063f427af0163f429186001a7',1528809724000,1739425308104,NULL,NULL,NULL,'All Objects','Allows all objects to be selected (no filtering)','beanshell','import sailpoint.object.QueryInfo;\n\nreturn new QueryInfo(null, false);','RequestObjectSelector',' ',NULL,'sailpoint.object.Filter'),('4028ab1063f427af0163f4293a3b01f9',1528809732668,1739425321636,NULL,NULL,NULL,'Identity Report Form Customizer','\n    This rule populates a form with fields for the standard and extended identity attributes.\n  ','beanshell','\n       \n        import sailpoint.object.*;\n        import sailpoint.reporting.ReportingLibrary;\n\n        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);\n        List standardAttributes = new ArrayList();\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"firstname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"lastname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"displayName\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"email\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"manager\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"inactive\"));\n\n        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, null,\n          \"Identity Attributes\", locale, \"id\");\n\n        List extendedAttrs = new ArrayList();\n        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){\n          if (!att.isStandard())\n            extendedAttrs.add(att);\n        }\n\n        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){\n            extendedAttrs.add(att);\n        }\n\n        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, null,\n          \"Identity Extended Attributes\", locale, \"id\");\n\n\n       \n','ReportCustomizer',' ',NULL,'Map'),('4028ab1063f427af0163f4293d2801fc',1528809733416,1739425321360,NULL,NULL,NULL,'Identity Entitlement Identity Report Form Customizer','\n    This rule populates a form with fields for the standard and extended identity attributes accessed through an identity entitlement.\n  ','beanshell','\n       \n        import sailpoint.object.*;\n        import sailpoint.reporting.ReportingLibrary;\n\n        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);\n        List standardAttributes = new ArrayList();\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"firstname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"lastname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"displayName\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"email\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"manager\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"inactive\"));\n\n        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, standardAttributes, \"identity\",\n          \"Identity Attributes\", locale, \"id\");\n\n\n        List extendedAttrs = new ArrayList();\n        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){\n          if (!att.isStandard())\n            extendedAttrs.add(att);\n        }\n\n        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){\n            extendedAttrs.add(att);\n        }\n\n        ReportingLibrary.addAttributes(context, report, IdentityEntitlement.class, extendedAttrs, \"identity\",\n          \"Identity Extended Attributes\", locale, \"id\");\n\n\n       \n','ReportCustomizer',' ',NULL,'Map'),('4028ab1063f427af0163f4293e3201fe',1528809733682,1739425302309,NULL,NULL,NULL,'Account Report Form Customizer','\n    This rule populates a form with fields for all searchable account fields.\n  ','beanshell','\n       \n        import sailpoint.object.*;\n        import sailpoint.reporting.ReportingLibrary;\n\n        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);\n        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,\n          \"Account Properties\", locale);\n       \n','ReportCustomizer',' ',NULL,'Map'),('4028ab1063f427af0163f42945ab0218',1528809735595,1739425315468,NULL,NULL,NULL,'Certification Report Customizer',NULL,'beanshell','\n       \n        import sailpoint.object.*;\n        import sailpoint.tools.Util;\n        import sailpoint.web.messages.MessageKeys;\n        if (Util.otob(taskDefinition.getArgument(\"exclusions\"))){\n          report.setDisablePreview(true);\n          report.setDisablePreviewMessage(MessageKeys.REPT_CERT_PREVIEW_DISABLED_EXCLUSIONS);\n        } else {\n          report.setDisablePreview(false);\n          report.setDisablePreviewMessage(null);\n        }\n\n       \n','ReportCustomizer',' ',NULL,NULL),('4028ab1063f427af0163f4294f3e0230',1528809738046,1739425331685,NULL,NULL,NULL,'Privileged Access Report Customizer','\n    This rule populates a form with fields for the standard and extended identity attributes as well as\n    a form for defining the \'privileged\' identity attribute.\n  ','beanshell','\n       \n        import sailpoint.object.*;\n        import sailpoint.reporting.ReportingLibrary;\n\n        ObjectConfig linkConfig = ObjectConfig.getObjectConfig(Link.class);\n        ReportingLibrary.addAttributes(context, report, Link.class, linkConfig.getSearchableAttributes(), null,\n          \"Privileged Account Attributes\", locale, \"id\");\n\n\n        ObjectConfig identityConfig = ObjectConfig.getObjectConfig(Identity.class);\n        List standardAttributes = new ArrayList();\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"firstname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"lastname\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"displayName\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"email\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"manager\"));\n        standardAttributes.add(identityConfig.getObjectAttributeMap().get(\"inactive\"));\n\n        ReportingLibrary.addAttributes(context, report, Identity.class, standardAttributes, \"identity\",\n          \"Identity Properties\", locale, \"id\");\n\n        List extendedAttrs = new ArrayList();\n        for(ObjectAttribute att : identityConfig.getSearchableAttributes()){\n          if (!att.isStandard())\n            extendedAttrs.add(att);\n        }\n\n        for(ObjectAttribute att : identityConfig.getMultiAttributeList()){\n            extendedAttrs.add(att);\n        }\n\n        ReportingLibrary.addAttributes(context, report, Identity.class, extendedAttrs, \"identity\",\n          \"Identity Extended Properties\", locale, \"id\");\n       \n','ReportCustomizer',' ',NULL,'Map'),('4028ab1063f427af0163f4294ffe0231',1528809738238,1739425332139,NULL,NULL,NULL,'Privileged Access Report Validation Rule','\n      This rule validates the Privileged Access Report Form\n    ','beanshell','\n      \n       import java.util.*;\n       import sailpoint.object.*;\n       import sailpoint.tools.Message;\n       List messages = new ArrayList();\n\n       Form.Section section = form.getSection(\"Privileged Account Attributes\");\n       if (section != null) {\n         boolean found = false;\n         for(FormItem item : section.getItems()){\n           Field field = (Field)item;\n           if(field.getValue() != null && !field.getValue().equals(\"\") && !field.getValue().equals(\"null\")) {\n             found = true;\n           }\n         }\n\n         if (!found) {\n           messages.add(Message.localize(\"rept_priv_access_err_no_attr\"));\n         }\n       } else {\n         messages.add(Message.localize(\"rept_priv_attr_setup_needed\"));\n       }\n\n       return messages;\n      \n  ','ReportValidator',' ',NULL,'java.util.List'),('4028ab1063f427af0163f429913802a6',1528809754937,1739425341674,NULL,NULL,NULL,'WindowsActivityRuleLibrary',NULL,'beanshell','\n    \n      import java.util.HashMap;\n      import java.util.ArrayList;\n      import java.util.List;\n      import sailpoint.object.ApplicationActivity;\n      import sailpoint.object.ApplicationActivity.Action;\n      import sailpoint.tools.xml.*;\n\n      public static String ACCESSES = \"Accesses\";\n      public static String PRIVS = \"Privileges\";\n\n      /**\n       * Build a name,value Map pairing of the data found\n       * in the Message field of the windows event.\n       * Most of the low-level data is usually stored \n       * there using a \"name : value \\n\" format, so parse\n       * out those values so we can use them when \n       * building our activity.\n       */\n      public HashMap buildMapFromMessage(String message) {\n  \n          HashMap attributeMap = new HashMap();\n          if ( message == null ) return attributeMap;\n\n          StringTokenizer st = new StringTokenizer(message, \"\\n\");\n          int tokenNum = 0;\n          while ( st.hasMoreTokens() ) {\n              tokenNum++;\n              String token = st.nextToken();\n//System.out.println(\"token :\" + token);\n              String[] values = token.split(\":\");\n              if ( values == null ) continue;\n              if ( values.length == 2 ) {\n                  String name = values[0];\n                  String value = values[1];\n                  if ( ( name != null ) && ( value != null ) ) {\n//System.out.println(\"name: \" + name.trim() + \" value: \" + value.trim());\n                      attributeMap.put(name.trim(), value.trim());\n                  }\n              } else \n              if ( (values.length == 1) && (tokenNum == 1) ) {\n                  String name = values[0];\n                  attributeMap.put(\"action\", name.trim());\n              }\n          }\n          // Parse out privs \n          addPrivileges(attributeMap, message); \n\n          return attributeMap;\n      }\n\n      /** \n       * Some events, mostly Object Access events contain\n       * Accesses, Privleges that need to be parsed further.\n       * This is called, when we build a Map if the Message.\n       */\n      public void addPrivileges(HashMap extraInfo, String message) {\n\n          if ( message== null ) return;\n          int i = message.indexOf(ACCESSES);\n          if ( i == -1 ) {\n//System.out.println(ACCESSES + \" not found\");\n              return;\n          }\n          int j = message.indexOf(PRIVS);\n          if ( j == -1 ) {\n//System.out.println(PRIVS + \" not found\");\n              return;\n          }\n\n          List accesses = new ArrayList();\n          String lastBlock = message.substring(i+ACCESSES.length(), j-1);\n          if ( lastBlock != null ) {\n//System.out.println(\"***lastBlock: \" + lastBlock);\n              StringTokenizer st = new StringTokenizer(lastBlock, \"\\n\");\n              while ( st.hasMoreTokens() ) {\n                  String access = st.nextToken();\n                  if ( access != null ) {\n                      String trimed = access.trim();\n                      if ( trimed.length() > 0 ) {\n//System.out.println(\"access: \'\" + trimed + \"\'\");\n                          accesses.add(trimed);\n                      }\n                  }\n              }\n          }\n\n          if ( accesses.size() > 0 ) {\n              extraInfo.put(ACCESSES, accesses);\n          }\n      }\n\n      /**\n       * Given the eventCode from the native windows event\n       * map it to our Action.\n       */\n      public Action resolveAction(Integer eventCode, HashMap extraInfo) {\n          Action action = null;\n\n          if ( eventCode == null ) {\n              return;\n          }\n\n          try {\n              switch(eventCode) {\n                  case 538:\n                      // logout\n                      action = Action.Logout;\n                      break;\n                  case 528:\n                  case 540:\n                      // login\n                      action = Action.Login;\n                      break;\n                  case 564:\n                      // object delted\n                      action = Action.Delete;\n                      break;\n                  case 560:\n                      // object open\n                      // Very generic must dig in an check permissions\n                      if (containsAccess(\"WriteAttributes\", extraInfo))\n                          action = Action.Update;\n                      else\n                      if ( containsAccess(\"DELETE\", extraInfo) ) \n                          action = Action.Delete;\n                      else \n                          action = Action.Read;\n                      break;\n                  default: \n                      // not sure we should even have a default case?\n                      action = Action.Read;\n                      break;\n              }\n          } catch(Exception e) {\n              action = null;\n          }\n          return action;\n      }\n\n      /** \n       * Using the resolved action, use the data in the extraInfo\n       * map to come up with a target. ( the thing that was acted upon)\n       */\n      public String resolveTarget(Action action, HashMap extraInfo) {\n\n          String target = null;    \n          if ( ( action == null ) || ( extraInfo == null )  ) {\n              return target;\n          }\n\n          if ( ( action.equals(Action.Login) ) ||\n               ( action.equals(Action.Logout) ) ) {\n              target = (String)extraInfo.get(\"Domain\");\n          } else {\n              target = (String)extraInfo.get(\"Object Name\");\n          }\n\n          if ( target == null ) target = \"unResolved\";\n          return target;\n      }\n\n\n      /** \n       * Dig into the extra info and see if the event has referece to \n       * the past in access. \n       */\n      private boolean containsAccess(String access, HashMap extraInfo) {\n\n          boolean contains = false;\n          if ( extraInfo == null ) return contains;\n\n          ArrayList accesses = (ArrayList)extraInfo.get(ACCESSES); \n          if ( accesses != null ) {\n              for ( String access: accesses ) {\n                  if ( access != null ) {\n                      if ( access.compareTo(access) == 0 ) {\n                          return true;\n                      }\n                  }\n              }        \n          }\n          return contains;\n      }\n    \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f429a09e02ad',1528809758878,1739425336823,NULL,NULL,NULL,'System Configured Locale Rule','\n    This rule returns the locales configured in the System Configuration.\n  ','beanshell','\n      import java.util.*;\n     Map sysConfig = context.getConfiguration().getAttributes();\n     List locales = sysConfig.get(\"supportedLanguages\");\n     return locales;\n','FieldValue',' ',NULL,'java.util.List'),('4028ab1063f427af0163f429a26702ae',1528809759335,1739425334838,NULL,NULL,NULL,'Report Completion Notification','\n    This rule sends a notification email when a report is completed.\n  ','beanshell','\n      \n        import sailpoint.object.*;\n        import java.util.*;\n\n        String identity = (String)event.getAttribute(TaskEvent.ATTR_EMAIL_RECIP);\n\n        if (identity != null){\n\n          Identity identity = context.getObjectByName(Identity.class, identity);\n          if (identity == null)\n            return result;\n\n          List emailAddresses = new ArrayList();\n          emailAddresses.add(identity.getEmail());\n          EmailOptions options = new EmailOptions(emailAddresses, null);\n          options.setSendImmediate(true);\n\n          Map emailVars = new HashMap();\n          emailVars.put(\"reportName\", taskResult.getName());\n          options.setVariables(emailVars);\n\n          String templateName = (String)context.getConfiguration().get(Configuration.REPORT_COMPLETION_EMAIL_TEMPLATE);\n          EmailTemplate et = context.getObjectByName(EmailTemplate.class, templateName);\n\n          context.sendEmailNotification(et, options);\n        }\n\n        return null;\n      \n','TaskEventRule',' ',NULL,'Map'),('4028ab1063f427af0163f429a91a02af',1528809761050,1739425335119,NULL,NULL,NULL,'Report Scorecard Value Renderer','\n      This rule renders report columns which pull values from a Scorecard object.\n    ','beanshell','\n      \n       import java.util.*;\n       import sailpoint.object.*;\n\n       Integer score = null;\n       if(value!=null) {\n					score = value.getScore(column.getField());\n			 }\n\n       return score != null ? score.toString() : null;\n      \n  ',NULL,' ',NULL,NULL),('4028ab1063f427af0163f429ab7f02b1',1528809761663,1739425337084,NULL,NULL,NULL,'Task Completion Email Rule','\n      Example rule to perform Post Action after Task Completion\n    ','beanshell','\n      \n          import java.util.*;\n          import sailpoint.tools.Util;\n          import sailpoint.tools.GeneralException;\n          import sailpoint.object.Configuration;\n          import sailpoint.object.EmailOptions;\n          import sailpoint.object.EmailTemplate;\n          import sailpoint.object.TaskResult;\n          import sailpoint.object.Identity;\n          import sailpoint.object.TaskDefinition;\n          import sailpoint.api.MessageRepository;\n          import sailpoint.api.Emailer;\n          import sailpoint.api.BasicMessageRepository;\n          import sailpoint.api.ObjectUtil;\n          import sailpoint.api.SailPointContext;\n\n          MessageRepository _errorHandler;\n\n          /**\n           * Method to send email\n          */\n          private void sendEmailOnTaskCompletion(String emailTemplate, ArrayList recipients, TaskResult result, SailPointContext context) {\n              String message = \"\";\n              String status = \"\";\n              TaskDefinition def;\n              Configuration sysConfig;\n\n              def = result.getDefinition();\n              EmailTemplate notifyEmail =  context.getObjectByName(EmailTemplate.class, emailTemplate);\n              if (null == notifyEmail) {\n                  log.error (\"From Task Completion Email Rule: ERROR: could not find email template [ \" + emailTemplate + \"]\");\n                  return;\n              }\n              notifyEmail = (EmailTemplate) notifyEmail.deepCopy(context);\n              if (null == notifyEmail) {\n                  log.error (\"From Task Completion Email Rule: ERROR: failed to deepCopy template [ \" + emailTemplate + \"]\");\n                  return;\n              }\n              // For now, we\'ll just use a map with a few pre-selected properties.\n              Map mArgs = new HashMap();\n \n              mArgs.put(\"taskResult\", result);\n              mArgs.put(\"taskName\", def.getName());\n              mArgs.put(\"taskDesc\", def.getDescription());\n              if (result.isError()) {\n                  status = \"Error\";\n              }\n              else  if (result.isWarning()) {\n                  status = \"Warning\";\n              }\n              else if (result.isSuccess()) {\n                  status = \"Success\";\n              }\n \n              mArgs.put(\"taskStartTime\", result.getLaunched() );\n              mArgs.put(\"taskEndTime\", result.getCompleted() );\n              mArgs.put(\"status\", status);\n              if (result.getMessages() != null) {\n                  mArgs.put(\"message\", result.getMessages());\n              }\n              mArgs.put (\"resultId\", result.getId());\n\n              EmailOptions ops = new EmailOptions(recipients, mArgs);\n              new Emailer(context, _errorHandler).sendEmailNotification(notifyEmail , ops);\n          }\n\n          private boolean isEmailNotificationEnabled(TaskResult result, Configuration sysConfig) {\n              boolean sendEmail = false;\n              String notifyStr = null;\n\n              TaskDefinition def = result.getDefinition();\n              notifyStr = (String) def.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);\n              if (notifyStr == null) {\n                  notifyStr = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_NOTIFY);\n              }\n\n              if (notifyStr != null) {\n                  if (notifyStr.equals(\"Always\") ||\n                      ((notifyStr.equals(\"Failure\")) && result.isError()) || \n                      ((notifyStr.equals(\"Warning\")) &&\n                       (result.isWarning() || result.isError()))) {\n                      sendEmail = true;\n                  }\n              }\n                      \n              return sendEmail;\n          }\n\n          private Object getIdentityNames(TaskResult result, Configuration sysConfig) {\n              \n              TaskDefinition def = result.getDefinition();\n              Object identityNames = def.getArgument(Configuration.TASK_COMPLETION_RECIPIENTS);\n              if (identityNames == null) {\n                  identityNames = sysConfig.get(Configuration.TASK_COMPLETION_RECIPIENTS);\n              }\n              return identityNames;\n          }\n\n          private String getEmailTemplate(TaskResult result, Configuration sysConfig) {\n              TaskDefinition def = result.getDefinition();\n              String emailTemplate = def.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);\n              if (emailTemplate == null) {\n                  emailTemplate = sysConfig.getString(Configuration.TASK_COMPLETION_EMAIL_TEMPLATE);\n                  if (emailTemplate == null)\n                      emailTemplate = Configuration.DEFAULT_TASK_COMPLETION_EMAIL_TEMPLATE;\n              }\n              return emailTemplate;\n          }\n\n          private List getEmailAddress (String identityName, SailPointContext context) {\n              Identity identity = context.getObjectByName(Identity.class, identityName);\n              if (identity != null) \n              {\n                  List addresses = ObjectUtil.getEffectiveEmails(context, identity);\n                  if (!Util.isEmpty(addresses)) {\n                      return(addresses);\n                  }\n                  else\n                  {\n                     if(log.isWarnEnabled()) {\n                         log.warn(\"From Task Completion Email Rule: Missing Email Address for Email Recipient: \" + identityName );\n                     }\n                  }\n              }\n              return (null);\n          }\n\n          private ArrayList getEmailRecipient (Object identityNames, SailPointContext context) {\n              List recipients;\n              String val = null;\n              StringTokenizer st = null;\n              if (identityNames != null) {\n                  recipients = new ArrayList ();\n                  // From Task definition, single identity\n                  if (identityNames instanceof String  && !identityNames.contains(\",\")) {\n                      List addresses = getEmailAddress (identityNames.toString(), context);\n                      if (addresses != null) {\n                         recipients.addAll (addresses);\n                      }\n                  }\n                  // From Task definition, multiple identities\n                  else if (identityNames instanceof String  && identityNames.contains(\",\") == true) {\n                      List nameList = Util.csvToList(identityNames);\n                      for (String identityName : nameList) {\n                          List addresses = getEmailAddress (identityName, context);\n                          if (addresses != null) {\n                              recipients.addAll (addresses);\n                          }\n                      }  \n                  } \n                  // From system configuration single or multiple identities it comes as list\n                  else if (identityNames instanceof List) {\n                      for (String identityName : identityNames) {\n                          List addresses = getEmailAddress (identityName, context);\n                          if (addresses != null) {\n                              recipients.addAll(getEmailAddress (identityName, context));\n                          }\n                      }\n                  }\n              }\n              return (recipients);\n          }\n\n          // Main\n          Configuration sysConfig = context.getConfiguration();\n          boolean sendEmailNotify = isEmailNotificationEnabled(result, sysConfig);\n    \n          if (sendEmailNotify) {\n              // jsl - why consturct this here, just make it in\n              // sendEmailOnTaskCompletion where it is used?\n              // why do this at all since no one consumes it?\n              _errorHandler = new BasicMessageRepository();\n\n              Object identityNames = getIdentityNames(result, sysConfig);\n              String emailTemplate = getEmailTemplate(result, sysConfig);\n              List recipients = getEmailRecipient(identityNames, context);\n\n              if (recipients != null && !Util.isEmpty(recipients)) {\n                    // Send Email\n                   sendEmailOnTaskCompletion(emailTemplate, recipients, result, context);\n              }\n              else {\n                  if(log.isWarnEnabled()) {\n                      log.warn(\"From Task Completion Email Rule: Cannot send task completion email Notification. Reason : Missing Email Address for Email Recipients\");\n                  }\n              }\n          }\n    \n    ','TaskCompletion',' ',NULL,NULL),('4028ab1063f427af0163f429ac8202b2',1387809647533,1739425313386,NULL,NULL,NULL,'CEFTransformRule','ActivityTransformation Rules are used by the LogFileCollector to transform fields parsed from a text file into our ApplicationActivity model.','beanshell','import sailpoint.object.ApplicationActivity.Action;\nimport sailpoint.object.ApplicationActivity.Result;\nimport java.text.SimpleDateFormat;\nimport java.io;\nimport sailpoint.object.Configuration;\nimport java.util.List;\n\nactivity.setAction(Action.Grant);\nactivity.setResult(Result.Success);\n\n//Dump out all params from CEF log entry to console\n//System.out.println(\"CEFTransformRule: In rule\");        \n//System.out.println(\"CEFTransformRule: Timestamp=\" +cef_timestamp);\n//System.out.println(\"CEFTransformRule: Host=\" +cef_host);\n//System.out.println(\"CEFTransformRule: CEFVersion=\" + cef_cefversion);\n//System.out.println(\"CEFTransformRule: Vendor=\" + cef_vendor);\n//System.out.println(\"CEFTransformRule: Product=\" + cef_product);\n//System.out.println(\"CEFTransformRule: Version=\" + cef_version);\n//System.out.println(\"CEFTransformRule: Signature=\" + cef_signature);\n//System.out.println(\"CEFTransformRule: Name=\" + cef_name);\n//System.out.println(\"CEFTransformRule: Severity=\" + cef_severity);\n//System.out.println(\"CEFTransformRule: Explanation=\" + cef_explanation);\n\n//Find the user parameter in CEF Explanation field\n//System.out.println(\"CEFTransformRule: Breaking down the parameter list.....:\");\n\nObject o= Configuration.getSystemConfig().getList(Configuration.ATT_CEF_USER_NAME);\nList cefUserNames = null;\nif (o instanceof List) {\n            cefUserNames = (List)o;\n}\n\nfor (String paramPair: cef_explanation.split(\"\\\\s(?=\\\\S*(?<!\\\\\\\\)=)\", 0)){\n//	System.out.println(\"CEFTransformRule: Parameter pair found \" + paramPair);\n    for(String cefUser: cefUserNames){\n        String cefUserParam = cefUser.concat(\"=.*\");\n        if (paramPair.matches(cefUserParam)) {\n            cef_user = paramPair.split(\"=\",2)[1];\n//            System.out.println(\"CEFTransformRule: duser parameter found! \" + cef_user);\n        }\n    }   \n}\n\n// Set activity values\nactivity.setUser(cef_user);\nactivity.setAction(Action.Login);\nactivity.setResult(Result.Success);\nactivity.setInfo(\"vendor=\" + cef_vendor + \" host=\" + cef_host + \" \" + cef_explanation + \" severity=\" + cef_severity + \" product=\" + cef_product);\nactivity.setTarget(cef_name);\n\n// Set timestamp from CEF header, but add current year as this is not supplied\nSimpleDateFormat f = new SimpleDateFormat(\"MMM dd hh:mm:ss yyyy\");\ndefaultYear = Calendar.getInstance().get(Calendar.YEAR);\nDate date = date = f.parse(cef_timestamp + \" \" + defaultYear);\nactivity.setTimeStamp(date);\n\nreturn activity;','ActivityTransformer',' ',NULL,'String'),('4028ab1063f427af0163f429ad3c02b3',1388673847625,1739425313025,NULL,NULL,NULL,'CEFActivityCorrelation','Rule to show how an CEF activity might be correlated back to an identity. In most cases, this rule will be providing enought information to the correlator so that it can find the Application link. In some cases, it might also be desireable to return something that points back to an Identity, which is also supported.','beanshell','import sailpoint.object.ApplicationActivity;\n  import sailpoint.object.Configuration;\n	\n//  System.out.println(\"CEFActivityCorrelation: In Correlation Rule\");\n\n    Map returnMap = new HashMap();\n    String user = activity.getUser();\n	String cefLinkAttributeName = Configuration.getSystemConfig().getString(Configuration.ATT_CEF_LINK_ATTRIBUTE_NAME);\n	\n    if ( user != null ) {\n//		System.out.println(\"CEFActivityCorrelation: Matching for user \" + user);\n        returnMap.put(\"linkAttributeName\", cefLinkAttributeName);\n        returnMap.put(\"linkAttributeValue\", user);\n//        System.out.println(\"returnMap \" + returnMap);\n    }\n\n    return returnMap;','ActivityCorrelation',' ',NULL,'Map'),('4028ab1068cc9d780168cd21a0e10004',1549629759714,1739425342669,NULL,NULL,NULL,'_HR_Correlate','Identity Correlation Rules are used to find identities to which new accounts can be attached.\n\nA correlation rule must return a Map with one of the specified Return arguments.','beanshell','return identity;','Correlation',' ',NULL,'Map'),('a9fe0bbd7f501059817f604207400182',1646587414337,1646631657016,NULL,NULL,NULL,'COF Sample BatchRequest Rule',NULL,'beanshell','\n  import java.util.*;\n  import java.lang.*;\n  import java.text.*;\n\n  import java.io.BufferedReader;\n  import java.io.FileReader;\n  import java.io.IOException;\n  import java.io.FileWriter;\n\n  import sailpoint.api.*;\n  import sailpoint.api.Describer;\n  import sailpoint.object.*;\n  import sailpoint.workflow.*;\n\n  import org.apache.log4j.Logger;\n  import org.apache.log4j.Level;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  import java.sql.Connection;\n  import java.sql.DriverManager;\n  import java.sql.ResultSet;\n  import java.sql.Statement;\n\n  import sailpoint.task.TaskMonitor;\n  import sailpoint.tools.Message;\n  import sailpoint.object.TaskResult.CompletionStatus;\n\n\n  String fileName = \"BR.txt\";\n  Calendar date = Calendar.getInstance();\n  date.add(Calendar.MINUTE, 15);\n  List<BatchRequestItem> biList = new ArrayList();\n  \n  BatchRequest batchRequest = new BatchRequest();\n  batchRequest.setFileName(fileName);\n  batchRequest.setRunDate(new Date());\n  //batchRequest.setStatus(BatchRequest.Status.Scheduled);\n  batchRequest.setFileContents(\"operation, application, nativeIdentity\\nEnableAccount, AdminsApp, abell\"); \n  \n  Attributes attributeMap = new Attributes();\n  attributeMap.put(\"skipManualWorkItems\",true);\n  attributeMap.put(\"generateIdentityRequests\",false);\n  attributeMap.put(\"runNow\",true);\n  attributeMap.put(\"skipProvisioningForms\",true);\n  //attributeMap.put(\"runDate\",date.getTimeInMillis());\n  \n  batchRequest.setRunConfig(attributeMap);\n	\n  BatchRequestItem batchRequestItem = new BatchRequestItem();\n  batchRequestItem.setRequestData(\"EnableAccount, AdminsApp, abell\");\n  \n  biList.add(batchRequestItem);\n  //batchRequest.setBatchRequestItems(biList);\n  \n  context.startTransaction();  \n  context.saveObject(batchRequest);  \n  context.commitTransaction(); \n  \n  return \"Success\";\n  ',NULL,' ',NULL,NULL),('a9fe0bbd90c41bed8190d40bb7d30557',1721544456147,1725431506829,NULL,NULL,NULL,'Contractor Customization Rule','This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.\r\n\r\nInitially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.','beanshell','boolean inactive = false;\r\n  if(object != null && object.getAttribute(\"inactive\") != null){\r\n\r\n    inactive= object.getAttribute(\"inactive\");\r\n    \r\n    \r\n    if(inactive){\r\n      object.put(\"IIQDisabled\", true);\r\n    } else {\r\n      object.put(\"IIQDisabled\", false);\r\n    }\r\n\r\n  }\r\n\r\n  return object;','ResourceObjectCustomization',' ',NULL,'ResourceObject'),('a9fe0bbd90c41bed8190d4290cae0593',1721546378414,1726812721820,NULL,NULL,NULL,'Test Update Identity Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.object.ProvisioningPlan.Operation;\n  import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;\n\n  String identityName = \"2020013\";\n  String app = \"HR System\"; //LDAP\n  String nativeIdentity = \"aaa0013\";\n\n  //String nativeIdentity = \"uid=TRub304,ou=user,o=Company\";\n\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  ProvisioningPlan plan = new ProvisioningPlan();\n  // Set identity to the plan\n  plan.setIdentity(identity);\n\n  AccountRequest ldapAcctReq = new AccountRequest();\n  ldapAcctReq.setOperation(AccountRequest.Operation.Disable);\n  ldapAcctReq.setApplication(app);\n  ldapAcctReq.setNativeIdentity(nativeIdentity);\n  //ldapAcctReq.add(new AttributeRequest(\"description\", ProvisioningPlan.Operation.Set, \"Inactive\"));\n\n  plan.add(ldapAcctReq);\n\n  Provisioner p = new Provisioner(context);\n  p.execute(plan);\n\n  System.out.println(\"Plan \"+plan.toXml());\n\n  return plan.toXml();\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd90c41bed8190d430dd7b059c',1721546890619,1739425324088,NULL,NULL,NULL,'JDBC Provisioning Rule','This rule is used by the JDBC connector to do provisioning of the data .','beanshell','\n  \n	import sailpoint.object.Identity;\n	import java.sql.PreparedStatement;\n	import java.util.Date;\n	import sailpoint.object.ProvisioningResult;\n\n\n	String sql = \"insert into hr_emp(EmployeeID, givenName, sn, name, manager, mail, employeeNumber, enabled, title, info) values (?,?,?,?,?,?,?,?,?,?)\";\n\n	Identity identity = plan.getIdentity();\n	String eid = plan.getIdentity().getAttribute(\"uid\");\n	if(eid==null && identity.getAttribute(\"uid\")!=null ){\n		eid=(String) identity.getAttribute(\"uid\").toString();\n	}\n\n	String firstName = identity.getFirstname();\n	if(firstName == null && identity.getAttribute(\"firstname\") != null){\n		firstName = (String) identity.getAttribute(\"firstname\").toString();\n	}\n	\n	String lastName = identity.getLastname();\n	if(lastName == null && identity.getAttribute(\"lastname\") != null){\n		lastName = (String) identity.getAttribute(\"lastname\").toString();\n	}\n	\n	String email = identity.getEmail();\n	if(email == null && identity.getAttribute(\"email\") != null){\n		email = (String) identity.getAttribute(\"email\").toString();\n	}\n	\n	String fullName = \"\";\n	if(identity.getAttribute(\"displayName\") != null){\n		fullName = (String) identity.getAttribute(\"displayName\").toString();\n	}\n	\n	String manager = \"\";\n	if(identity.getManager() != null && identity.getManager().getAttribute(\"uid\") != null){\n		manager = (String) identity.getManager().getAttribute(\"uid\").toString();\n	}\n	\n	String employeeNumber = \"\";\n	if(identity.getAttribute(\"employeenumber\") != null){\n		employeeNumber = (String) identity.getAttribute(\"employeenumber\").toString();\n	}\n	\n	String title = \"\";\n	if(identity.getAttribute(\"title\") != null){\n		title = (String) identity.getAttribute(\"title\").toString();\n	}\n	\n	String employeeType = \"\";\n	if(identity.getAttribute(\"employeeType\") != null){\n		employeeType = (String) identity.getAttribute(\"employeeType\").toString();\n	}\n\n	PreparedStatement ps = connection.prepareStatement(sql);\n	ps.setString(1, eid);\n	ps.setString(2, firstName);\n	ps.setString(3, lastName);\n	ps.setString(4, fullName);\n	ps.setString(5, manager);\n	ps.setString(6, email);\n	ps.setString(7, employeeNumber);\n	ps.setString(8, \"TRUE\");\n	ps.setString(9, title);\n	ps.setString(10, employeeType);\n	\n	int updateStatus = 0;\n	try{\n		updateStatus = ps.executeUpdate();\n	}catch(SQLException){\n		// if the user account exists in target system and account does not exists in IIQ, existing account will be updated.\n		/**String sql = \"update hr_emp set EmployeeID = ?, givenName = ?, sn = ?, name = ?, manager = ?, mail = ?, employeeNumber = ?, enabled = ?, titlr = ?, info = ? where EmployeeID = ?\";\n		ps.setString(1, eid);\n		ps.setString(2, firstName);\n		ps.setString(3, lastName);\n		ps.setString(4, fullName);\n		ps.setString(5, manager);\n		ps.setString(6, email);\n		ps.setString(7, employeeNumber);\n		ps.setString(8, \"TRUE\");\n		ps.setString(9, title);\n		ps.setString(10, employeeType);\n		ps.setString(11, eid);\n		updateStatus = ps.executeUpdate();**/\n	}\n	log.debug(\".........request....\" +updateStatus);\n	if(updateStatus > 0){\n		ProvisioningResult result = new ProvisioningResult();\n		result.setStatus(ProvisioningResult.STATUS_COMMITTED);\n		plan.setResult(result);\n	}\n	\n','JDBCOperationProvisioning',' ',NULL,'ProvisioningResult'),('a9fe0bbd90c41bed8190d44857f505c7',1721548429301,1739425335732,NULL,NULL,NULL,'Rule Library',NULL,'beanshell','\n	\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n	import org.apache.commons.lang.StringUtils;\n	import sailpoint.object.AttributeAssignment;\n	import sailpoint.api.IdentityService;\n	import sailpoint.api.ObjectUtil;\n	import sailpoint.api.SailPointContext;\n	import sailpoint.api.SailPointFactory;\n	import sailpoint.api.Provisioner;\n	import sailpoint.api.*;\n	import java.util.Calendar;\n	import sailpoint.object.IdentityEntitlement;\n	import sailpoint.object.ApprovalItem.ProvisioningState;\n	import sailpoint.object.Application;\n	import sailpoint.object.ApprovalItem;\n	import sailpoint.object.AuditEvent;\n	import sailpoint.object.Attributes;\n	import sailpoint.object.AuthenticationAnswer;\n	import sailpoint.object.AuthenticationQuestion;\n	import sailpoint.object.Bundle;\n	import sailpoint.object.Certification;\n	import sailpoint.object.CertificationEntity;\n	import sailpoint.object.Custom;\n	import sailpoint.object.EmailOptions;\n	import sailpoint.object.EmailTemplate;\n	import sailpoint.object.Filter;\n	import sailpoint.object.Form;\n	import sailpoint.object.Identity;\n	import sailpoint.object.IdentityRequest;\n	import sailpoint.object.IdentityRequestItem;\n	import sailpoint.object.Link;\n	import sailpoint.object.ManagedAttribute;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.ProvisioningPlan.Operation;\n	import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;\n	import sailpoint.object.ProvisioningProject;\n	import sailpoint.object.ProvisioningResult;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.RoleAssignment;\n	import sailpoint.object.Field;\n	import sailpoint.object.Filter;\n	import sailpoint.object.Form;\n	import sailpoint.object.WorkItem;\n	import sailpoint.object.Form.Section;\n	import sailpoint.object.*;\n	import sailpoint.object.Request;\n	import sailpoint.object.Filter.LeafFilter;\n	import sailpoint.object.Filter.CompositeFilter;\n	import sailpoint.object.Profile;\n	import sailpoint.workflow.WorkflowContext;\n\n\n	import sailpoint.tools.GeneralException;\n	import sailpoint.tools.Message;\n	import sailpoint.tools.Util;\n	import sailpoint.tools.xml.XMLObjectFactory;\n\n	import java.util.ArrayList;\n	import java.util.HashMap;\n	import java.util.Iterator;\n	import java.util.List;\n	import java.util.Map;\n	import java.util.Arrays;\n\n	import com.cof.rap.olad.OladPasswordUpdateClient;\n\n\n	String COF_DELEGATE_WORKGROUP_FORMAT = \"cofDelegateWorkgroupFormat\";//sys config entry for COF Set Delegate module\n	String[] ENTITLEMENT_CLEANUP_APPS = { \"Active Directory\" };\n	String[] RELATED_APPS = {\"Active Directory\"};\n	String[] HYPHEN_ROLES = {\"COF A- Role\",\"COF W- Role\"};\n\n	Log log = LogFactory.getLog(\"com.rules.RuleLibrary\");\n	\n	public AccountRequest createAR(SailPointContext context, String app)\n	{\n	\n			AccountRequest ar = new AccountRequest();\n			ar.setOperation(AccountRequest.Operation.Create);\n			ar.setApplication(app);\n			\n			return ar;\n	}\n	\n	/***\n	Get new UID\n	***/\n	public static String getNewUID(SailPointContext context)\n	{\n		Custom custom = (Custom) ObjectUtil.lockObject(context, Custom.class, null, \"UID Custom Object\", PersistenceManager.LOCK_TYPE_TRANSACTION);\n		\n		String prefix = custom.getString(\"prefix\");\n		String suffix = custom.getString(\"suffix\");\n		\n		Integer suf = Integer.valueOf(suffix);\n		\n		if(suf == 9999){\n			suf = 1;\n			incrementPrefix(prefix);\n		} else {\n			suf++;\n		}\n		\n		String suffix = String.format(\"%04d\", new Object[] {suf});\n		custom.put(\"prefix\", prefix);\n		custom.put(\"suffix\", suffix);\n		\n		context.saveObject(custom);\n		context.commitTransaction();\n		\n		return prefix + suffix;\n	}\n	\n	/***\n	This API will increments the prefix, ex \"aaa\" will return \"aab\", \"zzz\" will return \"aaaa\"\n	***/\n	public static String incrementPrefix(String s)\n	{\n		int length = s.length();\n		char c = s.charAt(length - 1);\n		\n		if(c == \'z\'){\n			return length > 1 ? incrementPrefix(s.substring(s, length - 1)) + \'a\' : \"aa\";\n		}\n		\n		return s.substring(s, length - 1) + ++c;\n	}\n\n	',NULL,' ',NULL,NULL),('a9fe0bbd90c41bed8190d44cebf405d3',1721548729332,1739425337636,NULL,NULL,NULL,'Test Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.object.ProvisioningPlan.Operation;\n  import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;\n\n  \n	return getNewUID(context);\n	\n	Identity id = context.getObjectByName(Identity.class, \"\");\n	\n	id.getName();\n	String email= id.getAttribute(\"email\");\n	List links = id.getLinks();\n	\n	\n	id.setAttribute(\"email\", \"xyz@gamil.com\");\n	\n	app.setOwner();\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd90c41bed8190d461d07705f9',1721550098551,1739425320758,NULL,NULL,NULL,'HR Customization Rule','This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.\n\n    Initially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.','beanshell','\n  \n	String enabled = \"false\";\n	if(object != null && object.getAttribute(\"enabled\") != null){\n\n		enabled = object.getAttribute(\"enabled\");\n\n		if(enabled.equalsIgnoreCase(\"false\")){\n			object.put(\"IIQDisabled\", false);\n		} else {\n			object.put(\"IIQDisabled\", true);\n		}\n\n	}\n\n	return object;','ResourceObjectCustomization',' ',NULL,'ResourceObject'),('a9fe0bbd90c41bed8190d5342d200718',1721563884832,1739425323293,NULL,NULL,NULL,'Identity_InActiveAttribute_Contractor','Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.\n\n    This rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the \"link\" argument which is not passed in global mapping rules.','beanshell','\n\n	boolean active = false;\n	//String status = \"\";\n	if(link != null && link.getAttribute(\"enabled\") != null){\n\n		active = link.getAttribute(\"enabled\");\n		\n		//status = link.getAttribute(\"enabled\");\n		\n		if(active){\n		  return \"Active\";\n		} else {\n		  return \"InActive\";\n		}\n		\n		/**\n		if(status.equalsIgnoreCase(\"Active\")){\n		  return true;\n		} else {\n		  return false;\n		}\n		**/\n\n	}\n\n\n  ','IdentityAttribute',' ',NULL,'String'),('a9fe0bbd90c41bed8190f7f4103d0ce0',1722146885693,1739425323821,NULL,NULL,NULL,'JDBC Global Provisioning Rule','This rule is used by the JDBC connector to do provisioning of the data .','beanshell','\n	import sailpoint.object.Identity;\n	import java.sql.PreparedStatement;\n	import java.util.Date;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.ProvisioningPlan.Operation;\n	import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;\n	import sailpoint.object.ProvisioningProject;\n	import sailpoint.object.ProvisioningResult;\n\n	ProvisioningResult result = new ProvisioningResult();\n	Identity identity = plan.getIdentity();\n	List accountRequests = plan.getAccountRequests();\n	\n	if (accountRequests != null && accountRequests.size() > 0) {\n		for (AccountRequest accountRequest : accountRequests) {\n			if(ProvisioningPlan.AccountRequest.Operation.Create.equals(accountRequest.getOperation())){\n				String sql = \"insert into hr_emp(EmployeeID, givenName, sn, name, manager, mail, employeeNumber, enabled, title, info) values (?,?,?,?,?,?,?,?,?,?)\";\n\n				String eid = identity.getAttribute(\"uid\");\n				if(eid==null && identity.getAttribute(\"uid\")!=null ){\n					eid=(String) identity.getAttribute(\"uid\").toString();\n				}\n\n				String firstName = identity.getFirstname();\n				if(firstName == null && identity.getAttribute(\"firstname\") != null){\n					firstName = (String) identity.getAttribute(\"firstname\").toString();\n				}\n				\n				String lastName = identity.getLastname();\n				if(lastName == null && identity.getAttribute(\"lastname\") != null){\n					lastName = (String) identity.getAttribute(\"lastname\").toString();\n				}\n				\n				String email = identity.getEmail();\n				if(email == null && identity.getAttribute(\"email\") != null){\n					email = (String) identity.getAttribute(\"email\").toString();\n				}\n				\n				String fullName = \"\";\n				if(identity.getAttribute(\"displayName\") != null){\n					fullName = (String) identity.getAttribute(\"displayName\").toString();\n				}\n				\n				String manager = \"\";\n				if(identity.getManager() != null && identity.getManager().getAttribute(\"uid\") != null){\n					manager = (String) identity.getManager().getAttribute(\"uid\").toString();\n				}\n				\n				String employeeNumber = \"\";\n				if(identity.getAttribute(\"employeenumber\") != null){\n					employeeNumber = (String) identity.getAttribute(\"employeenumber\").toString();\n				}\n				\n				String title = \"\";\n				if(identity.getAttribute(\"title\") != null){\n					title = (String) identity.getAttribute(\"title\").toString();\n				}\n				\n				String employeeType = \"\";\n				if(identity.getAttribute(\"employeeType\") != null){\n					employeeType = (String) identity.getAttribute(\"employeeType\").toString();\n				}\n\n				PreparedStatement ps = connection.prepareStatement(sql);\n				ps.setString(1, eid);\n				\n				int updateStatus = 0;\n				try{\n					updateStatus = ps.executeUpdate();\n				}catch(SQLException){\n					// if the user account exists in target system and account does not exists in IIQ, existing account will be updated.\n					log.debug(\".........Error....\" +SQLException);\n					result.setStatus(ProvisioningResult.STATUS_FAILED);\n				}\n				log.debug(\".........request....\" +updateStatus);\n				if(updateStatus > 0){\n					result.setStatus(ProvisioningResult.STATUS_COMMITTED);\n					plan.setResult(result);\n				}\n			}\n			\n			if(ProvisioningPlan.AccountRequest.Operation.Modify.equals(accountRequest.getOperation())){\n			\n			}\n			\n			if(ProvisioningPlan.AccountRequest.Operation.Delete.equals(accountRequest.getOperation())){\n				String sql = \"DELETE FROM hr_emp WHERE EmployeeID = ?\";\n\n				String eid = identity.getAttribute(\"uid\");\n				if(eid==null && identity.getAttribute(\"uid\")!=null ){\n					eid=(String) identity.getAttribute(\"uid\").toString();\n				}\n\n\n				PreparedStatement ps = connection.prepareStatement(sql);\n				ps.setString(1, eid);\n				\n				int updateStatus = 0;\n				try{\n					updateStatus = ps.executeUpdate();\n				}catch(SQLException){\n					\n				}\n				log.debug(\".........request....\" +updateStatus);\n				if(updateStatus > 0){\n					result.setStatus(ProvisioningResult.STATUS_COMMITTED);\n					plan.setResult(result);\n				}\n			}\n				\n		}\n	}\n	\n	\n','JDBCOperationProvisioning',' ',NULL,'ProvisioningResult'),('a9fe0bbd90c41bed8190f806579b0d18',1722148083611,NULL,NULL,NULL,NULL,'LDAP Customization Rule','This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.\r\n\r\nInitially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.','beanshell','     String enabled = \"inactive\";\r\n	if(object != null && object.getAttribute(\"description\") != null){\r\n\r\n		enabled = object.getAttribute(\"description\");\r\n\r\n		if(enabled.equalsIgnoreCase(\"inactive\")){\r\n			object.put(\"IIQDisabled\", true);\r\n		} else {\r\n			object.put(\"IIQDisabled\", false);\r\n		}\r\n\r\n	}\r\n\r\n	return object;','ResourceObjectCustomization',' ',NULL,'ResourceObject'),('a9fe0bbd92b219cc8192b2b97e110037',1729575353873,1739425337403,NULL,NULL,NULL,'Test Email Sending','Debugging Tool - Sends a sample email out via the email\nserver.','beanshell','\n // Library inclusions for BeanShell\nimport sailpoint.api.*;\nimport sailpoint.object.*;\nimport sailpoint.tools.*;\nimport java.util.*;\nimport java.lang.*;\nimport java.text.*;\n\n// Point this to the \"To\" email address\nString emailDest = \"Test.User@sweinc.com\";\n// Specify the email template name in tplName\nString tplName = \"SailPoint - Test Email Sending\";\nEmailTemplate template = context.getObjectByName(EmailTemplate.class, tplName);\nif (null == template) {\n log.error(\"ERROR: could not find email template [ \" + tplName + \"]\");\n return;\n}\ntemplate = (EmailTemplate) template.deepCopy(context);\nif (null == template) {\n log.error(\"ERROR: failed to deepCopy template [ \" + tplName + \"]\");\n return;\n}\nMap args = new HashMap();\n// Add all args needed by the template like this\nargs.put(\"testField1\", \"This is a test of template parameters.\");\n\nEmailOptions ops = new EmailOptions(emailDest, args);\ncontext.sendEmailNotification(template, ops);\nreturn;\n ','BuildMap',' ',NULL,'Map'),('a9fe0bbd92b71d768192bd06872a02f8',1729748174634,1739425309923,NULL,NULL,NULL,'Audit Event','Debugging Tool - Sends a sample email out via the email\nserver.','beanshell','\n	import sailpoint.object.*;\n	import java.util.*;\n	import sailpoint.api.*;\n	import sailpoint.tools.*;\n	import sailpoint.server.Auditor;\n		\n	\n	AuditEvent audit = new AuditEvent();\n	audit.setApplication(\"LDAP\");\n	audit.setSource(\"Identity Attribute Update\");\n	audit.setAction(\"Modify\");\n	audit.setTarget(\"2020013\");\n	audit.setAccountName(\"user2,test\");\n	audit.setString1(\"Test Audit Event\");\n	\n	\n	context.saveObject(audit);\n	context.commitTransaction();\n ',NULL,' ',NULL,'Map'),('a9fe0bbd92b71d768192c21b793a050a',1729833433402,1739425338170,NULL,NULL,NULL,'Update User Attribute',NULL,'beanshell','\n	import java.io.*;\n	import java.util.*;\n	import sailpoint.object.*;\n	import sailpoint.tools.Message;\n\n\n	String tskMsg = \"\";\n	String filePath=\"\\\\\\\\E:\\\\Data\\\\test.csv\";\n\n	if(config.get(\"filePath\") != null){\n	filePath =  config.get(\"filePath\").toString();\n	}\n\n	File testFile = new File(filePath);\n\n	if ((!testFile.exists()) || (testFile.isDirectory())) {\n		System.out.println(\"Unable to find file: \" + filePath);\n		taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n		taskResult.setProgress(\"Done launching task: \"+tskMsg);\n		taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n		return;\n	}\n\n	BufferedReader fileIn = new BufferedReader(new FileReader(filePath));\n	String l=\"\";    \n	  \n	while((l=fileIn.readLine())!=null){  \n	System.out.print(l+\"\\n\"); \n\n	String user = l.split(\",\")[0];\n	String attr = l.split(\",\")[1];\n	String value = l.split(\",\")[2];\n\n	if(null != user && null != group){\n		Identity identity = context.getObjectByName(Identity.class,user);\n					\n		if(null != identity){\n		  tskMsg = tskMsg + \"Updating user: \"+user+\" attribute: \"+attr+\" with \"+value+\"\\r\\n\";\n		  identity.setAttribute(attr, value);\n		  context.saveObject(identity);\n		  context.commitTransaction();\n		  context.decache(identity);\n		}\n	}\n\n	}  \n\n\n\n	fileIn.close(); \n\n\n	taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n	taskResult.setProgress(\"Done launching task: \"+tskMsg);\n	taskResult.setAttribute(\"msg\",tskMsg);\n    taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n    context.saveObject(taskResult); 	\n	\n	return \"Success\";\n',NULL,' ',NULL,NULL),('a9fe0bbd92d11bbd8192d6cbc74003bf',1730180532032,1739425335468,NULL,NULL,NULL,'Require LDAP Account Policy Rule','This rule is used to determine if a Policy has been violated.','beanshell','\n	import java.util.List;\n	import java.util.ArrayList;\n	import sailpoint.object.*;\n	import sailpoint.api.*;\n	import sailpoint.object.PolicyViolation;\n	import sailpoint.object.PolicyViolation.Status;\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	Log log = LogFactory.getLog(\"com.swe.serviceaccountPolicyRule\"); \n	log.info(\"Entering serviceaccountPolicyRule:\"+identity);\n	\n	boolean hasAccount = false, ldapReq = false;\n    Application application = context.getObject(Application.class,\"LDAP\");\n	\n	IdentityService service = new IdentityService(context);\n\n	List ldapLinks = service.getLinks(identity, application);\n	\n	for(Link link : ldapLinks){\n		if(link.getId() != null){\n			hasAccount = true;\n		}\n		\n		if(link.getId() == null){\n			ldapReq = true;\n		}\n	}\n	\n	if(!hasAccount && ldapReq){\n		violation = new PolicyViolation();\n		violation.setActive(true);\n		violation.setIdentity(identity);\n		violation.setPolicy(policy);\n		violation.setConstraint(constraint);\n		violation.setDescription(\"Require LDAP Account\");\n		violation.setStatus(sailpoint.object.PolicyViolation.Status.Open);\n	}\n\n\n	return violation;\n  ','Policy',' ',NULL,'PolicyViolation'),('a9fe0bbd92f5112a8192fad3619f01e1',1730785010079,1739425326480,NULL,NULL,NULL,'Logging Example Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  private static Log log = LogFactory.getLog(\"rule.TestRule\");\n\n  log.info(\"printing message 1\");\n  log.info(\"printing message 2\");\n  log.info(\"printing message 3\");\n\n\n\n  String identityName = \"2020005\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  System.out.println(\"Result Identity: \"+identity);\n  System.out.println(\"Result Full Name: \"+identity.getFullName());\n\n  return identity.getFullName();\n\n\n  Rule rule = context.getObjectById(Rule.class, \"4028ab1063f427af0163f428e5610131\");\n\n  return rule;\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd92f5112a8192fad8ef6001ef',1730785374048,1745384486517,NULL,NULL,NULL,'BeanShell Example',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  private static Log log = LogFactory.getLog(\"rule.TestRule\");\n\n  System.out.println(\"Simple Beanshell...\");\n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  Object obj = context.getObjectByName(Object.class, objectName);\n  Object obj = context.getObjectById(Object.class, objectId);\n \n \n  //Condtion ex1\n  if(identity == null){\n    System.out.println(\"No User Found... \");\n    log.error(\"No User Found...\");\n    return;\n  }\n\n  //Condtion ex2\n  if(identity != null && identity.getLinks() != void){\n    System.out.println(\"User Links: \"+identity.getLinks());\n\n    //loop ex1\n    for(Link link : identity.getLinks()){\n      System.out.println(\"User Link: \"+link.getApplication());\n\n    }\n\n    //return identity.getLinks();\n\n  }\n\n	if(identity.getName().equals(\"12345\")){\n	} else {\n	}\n	\n	\n  /*if(identity != null @and identity.getLinks() @lt 0){\n  }*/\n  \n  \n  /*if(identity != null  && identity.getLinks() < 0){\n  }*/\n\n  //loop ex2\n  QueryOptions options = new QueryOptions();\n  List identityList = context.getObjects(Identity.class, options);\n  List idList = new ArrayList();\n  if (null != identityList) {\n\n    for (Identity id : identityList) {\n      idList.add(id.getDisplayName());\n    }\n\n  }\n\n  return idList;\n  //return identity.getDisplayName();\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd92f5112a819301325f730583',1730891898766,1739425337888,NULL,NULL,NULL,'Update Identity Attribute',NULL,'beanshell','\n  import java.io.*;\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.tools.Message;\n\n    String user = \"\";\n    String attr = \"\";\n    String value = \"\";\n\n    if(null != user && null != group){\n      Identity identity = context.getObjectByName(Identity.class,user);\n\n      if(null != identity){\n        identity.setAttribute(attr, value);\n        context.saveObject(identity);\n        context.commitTransaction();\n        context.decache(identity);\n      }\n    }\n\n    \n\n\n  return \"Success\";\n  ',NULL,' ',NULL,NULL),('a9fe0bbd92f5112a819305404a18066c',1730959919640,1739425320067,NULL,NULL,NULL,'GetManagedAttribute','This rule will create approval summary to upadate in \'Interaction\' section of \'Access Request Page\'','beanshell','\n\n \n	import sailpoint.object.Identity; \n	import java.util.List;\n	import java.util.ArrayList;\n	import sailpoint.object.WorkItem;\n	import sailpoint.object.IdentityRequest;\n	import sailpoint.object.*;\n	import sailpoint.object.WorkflowSummary.ApprovalSummary;\n	import sailpoint.api.*;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Filter;\n	import sailpoint.tools.GeneralException;\n\n\n    QueryOptions ops = new QueryOptions();\n  \n	Filter f1 = Filter.eq(\"application.name\", \"LDAP\");\n	Filter f2 = Filter.and(f1, Filter.ignoreCase(Filter.eq(\"value\", managedAttributeValue)));\n	ops.addFilter(f2);\n\n	Iterator iterator = context.search(ManagedAttribute.class, ops);\n	if(null != iterator && iterator.hasNext()){\n		ManagedAttribute managedAttribute = (ManagedAttribute) iterator.next();\n		return managedAttribute;\n	}\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd92f5112a81930543eb070675',1730960157447,1730960315040,NULL,NULL,NULL,'Test Email Sending 2','Debugging Tool - Sends a sample email out via the email\n    server.','beanshell','\n  // Library inclusions for BeanShell\n  import sailpoint.api.*;\n  import sailpoint.object.*;\n  import sailpoint.tools.*;\n  import java.util.*;\n  import java.lang.*;\n  import java.text.*;\n\n  // Point this to the \"To\" email address\n  String emailDest = \"Test.User@sweinc.com\";\n  // Specify the email template name in tplName\n  String tplName = \"Test Email Sending\";\n  EmailTemplate template = context.getObjectByName(EmailTemplate.class, tplName);\n  if (null == template) {\n    log.error(\"ERROR: could not find email template [ \" + tplName + \"]\");\n    return;\n  }\n  template = (EmailTemplate) template.deepCopy(context);\n  if (null == template) {\n    log.error(\"ERROR: failed to deepCopy template [ \" + tplName + \"]\");\n    return;\n  }\n  Map args = new HashMap();\n  \n\n  EmailOptions ops = new EmailOptions(emailDest, args);\n  context.sendEmailNotification(template, ops);\n  return \"Email Sent\";\n  ','BuildMap',' ',NULL,'Map'),('a9fe0bbd92f5112a819305665f8a06bf',1730962415498,1739425319801,NULL,NULL,NULL,'Get Custom Object Rule',NULL,'beanshell','\n  import java.util.ArrayList;\n  import java.util.Iterator;\n  import java.util.List;\n\n  import sailpoint.api.SailPointContext;\n  import sailpoint.object.Custom;\n  import sailpoint.object.Application;\n  import sailpoint.object.Rule;\n  import sailpoint.object.Filter;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.object.TaskDefinition;\n  import sailpoint.object.TaskResult;\n  import sailpoint.object.TaskResult.CompletionStatus;\n  import sailpoint.tools.Util;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n  import sailpoint.tools.GeneralException;\n  \n  Log log = LogFactory.getLog(\"com.cof.rap.COFCheckPromoteManagedAttributeRule\");\n\n	try {\n		Custom custom = context.getObject(Custom.class, \"Application Custom Object\");\n		if (custom != null && custom.getList(\"ApplicationList\") != null && !custom.getList(\"ApplicationList\").isEmpty()) {\n			List list = (List) custom.get(\"ApplicationList\");\n			Filter eq = Filter.eq(\"type\", \"AccountAggregation\");\n			QueryOptions options = new QueryOptions();\n			options.addFilter(eq);\n			Iterator search = context.search(TaskDefinition.class, options);\n			while (search.hasNext()) {\n				TaskDefinition definition = (TaskDefinition) search.next();\n				String applications = (String) definition.getArgument(\"applications\");\n				if (Util.isNotNullOrEmpty(applications)) {\n					List apps = new ArrayList();\n					if (applications.contains(\",\")) {\n						apps = Util.csvToList(applications);\n					} else {\n						apps.add(applications);\n					}\n				}\n			}\n\n\n		}\n	} catch(GeneralException e){\n		log.error(\"Error \" + e.getMessage());\n    } catch(Exception ex){\n		log.error(\"Error \" + ex.getMessage());\n    } finally {\n		context.commitTransaction();\n	}\n\n	return \"Success\";\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd92f5112a81930a63be410976',1731046129217,1739425333978,NULL,NULL,NULL,'QueryOptions Example Rule',NULL,'beanshell','\n	import java.util.*;\n	import sailpoint.object.*;\n	import sailpoint.api.Provisioner;\n	import sailpoint.api.*;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Filter;\n	import sailpoint.tools.Util;\n	import sailpoint.tools.GeneralException;\n\n\n	//SQL Query\n	String query = \"sql: SELECT name, extended1 FROM IDENTITYIQ.SPT_IDENTITY\";\n\n	//HQL Query\n	//String query = \"select name, displayName FROM Identity\";\n	Iterator results = null;\n   \n	try{\n\n		QueryOptions qo = new QueryOptions();\n		qo.setCloneResults(true);\n		qo.setQuery(sqlQuery);\n		results = context.search(sqlQuery, null, qo);\n\n		while(results.hasNext()){\n\n			Object[] resultValues = results.next();\n\n			String val1 = resultValues[0];\n			String val2 = resultValues[1];\n			\n			System.out.println(\"Name: \"+val1);\n			System.out.println(\"UID: \"+val2);\n\n		}\n	}  catch(GeneralException ex){\n		log.error(\"GeneralException occured \" + ex.getMessage());\n	} catch(Exception ex){\n		log.error(\"Exception occured \" + ex.getMessage());\n	}finally {\n		if(null!=results) Util.flushIterator(results);\n	}\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd939010d78193957532b401be',1733379306165,1739425334556,NULL,NULL,NULL,'Rehire Trigger Rule',NULL,'beanshell','\n		boolean result = false;\n		log.info(\"Enter rehireTrigger\");\n\n		if (previousIdentity == null || previousIdentity == void) {\n			log.warn(\"Identity objects are null\");\n			return result;\n		}\n\n		if (newIdentity == null || newIdentity == void) {\n			log.warn(\"Identity objects are null\");\n			return result;\n		}\n		\n		String accountType = (String) newIdentity\n				.getAttribute(\"accountType\");\n\n		result = (previousIdentity.isInactive() && !(newIdentity.isInactive())\n				&& accountType != null && accountType.equalsIgnoreCase(\"User\"));\n		log.info(\"Exit rehireTrigger\");\n		log.debug(\"Rehire Result:\"+result);\n		\n		List links = identity.getLinks();\n\n		for(Iterator iterator = links.iterator(); iterator.hasNext();){\n			Link link = (Link) iterator.next();\n			if(link.getApplicationName().equalsIgnoreCase(\"LDAP\")){\n				if(!link.getAttribute(\"\").equals(\"Active\")){\n					return true;\n				}\n			}\n			\n			if(link.getApplicationName().equalsIgnoreCase(\"JDBC\")){\n				\n			}\n		}\n		\n		\n		return result;\n  ','IdentityTrigger',' ',NULL,'boolean'),('a9fe0bbd940617a1819406a532ee0040',1735278277358,1739425300950,NULL,NULL,NULL,'AD Validation Rule','This rule is used toAD validate the Field values on a provisioning plan.','beanshell','\n  \n  \n  import java.util.Iterator;\n  import java.util.Map;\n  import sailpoint.object.ApprovalItem;\n  import sailpoint.object.ApprovalSet;\n  import sailpoint.object.Attributes;\n  import sailpoint.object.Identity;\n  import sailpoint.object.WorkItem;\n  import sailpoint.tools.GeneralException;\n  import sailpoint.tools.Util;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n  import sailpoint.object.Filter;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.object.Link;\n  import java.util.ArrayList;\n  import java.util.List;\n  import sailpoint.api.IdentityService;\n  import sailpoint.object.Application;\n\n  Log log = LogFactory.getLog(\"com..rap.ADValidationRule\");\n  log.info(\"Enter rule  AD Validation Rule\");\n\n  String APPLICATION_NAME = \"Active Directory\";\n  String FIELD_NAME_ACCOUNT_TYPE =  \"accountType\";\n  String FIELD_NAME_USER_TYPE =   \"userType\";\n  String FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE =  \"systemAccountSubType\";\n  String FIELD_NAME_MAILBOX =  \"mailbox\";\n  String FIELD_NAME_EXTERNAL_EMAIL =  \"externalEmail\";\n  String FIELD_NAME_SYSTEM_ACCOUNT_NAME =  \"systemAccountName\";\n  String FIELD_NAME_SAMACCOUNTNAME =  \"sAMAccountName\";\n  String FIELD_NAME_DISTINGUISHED_NAME =  \"distinguishedName\";\n  String FIELD_NAME_MEMBER_OF =  \"memberOf\";\n  String FIELD_NAME_PASSWORD =  \"password\";\n  String FIELD_NAME_USER_PASSWORD =  \"userPassword\";\n  String FIELD_NAME_PWD_LAST_SET =  \"pwdLastSet\";\n  String FIELD_NAME_FIRST_NAME =  \"givenName\";\n  String FIELD_NAME_LAST_NAME =  \"sn\";\n  String FIELD_NAME_DESCRIPTION =  \"description\";\n  String FIELD_NAME_INITIALS =  \"initials\";\n  String FIELD_NAME_DISPLAY_NAME =  \"displayName\";\n  String FIELD_NAME_USER_PRINCIPAL_NAME =  \"userPrincipalName\";\n  String FIELD_NAME_EXTENSION_ATTRIBUTE_8 =  \"extensionAttribute8\";\n  String FIELD_NAME_EXTENSION_ATTRIBUTE_9 =  \"extensionAttribute9\";\n  String FIELD_NAME_USER_ACCOUNT_CONTROL =  \"userAccountControl\";\n  String DOMAIN_NAME = (domainName != void && domainName != null) ? domainName : \"\";\n  String ACCOUNT_TYPE = (accountType != void && accountType != null) ? accountType : \"\";\n  String SAMACCOUNTNAME = (sAMAccountName != void && sAMAccountName != null) ? sAMAccountName : \"\";\n  String SYSTEM_ACCOUNT_NAME = (systemAccountName != void && systemAccountName != null) ? systemAccountName : \"\";\n  String SYSTEM_ACCOUNT_SUB_TYPE = (systemAccountSubType != void && systemAccountSubType != null) ? systemAccountSubType : \"\";\n\n  String ATTR_ACCOUNT_TYPE = \"AccountType\";\n\n  String fieldName = field.getName();\n  String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1); \n  List messages = null;\n  String accountType = \"\";\n  String Domain = \"swe\";\n  boolean hasUserAccount = false;\n\n\n  public static String pendingApprovalCheck(String appName, Identity id){\n    List dataList = new ArrayList();\n\n    Filter filter = Filter.and(Filter.eq(\"type\", \"Approval\"), Filter.eq(\"targetName\", id.getName()),\n                               Filter.eq(\"targetId\", id.getId()),\n                               Filter.eq(\"targetClass\", \"sailpoint.object.Identity\"), Filter.ignoreCase(\n                                 Filter.like(\"description\", \"Account Approval for \'\" + id.getDisplayName() + \"\'\")));\n\n    Iterator workItemSearch = context.search(WorkItem.class, new QueryOptions().addFilter(filter), \"id\");\n    if (workItemSearch != null) {\n      while (workItemSearch.hasNext()) {\n        Object[] next = workItemSearch.next();\n        if (next != null) {\n          String itemId = (String) next[0];\n          if (Util.isNotNullOrEmpty(itemId)) {\n            WorkItem workItemId = context.getObjectById(WorkItem.class, itemId);\n            if (workItemId != null) {\n              ApprovalSet approvalSet = workItemId.getApprovalSet();\n              if (approvalSet != null) {\n                List items = approvalSet.getItems();\n                if (Util.nullSafeSize(items) > 0) {\n                  for (ApprovalItem approvalItem : items) {\n                    if (approvalItem != null) {\n                      String application = approvalItem.getApplication();\n                      String operation = approvalItem.getOperation();\n                      if (Util.nullSafeCaseInsensitiveEq(application, appName)\n                          && Util.nullSafeCaseInsensitiveEq(operation, \"Create\")) {\n                        Attributes attributes = approvalItem.getAttributes();\n                        if(attributes != null && attributes.size() > 0) {\n                          Map map = attributes.getMap();\n                          if(map != null && map.size() > 0) {\n                            Map  ProvisionData  = (Map) map.get(\"ProvisionData\");\n                            if(ProvisionData != null && ProvisionData.size() > 0 && ProvisionData.get(\"data\") !=null) {\n                              dataList = (List) ProvisionData.get(\"data\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    String returnValue = \"\";\n\n    if(Util.nullSafeSize(dataList) > 0){\n      returnValue = (String) dataList.get(1);\n    }\n    return returnValue;\n  }\n\n  if(identity.getAttribute(ATTR_ACCOUNT_TYPE) != null){\n    accountType = identity.getAttribute(ATTR_ACCOUNT_TYPE);\n  }\n  log.debug(\"accountType:\"+accountType);\n  log.debug(\"currentField = \" + currentField);\n  log.debug(\"ACCOUNT_TYPE = \" + ACCOUNT_TYPE);\n\n  public getIdentityAccountList(){\n    IdentityService identityService = new IdentityService(context);\n    Application app = context.getObjectByName(Application.class,APPLICATION_NAME);\n    List link = identityService.getLinks(identity,app);\n    return link;\n  }\n\n  if(ACCOUNT_TYPE.equals(\"P-\")) {\n    log.debug(\"Account type is P-\");\n    List link = getIdentityAccountList();\n    if(!link.isEmpty()){\n      messages = new ArrayList();\n      for(  Link account : link) {\n        log.debug(\"account name\"+account.getDisplayName());\n        if(DOMAIN_NAME.equalsIgnoreCase(Domain)){\n		// checking whether a user has any pending dash account           \n          String pendingRequestDashAccount = pendingApprovalCheck(APPLICATION_NAME, identity);\n\n          if(Util.isNotNullOrEmpty(pendingRequestDashAccount)){\n            String[] split = pendingRequestDashAccount.split(\"~\");\n            if(split != null){\n              String dashAccount = split[2];\n\n              if(Util.isNotNullOrEmpty(dashAccount) && (! dashAccount.equals(\"W-\") && ! dashAccount.equals(\"D-\"))){\n\n                messages.add(\"Request for creation of \"+dashAccount+\" is pending with your manager, if you are now a developer, please cancel the \"+dashAccount+\" account request and request the P- account\");\n\n                return messages;\n              }\n\n            }\n          }\n\n          // checking whether a user has D- account \n          if(account.getDisplayName().startsWith(Domain + \"\\\\\" + \"D-\")){\n\n            messages.add(\"User has a D- account, if the user is now a developer, delete the D- account and then request the P- account\"); \n\n          }\n          if(account.getDisplayName().startsWith(Domain + \"\\\\\" + \"A-\")){\n            if(account.isDisabled()){\n              messages.add(\"User has a Disabled A- account, if the user is now a developer, delete the disabled A- account and then request the P- account\");\n              return messages;\n            }\n            else{\n              messages.add(\"User has a A- account, if the user is now a developer, delete the A- account and then request the P- account\"); \n            }\n          }\n\n          // checking whether a user has P- account\n          if(account.getDisplayName().startsWith(Domain + \"\\\\\" + \"P-\")){\n            if(account.isDisabled()){\n              messages.add(\"User has a Disabled P- account, if the user needs P- account, delete the disabled P- account and then request the P- account again\"); \n              return messages;\n            }else{\n              messages.add(\"User already has a P- Account\"); \n            }\n          }\n        }else{\n          // checking whether a user has P- account\n          if(account.getDisplayName().startsWith(DOMAIN_NAME + \"\\\\\" + \"P-\")){\n\n            messages.add(\"User already has a P- Account\"); \n\n          }\n\n        }\n        if(account.getDisplayName().equalsIgnoreCase(Domain+\"\\\\\"+identity.getName())){\n          hasUserAccount = true;\n        }\n      }\n    }\n    if(!hasUserAccount && !accountType.equalsIgnoreCase(\"system\")){\n      if (messages == null){\n        messages = new ArrayList();	  \n        messages.add(\"User does not have user account (\" + identity.getName() + \"). Please submit a user account request first. Once the request is completed you can submit the P- account request\"); \n      }\n    }\n  } \n  else if(ACCOUNT_TYPE.equals(\"A-\") || ACCOUNT_TYPE.equals(\"D-\")) {\n\n    List link = getIdentityAccountList();\n\n    if(!link.isEmpty()){\n      messages = new ArrayList();\n\n      for(  Link account : link) {\n        log.debug(\"account.getDisplayName() : \" + account.getDisplayName());\n        if(DOMAIN_NAME.equalsIgnoreCase(Domain)){\n		// checking whether a user has any pending dash account 		\n          String pendingRequestDashAccount = pendingApprovalCheck(APPLICATION_NAME, identity);\n          if(ACCOUNT_TYPE.equals(\"A-\")){\n            if(Util.isNotNullOrEmpty(pendingRequestDashAccount)){\n              String[] split = pendingRequestDashAccount.split(\"~\");\n              if(split != null){\n                String dashAccount = split[2];\n\n                if(Util.isNotNullOrEmpty(dashAccount) && (! dashAccount.equals(\"W-\") && ! dashAccount.equals(\"D-\"))){\n\n                  messages.add(\"Request for creation of \"+dashAccount+\" is pending with your manager,  If you require A-EID, please cancel the \"+dashAccount+\" account request and request the A- account\");\n\n                  return messages;\n                }\n              }\n            }\n          }\n          if(account.getDisplayName().startsWith(Domain + \"\\\\\" + \"P-\")){\n            if(account.isDisabled()){\n              messages.add(\"User has a Disabled P- account, if the user needs A- account, delete the disabled P- account and then request the A- account\"); \n              return messages;\n            }\n            else{\n              messages.add(\"User has a P- account, if the user is no longer a developer, delete the P- account and then request the \"+ACCOUNT_TYPE +\" account\"); \n            }\n          }\n\n          if(account.getDisplayName().startsWith(DOMAIN_NAME + \"\\\\\" + \"A-\") && ACCOUNT_TYPE.equals(\"A-\")){\n            if(account.isDisabled()){\n              messages.add(\"User has a Disabled A- account, if the user needs A- account, delete the disabled A- account and then request for A- account again\"); \n              return messages;\n            }\n            else{\n              messages.add(\"User already has a A- Account\"); \n            }\n\n          }\n\n        }else{\n          if(account.getDisplayName().startsWith(DOMAIN_NAME + \"\\\\\" + \"D-\") && ACCOUNT_TYPE.equals(\"D-\")){\n\n            messages.add(\"User already has a D- Account\"); \n\n          }\n\n        } \n        if(account.getDisplayName().equalsIgnoreCase(Domain+\"\\\\\"+identity.getName())){\n          hasUserAccount = true;\n        }\n      }\n    }\n    if(!hasUserAccount && !accountType.equalsIgnoreCase(\"system\")){\n      if (messages == null){\n        messages = new ArrayList();\n        messages.add(\"User does not have user account (\" + identity.getName() + \"). Please submit a user account request first. Once the request is completed you can submit the A- account request\"); \n      }\n    }\n\n  }\n\n  else if(ACCOUNT_TYPE.equals(\"W-\")) {\n\n    List link = getIdentityAccountList();\n\n    if(!link.isEmpty()){\n      messages = new ArrayList();\n\n      for(  Link account : link) {\n        if(account.getDisplayName().equalsIgnoreCase(Domain+\"\\\\\"+identity.getName())){\n          hasUserAccount = true;\n        }\n      }\n    }\n\n    if(!hasUserAccount && !accountType.equalsIgnoreCase(\"system\")){\n      if (messages == null){\n        messages = new ArrayList();\n        messages.add(\"User does not have user account (\" + identity.getName() + \"). Please submit a user account request first. Once the request is completed you can submit the W- account request\"); \n      }\n    }\n  }\n\n  else if(ACCOUNT_TYPE.equals(\"User\")) {\n\n    List link = getIdentityAccountList();\n\n    if(!link.isEmpty()){\n      messages = new ArrayList();\n\n      for(  Link account : link) {\n        if(account.getDisplayName().startsWith(Domain + \"\\\\\" + \"P-\") && !accountType.equalsIgnoreCase(\"system\")){\n          messages.add(\"User already has a P- Account. If you need a \"+ACCOUNT_TYPE +\" account you must submit a request to delete P- account \"); \n        }\n      }\n    }\n  }\n  else if(FIELD_NAME_SYSTEM_ACCOUNT_NAME.equals(currentField)){\n\n    if(SAMACCOUNTNAME.length() >= 20){\n      messages = new ArrayList();\n      messages.add(\"System Account Name must be less than 20 characters\");\n    }\n\n    /*Changes for AM-12836 COPP sub Account Type Changes*/\n    if(SYSTEM_ACCOUNT_SUB_TYPE.equals(\"COPP\")){\n      //check if account matches regex.  Example COSPP003\n      if(!SYSTEM_ACCOUNT_NAME.matches(\"[A-Z][A-Z][A-Z]PP[0-9][0-9][0-9]\")){\n        messages = new ArrayList();\n        messages.add(\"System Account Name must match format [A-Z][A-Z][A-Z]PP[0-9][0-9][0-9]\");\n      }\n    }\n    else{\n      List filterList = new ArrayList();\n      Filter filter;\n      QueryOptions queryOptions = new QueryOptions();\n      filterList.add(Filter.eq(\"application.name\",APPLICATION_NAME));\n      filterList.add(Filter.eq(\"displayName\",SYSTEM_ACCOUNT_NAME));\n      filter = Filter.and(filterList);\n      queryOptions.addFilter(filter);\n      List results = context.getObjects(Link.class, queryOptions);\n      if(results != null && results.size()>0){\n        messages = new ArrayList();\n        messages.add(\"Account with the provided name already exists. Please enter a different System Account Name\");\n      }\n    }\n\n  }\n  else if(FIELD_NAME_DISPLAY_NAME.equals(currentField)){\n    if((SYSTEM_ACCOUNT_SUB_TYPE.equals(\"Shared Mailbox\"))||(SYSTEM_ACCOUNT_SUB_TYPE.equals(\"Kiosk\"))){\n      boolean intFlag = true;\n      if(field.getValue()!=null && field.getValue().length() >= 120){\n        messages = new ArrayList();\n        messages.add(\"Display Name must be less than 120 characters\");\n        intFlag = false; \n      }\n\n      if(intFlag){\n\n        List filterList = new ArrayList();\n        Filter filter;\n        QueryOptions queryOptions = new QueryOptions();\n        filterList.add(Filter.eq(\"application.name\",APPLICATION_NAME));\n        filterList.add(Filter.eq(\"key1\",field.getValue()));\n        filter = Filter.and(filterList);\n        queryOptions.addFilter(filter);\n        List results = context.getObjects(Link.class, queryOptions);\n        if(results != null && results.size()>0){\n          messages = new ArrayList();\n          //messages.add(\"A Shared Mailbox already exists with this display name. Please enter a different display name for your Shared Mailbox\");\n          messages.add(\"An account already exists with this display name. Please enter a different display name for your account\");\n        }\n\n\n\n\n\n        /*\n		if(checkUniqueDisplayName(field.getValue())){\n\n			messages = new ArrayList();\n			messages.add(\"A Shared Mailbox already exists with this display name. Please enter a different display name for your Shared Mailbox\");\n		}\n*/\n      }\n      if( field.getValue() != null && !field.getValue().equalsIgnoreCase(\"\") && field.getValue().contains(\"@\") && field.getValue().endsWith(\".com\")  )     {\n        messages = new ArrayList();\n        // messages.add(\"Shared Mailbox Display name is not valid.\");\n        messages.add(\"This Display name is not valid.\");\n      }\n    }	\n  }\n  else if(FIELD_NAME_MAILBOX.equals(currentField)){\n    if(ACCOUNT_TYPE.equalsIgnoreCase(\"System\") && SYSTEM_ACCOUNT_SUB_TYPE.equalsIgnoreCase(\"Shared Mailbox\")){\n      if(field.getValue()!=null && field.getValue().equalsIgnoreCase(\"No\")){\n        messages = new ArrayList();\n        messages.add(\"Please select mailbox to Yes\"); \n      }\n    }\n  }\n  else{\n    log.error(\"Unsupported Field Name \" + currentField);\n    messages = null;\n  }\n\n  log.info(\"Exit rule  AD Validation Rule\");\n  return messages;\n  \n   \n \n\n  ','Validation',' ',NULL,'Object'),('a9fe0bbd940617a1819406a54eb60041',1735278284470,1739425292573,NULL,NULL,NULL,'CyberArk Rulelibrary',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5508c0042',1735278284940,1739425292918,NULL,NULL,NULL,'Shared Mailbox CSV Creation Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5514b0043',1735278285131,1739425293308,NULL,NULL,NULL,'Lock Level Change Email Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a551f20044',1735278285298,1739425293699,NULL,NULL,NULL,'Sphinx Safe Creation Workflow AD After Provisioning Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5526c0045',1735278285421,1739425294383,NULL,NULL,NULL,'ServiceDog IncidentCreate Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a552f50046',1735278285557,1739425294894,NULL,NULL,NULL,'CyberArk PAM Server password retrieval rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a553580047',1735278285656,1739425295170,NULL,NULL,NULL,'CyberArk REST API Rule Library',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a553cc0048',1735278285772,1739425295427,NULL,NULL,NULL,'CyberArk REST API Password Vault Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5549b0049',1735278285979,1739425295755,NULL,NULL,NULL,'CyberArk REST API Custom AD Password Vault Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5552b004a',1735278286124,1739425296048,NULL,NULL,NULL,'AD After Provisioning Rule','This rule will create the csv file with required fields for creating an exchange account in the remote server. This will add the following attributes in the csv file.','beanshell','\n  \n\n\n  /*******\n  *                                                                                                                                                                                                                                                                 *\n  * Generated: Tue Jul 28 15:20:28 IST 2015                                                                                                                                                                                                                         *\n  * Rule:  AD After Provisioning Rule                                                                                                                                                                                                                          *\n  * Description: This rule will create the csv file with required fields for creating an exchange account in the remote server. This will add the following attributes in the csv file.                                                                                                                                                                                                          *\n  * Inputs:                                                                                                                                                                                                                                                         *\n  *     plan - The ProvisioningPlan object on its way to the Connector.                                                                                                                                                                                             *\n  *     application - The application object that references this before/after script.                                                                                                                                                                              *\n  *     result - The ProvisioningResult object returned by the connectors provision method. This can be null and in many cases the connector will  not return a result and instead will annotate the plan\'s ProvisioningResult either at the plan or account level. *\n  * Returns:                                                                                                                                                                                                                                                        *\n  ******/\n  import sailpoint.api.IdentityService; \n  import sailpoint.api.SailPointContext;\n  import sailpoint.object.Application;\n  import sailpoint.object.Attributes;\n  import sailpoint.object.*;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.object.ProvisioningResult;\n  import sailpoint.tools.GeneralException;\n  import sailpoint.tools.EmailException;\n  import sailpoint.tools.xml.XMLObjectFactory;\n  import sailpoint.tools.Util;\n  import sailpoint.api.ObjectUtil;\n  import sailpoint.object.ProvisioningPlan.ObjectRequest;\n  import sailpoint.object.ManagedAttribute;\n  import sailpoint.object.Filter;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.object.Request;\n  import sailpoint.object.RequestDefinition;\n  import sailpoint.object.AuditEvent;\n    \n  import com.hierynomus.msdtyp.AccessMask;\n  import com.hierynomus.msfscc.FileAttributes;\n  import com.hierynomus.mssmb2.SMB2CreateDisposition;\n  import com.hierynomus.mssmb2.SMB2CreateOptions;\n  import com.hierynomus.mssmb2.SMB2ShareAccess;\n  import com.hierynomus.smbj.SMBClient;\n  import com.hierynomus.smbj.SmbConfig;\n  import com.hierynomus.smbj.auth.AuthenticationContext;\n  import com.hierynomus.smbj.connection.Connection;\n  import com.hierynomus.smbj.session.Session;\n  import com.hierynomus.smbj.share.DiskShare;\n  import com.hierynomus.smbj.share.File;\n\n  import java.io.IOException;\n  import java.io.OutputStream;\n  import java.util.Arrays;\n  import java.util.HashSet;\n  import java.util.Map;\n  import java.util.concurrent.TimeUnit;\n  import java.util.HashMap;\n  import java.util.List;\n  import java.util.Map;\n  import java.util.Calendar;\n  import java.util.Date;\n  import java.io.IOException;\n\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n  import org.apache.commons.lang.StringUtils;\n\n\n  //Note, when getting the userType value, the code below converts it to upper case, which is why these values are upper case\n  String BANK_SOUTH_TELLER = \"BANK SOUTH TELLER\";\n  String BANK_SOUTH_NON_TELLER = \"BANK SOUTH NON-TELLER\";\n  String BANK_CENTRAL_TELLER = \"BANK CENTRAL TELLER\";\n  String BANK_CENTRAL_NON_TELLER = \"BANK CENTRAL NON-TELLER\";\n  String NORTH_EAST_TELLER = \"NORTH EAST TELLER\";\n  String NORTH_EAST_NON_TELLER = \"NORTH EAST NON-TELLER\";\n  String NOT_A_BANK_USER = \"NOT A BANK USER\";\n  String CUSTOM_OBJECT_NAME = \" AD Provisioning Policy Custom Object\";\n  String password= null;\n  String memberOfInAD=null;\n  List links = null; //declared for OU channge\n\n  Log log = LogFactory.getLog(\"com..rap.ADAfterProvisioningRule\");\n  log.debug(\"Entering rule  AD After Provisioning Rule\");\n\n  public Map svctierMap = new HashMap();\n  public Map organizationMap = new HashMap();\n\n  String identityName = \"\";\n  Identity identity = null;\n  if(plan.getIdentity()!=null){\n    identity = plan.getIdentity();\n    if (identity!= null) {\n      identityName = identity.getName();\n    } else {\n      log.warn(\"Identity is null\");\n    }\n  } else{\n    log.warn(\"Identity is null\");\n  }\n\n\n  //sphinx: deprovision group in ad when one fails- starts\n  if(plan.getArguments()!=null){\n    Map mapOfPlanArguments= new HashMap();\n    String wfSource= \"\";\n    String identityRequestIdForSphinx= \"\";\n    Attributes attrOfPlan= plan.getArguments();\n    List provResultForAllReq= new ArrayList();\n\n    if(attrOfPlan.getMap()!=null){\n      mapOfPlanArguments= attrOfPlan.getMap();\n      if (mapOfPlanArguments.get(\"workflowSource\")!=null){\n        wfSource= mapOfPlanArguments.get(\"workflowSource\");\n        if (wfSource.equalsIgnoreCase(\"Sphinx Safe Creation\")){\n          log.debug(\"The method to deprovision group is being called for sphinx\");\n          deprovisionGroup(plan);\n        }\n      }\n    }\n  }\n  //sphinx: deprovision group in ad when one fails- ends\n\n  public void prepareMap() {\n    svctierMap.put(BANK_SOUTH_TELLER, \"Bronze\");\n    svctierMap.put(BANK_SOUTH_NON_TELLER, \"Gold\");\n    svctierMap.put(BANK_CENTRAL_TELLER, \"Bronze\");\n    svctierMap.put(BANK_CENTRAL_NON_TELLER, \"Gold\");\n    svctierMap.put(NORTH_EAST_TELLER, \"Bronze\");\n    svctierMap.put(NORTH_EAST_NON_TELLER, \"Gold\");\n    svctierMap.put(NOT_A_BANK_USER, \"Gold\");\n\n    organizationMap.put(BANK_SOUTH_TELLER, \"COB\");\n    organizationMap.put(BANK_SOUTH_NON_TELLER, \"COB\");\n    organizationMap.put(BANK_CENTRAL_TELLER, \"CCBCORP\");\n    organizationMap.put(BANK_CENTRAL_NON_TELLER, \"CCBCORP\");\n    organizationMap.put(NORTH_EAST_TELLER, \"NFB\");\n    organizationMap.put(NORTH_EAST_NON_TELLER, \"NFB\");\n    organizationMap.put(NOT_A_BANK_USER, \"\");\n  }\n\n  public String[] getSpecialAttribute(AccountRequest accReq) {\n    String[] csvAtt = new String[2];\n    String accountType = (String) accReq.getArgument(\"accountType\");\n    String userType = (String) accReq.getArgument(\"userType\");\n    if (accountType != null && accountType.equals(\"User\")) {\n      if (userType != null) {\n        userType = userType.toUpperCase();\n        userType = userType.trim();\n        csvAtt[0] = svctierMap.get(userType);\n        csvAtt[1] = organizationMap.get(userType);\n      }\n    } else if (accountType != null && accountType.equals(\"System\")) {\n        csvAtt[0] = \"Gold\";\n        csvAtt[1] = \"\";\n    }\n    return csvAtt;\n  }\n\n  public boolean pushExchangeCsv(String csvStr, String fileName) {\n    log.debug(\"Entering method pushExchangeCsv\");\n    boolean result = false;\n\n    OutputStream os = null;\n    DiskShare share = null;\n    try {\n      //Fetch the exchange CSV server form the AD application attributes\n      Map remoteServerDetails = (Map) application.getAttributes().get(\"ExchangeCSVremoteServer\");\n\n      String domain = (String) remoteServerDetails.get(\"domain\");\n      String userName = (String) remoteServerDetails.get(\"userName\");\n      String password = context.decrypt((String) remoteServerDetails.get(\"password\"));\n      String basePath = (String) remoteServerDetails.get(\"basePath\");\n      String host = (String) remoteServerDetails.get(\"host\");\n      File file = null;\n\n      //parse the basePath and fileName for the new format that smbj requires\n      fileName = basePath.substring(4) + fileName + \".csv\";\n      fileName = fileName.replace(\"/\", \"\\\\\");\n      basePath = basePath.substring(1, 3);\n\n      SmbConfig config = SmbConfig.builder()\n          .withTimeout(120, TimeUnit.SECONDS)\n          .withSoTimeout(180, TimeUnit.SECONDS)\n          .build();\n\n      SMBClient client = new SMBClient();\n      Connection connection = client.connect(host);\n      log.debug(\"Connected to SMB Share...\");\n\n      AuthenticationContext ac = new AuthenticationContext(userName, password.toCharArray(), domain);\n      Session session = connection.authenticate(ac);\n      log.debug(\"Session Established...\");\n\n      share = (DiskShare) session.connectShare(basePath);\n      log.debug(\"Connected to DiskShare...\");\n\n      file = share.openFile(fileName,\n        new HashSet(Arrays.asList(AccessMask.GENERIC_ALL)),\n        new HashSet(Arrays.asList(FileAttributes.FILE_ATTRIBUTE_NORMAL)),\n        SMB2ShareAccess.ALL,\n        SMB2CreateDisposition.FILE_CREATE,\n        new HashSet(Arrays.asList(SMB2CreateOptions.FILE_DIRECTORY_FILE))\n      );\n\n      log.debug(\"File Created...\");\n\n      os = (OutputStream) file.getOutputStream();\n      try {\n        os.write((\"eid,svctier,alias,organization\" + \"\\r\\n\").getBytes());\n        os.write(csvStr.getBytes());\n        os.flush();\n        result = true;\n      } catch (IOException ex) {\n        log.debug(\"Exception occured due to:\" + ex.getMessage());\n      }\n\n    } catch (IOException ex) {\n        log.debug(\"Exception occured due to:\" + ex.getMessage());\n    } catch (GeneralException ex) {\n        log.debug(\"Exception occured due to:\" + ex.getMessage());\n    } finally {\n      try {\n        os.close();\n      } catch (IOException ex) {\n        log.debug(\"Exception occured due to:\" + ex.getMessage());\n      }\n      try {\n        share.close();\n      } catch (IOException ex) {\n        log.debug(\"Exception occured due to:\" + ex.getMessage());\n      }\n    }\n    log.debug(\"Exiting method pushExchangeCsv:\" + result);\n    return result;\n  }\n\n  /**\n  * Sends email notification to user after deleting A- account with information about groups that are being deleted\n  * @param plan\n  * @param deleteAccReq\n  * @param identity\n  * @return\n  */\n  public boolean sendADAHyphenAccountDeletionMail(ProvisioningPlan plan, ProvisioningPlan.AccountRequest deleteAccReq, Identity identity) {\n    log = LogFactory.getLog(\"com..rap.RuleLibrary.sendADAHyphenAccountDeletionMail\");\n    log.info(\"Enter sendADAHyphenAccountDeletionMail()\");\n    log.debug (\"SHRTEST - 2\");\n    String ATTRIBUTE_MEMBER_OF = \"memberOf\";\n    String emailTemplateName = \" Active Directory A Hyphen Deletion Notification\";\n    boolean success = false;\n    IdentityService identityService = new IdentityService(context);\n    Link link = null;\n    String identityRequestId = null;\n    EmailTemplate emailTemplate = null;\n\n    try {\n      if (ProvisioningPlan.AccountRequest.Operation.Delete.equals(deleteAccReq.getOperation())) {\n        log.debug (\"SHRTEST - 3\");\n        emailTemplate = context.getObject(EmailTemplate.class, emailTemplateName);\n        if (emailTemplate == null)\n            throw new NullPointerException(\"Unable to find email template :\" + emailTemplateName);\n        identityRequestId = (String) plan.get(\"identityRequestId\");\n        Application application = deleteAccReq.getApplication(context);\n        String nativeIdentity = deleteAccReq.getNativeIdentity();\n        link = identityService.getLink(identity, application, null, nativeIdentity);\n        List <String> adGroups = sailpoint.tools.Util.asList(link.getAttribute(ATTRIBUTE_MEMBER_OF));\n\n        //sanity check in case there are no groups to remove\n        if (adGroups == null || adGroups.isEmpty()) {\n          adGroups = new ArrayList();\n          adGroups.add(\"**This account did not have any entitlements to remove\");\n        }\n        String groupString = \"\";\n        for (String group: adGroups) {\n          groupString = groupString + group + \"<br/>\";\n        }\n\n        /*update email body*/\n        String body = emailTemplate.getBody();\n        body = body.replaceAll(\"\\\\$groups\", groupString);\n        body = body.replaceAll(\"\\\\$identityRequestId\", identityRequestId);\n\n        emailTemplate = (EmailTemplate) emailTemplate.clone();\n        emailTemplate.setBody(body);\n        /*end update email body*/\n\n        //set email options\n        EmailOptions emailOptions = new EmailOptions();\n        Map variables = new HashMap();\n        emailOptions.setTo(identity.getEmail());\n        emailOptions.setSendImmediate(true);\n        variables.put(\"body\", body);\n        emailOptions.addVariables(variables);\n\n        //send email\n        context.sendEmailNotification(emailTemplate, emailOptions);\n        success = true;\n      } else {\n        log.warn(\"account request was not a delete request\");\n      }\n    } catch (Exception ex) {\n      log.debug(\"unable to send A- deletion email\");\n      log.debug(ex);\n    }\n    log.info(\"Exit sendADAHyphenAccountDeletionMail()\");\n    return success;\n  }\n\n  /**\n  * Sends email notification to  mailbox owner after a  mailbox account is created\n  * @param Service Identity Name\n  * @param Sam account name of account created\n  * @param mailboxOwner\n  */\n  public boolean sendSharedMailboxOwnerEmail( String svcIdentityName, String sAMAccountName, String mailboxOwner, String sharedMailboxDisplayName, String accountSubtype){\n\n    log.debug(\"Enter sendSharedMailboxOwnerEmail\");\n\n    String emailTemplateName = null;\n\n    if (accountSubtype.equalsIgnoreCase(\"Shared Mailbox\")){\n      emailTemplateName = \" EmailTemplate Shared Mailbox Creation Notify Owner\";\n      log.debug (\"SHRTEST Accountsubtype \" + accountSubtype);\n    } else if(accountSubtype.equalsIgnoreCase(\"Kiosk\")){\n      emailTemplateName = \" EmailTemplate Kiosk Creation Notify Owner\";\n      log.debug (\"SHRTEST Accountsubtype \" + accountSubtype);\n    } else if(accountSubtype.equalsIgnoreCase(\"Service\")){\n      emailTemplateName = \" EmailTemplate System Account Creation Notify Owner\";\n      log.debug (\"SHRTEST Accountsubtype \" + accountSubtype);\n    }\n\n    boolean success = false;\n\n    EmailTemplate emailTemplate = context.getObject(EmailTemplate.class, emailTemplateName);\n    if (emailTemplate == null)\n      throw new NullPointerException(\"Unable to find email template :\" + emailTemplateName);\n\n    Identity ownerIdentity  = context.getObjectByName(Identity.class,mailboxOwner);\n    String to = ownerIdentity.getEmail();\n\n    log.debug(\"to: \"+to);\n    if (to == null){\n      throw new GeneralException(\"email of the shared mailbox/kiosk owner is null\");\n    }\n\n    //set the required variables in the args map so that we can use in email template\n    Map args = new HashMap();\n    args.put(\"svcIdentityName\", svcIdentityName);\n    args.put(\"sAMAccountName\", sAMAccountName);\n    args.put(\"mailboxOwner\", mailboxOwner);\n    args.put(\"sharedMailboxDisplayName\", sharedMailboxDisplayName);\n    if(null != ownerIdentity){\n      args.put(\"requestor\",ownerIdentity.getDisplayableName());\n    }\n\n\n    log.debug(\"Successfully populated the args map: \"+args);\n\n    EmailOptions options = new EmailOptions();\n    options.setTo(to);\n    options.setVariables(args);\n    log.debug(\"Successfully set to and args in the email options\");\n    try{\n      context.sendEmailNotification(emailTemplate, options);\n      success = true;\n    } catch (EmailException e) {\n      log.debug(e);\n    }\n\n    log.debug(\"Exit sendSharedMailboxOwnerEmail: \"+success);\n    return success;\n  }\n\n  //IAM-97573 : send email to cyberak for creation/Modify Method\n\n  public boolean sendSharedMailboxCyberArkEmail(String previousOwner,String newOwner,String operation,String firstname,String lastname,String emailID,String sAMAccountName,String domain){\n    log.debug(\"Enter sendSharedMailboxCyberArkEmail\");\n    String emailTemplateName= \" AD SharedMailBox Vaulting Notification\";\n\n    boolean success = false;\n\n    EmailTemplate emailTemplate = context.getObject(EmailTemplate.class, emailTemplateName);\n    if (emailTemplate == null){\n      throw new NullPointerException(\"Unable to find email template :\" + emailTemplateName);\n    }\n\n    Identity workgroup=context.getObjectByName(Identity.class,\" CyberArk L3 Workgroup\");\n    List to=ObjectUtil.getEffectiveEmails(context,workgroup);\n\n    log.debug(\"to: \"+to);\n    if (to == null){\n      throw new GeneralException(\"email of the shared mailbox/kiosk owner is null\");\n    }\n\n    //set the required variables in the args map so that we can use in email template\n    Map args = new HashMap();\n    args.put(\"previousOwner\",previousOwner);\n    args.put(\"newOwner\",newOwner);\n    args.put(\"firstname\",firstname);\n    args.put(\"lastname\",lastname);\n    args.put(\"emailID\",emailID);\n    args.put(\"sAMAccountName\",sAMAccountName);\n    args.put(\"domain\",domain);\n    args.put(\"operation\",operation);\n\n\n    log.debug(\"Successfully populated the args map: \"+args);\n\n    EmailOptions options = new EmailOptions();\n    options.setTo(to);\n    options.setVariables(args);\n    log.debug(\"Successfully set to and args in the email options2\");\n    try{\n      context.sendEmailNotification(emailTemplate, options);\n      success = true;\n    } catch (EmailException e) {\n      log.debug(e);\n    }\n\n    log.debug(\"Exit sendSharedMailboxOwnerEmail: \"+success);\n    return success;\n\n  }\n\n  // END IAM-97573 :- send email to cyberak for creation/Modify Method\n\n  public void updateAccReqOU(AccountRequest accReq){\n    log.debug(\"updateAccReqOU() : start\" );\n    try{\n      String appName = \"Active Directory\";\n      // getcustomobject bulkOn value\n      String BULK_CUSTOM_OBJECT_NAME = \" Bulk Batch Request Custom\";\n      String bulkOn = \"\";\n      Custom bulkCustomObject = context.getObjectByName(Custom.class, BULK_CUSTOM_OBJECT_NAME);\n      if(bulkCustomObject!=null){\n        List bulkOns = bulkCustomObject.get(\"bulkOn\")!=null?bulkCustomObject.get(\"bulkOn\"):\"\";\n        if(bulkOns.size()>1){\n          bulkOn = \"true\";\n        } else {\n          bulkOn = bulkOns.get(0);\n        }\n      }\n      //\n      if((bulkOn.isEmpty() || bulkOn.equalsIgnoreCase(\"false\")) \n        && accReq.getAttributeRequest(\"AC_NewParent\") !=null\n        && (!(accReq.getAttributeRequest(\"AC_NewParent\").getValue().toString()).isEmpty())){\n\n        log.debug(\"*************** Enter updateAccReqOU for In fly Request ******************\");\n\n        if(links==null){\n          Application application=context.getObjectByName(Application.class, appName);\n          //Identity identity = context.getObjectByName(Identity.class, identityName);\n          IdentityService idenService = new IdentityService(context);\n          links = idenService.getLinks(identity, application);\n        }\n\n        String changedDN =null;\n        String accReqOldLinkDN = null;\n        log.debug(\"AC_NewParent : \" + accReq.getAttributeRequest(\"AC_NewParent\").getValue() );\n        Object changedOUofDN = accReq.getAttributeRequest(\"AC_NewParent\").getValue();\n        log.debug(\"changedOUofDN : \" + changedOUofDN );\n        String provisionedAccountDN = accReq.getNativeIdentity();\n        log.debug(\"provisionedAccountDN : \" + provisionedAccountDN );\n        //gettting accountname ex: CN=EID or CN=P-EID or CN=A-EID or CN=W-EID\n        String[] splittedprovisionedAccountDN = provisionedAccountDN.split(\",\");\n        log.debug(\"splittedprovisionedAccountDN : \" + splittedprovisionedAccountDN );\n\n        changedDN = splittedprovisionedAccountDN[0]+\",\"+changedOUofDN;\n        log.debug(\"changedDN : \" + changedDN );\n\n        String derAccDN = splittedprovisionedAccountDN[0];\n        log.debug(\"derAccDN : \" + derAccDN );\n        String[] superAccDN =  derAccDN.split(\"=\");\n        log.debug(\"superAccDN : \" + superAccDN );\n        String derivedAccountName = superAccDN[1];\n        log.debug(\"derivedAccountName : \" + derivedAccountName );\n        String[] cnName = provisionedAccountDN!=null && !provisionedAccountDN.isEmpty() ? provisionedAccountDN.split(\",\") : \"\";\n        log.error(\" gk0628 cnName: \"+cnName);\n        String[] cnNameSplit = cnName!=null  ? cnName[0].split(\"=\") : \"\";\n        log.error(\" gk0628 cnNameSplit: \"+cnNameSplit);\n        String accountName = cnNameSplit!=null ? cnNameSplit[1] : \"\";\n        log.error(\" gk0628 accountName: \"+accountName);\n        //getting DC name\n        String[] dcParse = provisionedAccountDN!=null && !provisionedAccountDN.isEmpty() ?  provisionedAccountDN.substring(provisionedAccountDN.indexOf(\"DC=\"),provisionedAccountDN.length()).split(\",\") : \"\";\n        log.error(\" gk0628 dcParse: \"+dcParse);\n        String[] dcSplit =  dcParse[0]!=null  ? dcParse[0].split(\"=\") : \"\";\n        log.error(\" gk0628 dcSplit: \"+dcSplit);\n        String dcName = dcSplit[1]!=null  ? dcSplit[1] : \"\";\n        log.error(\" gk0628 dcName: \"+dcName);\n        String oldAccDispName = dcName+\"\\\\\"+accountName;\n        log.error(\" gk0628 oldAccDispName: \"+oldAccDispName);\n          \n        // to gather old link DN in-order to delete old link/account before running Single Account Aggregation to get updated Link instantly\n        if(links!=null && !links.isEmpty()){\n          for(Link link:links){\n            if (link.getDisplayName()!=null && link.getDisplayName().equalsIgnoreCase(oldAccDispName)){\n              accReqOldLinkDN = link.getNativeIdentity();  // gathering accReqOldLinkDN to delete old AD Account in All Access\n              break;\n            }\n          }\n        }\n        log.debug(\"accReqOldLinkDN : \" + accReqOldLinkDN );\n\n        ProvisioningResult result = accReq.getResult();\n        log.debug(\"result : \" + result );\n\n        if(result!=null){\n          log.debug(\"result not null : \" + result );\n          if (result.isCommitted() || result.isSubmitted()) {\n            log.debug(\"result.isCommitted : \" + result.isCommitted() + \" result.isSubmitted : \" + result.isSubmitted() );\n            if(changedDN!=null){\n              log.debug(\"changedDn not null : \" + changedDN);\n              String caseName = \" Local Admin OU Change Workflow - case\";\n              log.debug(\"=================Staring OU change Workflow Launch Rule =============\");\n              Map launchArgsRuleMap = new HashMap();\n              launchArgsRuleMap.put(\"appName\",appName);\n              launchArgsRuleMap.put(\"changedDN\",changedDN);\n              launchArgsRuleMap.put(\"identityName\",identityName);\n              launchArgsRuleMap.put(\"oldLinkDN\",accReqOldLinkDN);\n              launchArgsRuleMap.put(\"derivedAccountName\",derivedAccountName);\n\n              WorkflowLaunch wflaunch = new WorkflowLaunch();\n              Workflow wf = (Workflow) context.getObjectByName(Workflow.class, \" AD OU Change Workflow\");\n              wflaunch.setWorkflowName(wf.getName());\n              wflaunch.setWorkflowRef(wf.getName());\n              wflaunch.setCaseName(caseName);\n              wflaunch.setVariables(launchArgsRuleMap);\n            // Workflower workflower = new Workflower(context);\n              //WorkflowLaunch launch = workflower.launch(wflaunch);\n              log.debug(\"===============Ending OU change Workflow Launch Rule ==============\");\n            }\n          }\n        }\n        log.debug(\"*************** Exit updateAccReqOU for In fly Request ******************\");\n      }\n    } catch(GeneralException ex){\n      log.error(\"Exception in updateAccReqOU() : \" + ex.getMessage() );\n    }\n    log.debug(\"updateAccReqOU() : end\" );\n  }\n\n  public void launchWorkflow(String wfName, Map launchArgsMap, String caseName) throws GeneralException {\n    try{\n      WorkflowLaunch wflaunch = new WorkflowLaunch();\n      Workflow wf = context.getObjectByName(Workflow.class,wfName);\n\n      if(wf != null){\n        wflaunch.setWorkflowName(wf.getName());\n        wflaunch.setWorkflowRef(wf.getName());\n        wflaunch.setCaseName(caseName);\n        wflaunch.setVariables(launchArgsMap);\n\n        //Create Workflower and launch workflow from WorkflowLaunch\n        Workflower workflower = new Workflower(context);\n        workflower.launch(wflaunch);\n      }\n    } catch (Exception e){\n      throw new GeneralException(\"Exception thrown while launching workflow :: \"+wfName,e);\n    }\n  }\n\n  public void manageCyberArkVaultAccessDashAccount(String sAMAccountName, ProvisioningPlan plan, String operation){\n    log.error(\" AD AfterProvisioning Rule: Dash account \"+operation+\" CyberArk Vault Access for account - \"+sAMAccountName);\n    String requesterName = null;\n    List requesters = plan.getRequesters();\n    if(!Util.isEmpty(requesters)){\n      requesterName = ((Identity)requesters.get(0)).getName();\n    } else {\n      requesterName = \"spadmin\";\n    }\n    String cyberArkVaultAccountWF = \" CyberArk Vault Account Management Workflow\";\n    String caseName = cyberArkVaultAccountWF+\" for \"+sAMAccountName+\" \"+System.currentTimeMillis();\n    Map launchArgsMap = new HashMap();\n    launchArgsMap.put(\"launcher\",requesterName);\n    launchArgsMap.put(\"sessionOwner\",requesterName);\n    launchArgsMap.put(\"operation\",operation);\n    launchArgsMap.put(\"accountName\",sAMAccountName);\n    //launching the workflow\n    launchWorkflow(cyberArkVaultAccountWF,launchArgsMap,caseName);\n    log.error(\" AD AfterProvisioning Rule: Dash Account \"+operation+\" CyberArk Vault Access - workflow launched\");\n  }\n\n\n  /*RULE LOGIC STARTS HERE */\n  try {\n    Attributes attributes = (Attributes) XMLObjectFactory.getInstance().cloneWithoutId(plan.getArguments(), context);\n    List accReqs = plan.getAccountRequests(application.getName());\n    String sAMAccountName = null;\n    String sMDisplayName = null;\n    for (AccountRequest accReq: accReqs) {\n      ProvisioningResult result = accReq.getResult();\n      AttributeRequest passwordAtt = accReq.getAttributeRequest(\"password\");\n      if (passwordAtt != null &&passwordAtt.getValue() != null) {\n        password = (String) passwordAtt.getValue();\n      }\n      String applicationName = accReq.getApplicationName();\n      String nativeIdentityName = accReq.getNativeIdentity();\n      //starts:uidNumber Provisioning for Sphinx and Centrify Groups\n\n      List allAttributeReqs= new ArrayList();\n      if (result != null && result.isCommitted()){\n\n        // IAM-129436 This logic has been added to delete AD Accounts after 7 days after user is disabled\n        Iterator oldItr = null;\n        Iterator itr = null;\n        boolean isTedsInactive = false;\n            \n        try{\n          if(accReq.getAttributeRequests()!=null && (accReq.getOp().toString().equals(\"Disable\"))) {\n            Identity identity = context.getObjectByName(Identity.class,identityName);\n            Application application = context.getObjectByName(Application.class,\"TEDS - HR\");\n            IdentityService service = new IdentityService(context);\n            List hrLinks = service.getLinks(identity,application);\n            if(hrLinks!=null && !hrLinks.isEmpty()) {\n              if(\"I\".equalsIgnoreCase(hrLinks.get(0).getAttribute(\"EMPLOYEESTATUS\") )) {\n                isTedsInactive =  true;\n              }\n            }\n            log.error(\"line 636 isTedsInactive\" + isTedsInactive + \"  for : \" + identityName);\n            if(isTedsInactive || (plan!=null && plan.getIdentity()!=null && plan.getIdentity().isInactive()) ) {\n              log.error(\"nativeIdentityName line 652\");\n              QueryOptions oldQue = new QueryOptions();\n              Filter f1 = Filter.like(\"name\",\"Delete AD Accounts for ::\",Filter.MatchMode.START);\n              Filter f2 = Filter.like(\"name\",nativeIdentityName,Filter.MatchMode.END);\n              Filter f = Filter.and(f1,f2);\n              oldQue.addFilter(f);\n              oldItr = context.search(Request.class, oldQue);\n              if(oldItr == null || (oldItr!=null && !oldItr.hasNext()) ) {\n                log.error(\"line 662\");\n                RequestDefinition reqD = context.getObjectByName(RequestDefinition.class,\"Workflow Request\");\n                reqD.setName(\"Workflow Request\");\n\n                Date currentDate = new Date();\n                Date nextLaunchDate;\n                Calendar calendar = Calendar.getInstance();\n                calendar.setTime(currentDate);\n        \n                if(nativeIdentityName.toUpperCase().contains(\"CN=\" + identityName.toUpperCase())) {\n                  calendar.add(Calendar.DATE, 60);\n                  nextLaunchDate = calendar.getTime();\n                } else {    \n                  calendar.add(Calendar.DATE, 7);\n                  nextLaunchDate = calendar.getTime();    \n                }\n                Request req = new Request();\n                req.setDefinition(reqD);\n                req.setLauncher(\"spadmin\");\n                req.setName(\"Delete AD Accounts for :: \" + nativeIdentityName);\n                req.setNextLaunch(nextLaunchDate);\n                req.setOwner(context.getObjectByName(Identity.class,\"spadmin\"));\n\n                Attributes attr = new Attributes();\n                Map attrMap = new HashMap();\n                attrMap.put(\"assigner\",\"spadmin\");\n                attrMap.put(\"date\", nextLaunchDate);\n                attrMap.put(\"identityName\",identityName);\n                attrMap.put(\"nativeIdentity\",nativeIdentityName);\n                attrMap.put(\"workflow\",\" Delete Inactive AD Accounts Workflow\");\n                attr.setMap(attrMap);\n                req.setAttributes(attr);\n                context.saveObject(req);\n                      \n                AuditEvent event = new AuditEvent();\n                event.setSource(\" Delete Inactive AD Accounts Workflow\");\n                event.setAction(\"Request to Delete AD Account\");\n                event.setApplication(\"Active Directory\");\n                event.setTarget(identityName);\n                event.setAccountName(nativeIdentityName);\n                event.setString1(\"WF Launch Date :: \" + nextLaunchDate.toString());\n                context.saveObject(event);                  \n                  \n                context.commitTransaction(); \n                log.error(\"Req is crewated for \" + nativeIdentityName);\n              } else {\n                log.error(\"no Req is not crewated for \" + nativeIdentityName);\n              }\n            } else {\n              log.error(\"condition not satisfied for \" + nativeIdentityName);\n            }\n          }\n          log.error(\"accReq.getAttributeRequests is \" + accReq.getAttributeRequests());    \n          if( accReq.getOp().toString().equals(\"Enable\")){\n            log.error(\"nativeIdentityName line 690\");\n            Filter f1 = Filter.like(\"name\",\"Delete AD Accounts for ::\",Filter.MatchMode.START);\n            Filter f2 = Filter.like(\"name\",nativeIdentityName,Filter.MatchMode.END);\n            Filter f = Filter.and(f1,f2);\n            QueryOptions oop = new QueryOptions();\n            oop.addFilter(f);\n            itr = context.search(Request.class, oop);\n\n            if(itr!=null && itr.hasNext()) {\n              log.error(\"Request already exists for nativeIdentityName,so deleting it\");\n              Request oldReq = (Request) itr.next();\n              context.removeObject(oldReq);\n              \n              AuditEvent event = new AuditEvent();\n              event.setSource(\" Delete Inactive AD Accounts Workflow\");\n              event.setAction(\"Request to Delete Request\");\n              event.setApplication(\"Active Directory\");\n              event.setTarget(identityName);\n              event.setAccountName(nativeIdentityName);\n              context.saveObject(event);\n              context.commitTransaction();\n            } else {\n              log.error(\"Request does not exists for nativeIdentityName ::\" + nativeIdentityName);\n            }\n          }\n        } catch(Exception e) {\n          log.error(\"Exception e is \" + e.getMessage());\n        } finally {\n          Util.flushIterator(oldItr); \n          Util.flushIterator(itr);          \n        }\n\n        if(accReq.getAttributeRequests()!=null && (accReq.getOp().toString().equals(\"Modify\"))){\n          allAttributeReqs=accReq.getAttributeRequests();\n          boolean checkSatisfied= false;\n\n          for(AttributeRequest attrRequest: allAttributeReqs){\n            if((attrRequest.getName().equalsIgnoreCase(\"memberOf\")) && (attrRequest.getOp().toString().equalsIgnoreCase(\"Add\")) && (attrRequest.getValue()!= null)){\n              if(attrRequest.getValue() instanceof String){\n                memberOfInAD = (String) attrRequest.getValue();\n              } else if (attrRequest.getValue() instanceof java.util.List){\n                List memberOfInADList= new ArrayList();\n                memberOfInADList=attrRequest.getValue();\n                memberOfInAD=\"\";\n                for(String valueOfAR: memberOfInADList){\n                  memberOfInAD= memberOfInAD+ \",\"+ valueOfAR;\n                }\n              }\n              List checksForUIDProv= new ArrayList();\n              checksForUIDProv.add(\"CN=QAWS_\");\n              checksForUIDProv.add(\"CN=DAWS_\");\n              checksForUIDProv.add(\"CN=POPS_\");\n\n              for(String check: checksForUIDProv){\n                String lCase= check.toLowerCase();\n                String ouSphinxLCase= \",ou=sphinx,\";\n                String ouCheckLCase= \",ou=bigdata,ou=groups,\";\n\n                if(((memberOfInAD.toLowerCase().contains(\"cn=sphinx-\")) \n                    && (memberOfInAD.toLowerCase().contains(ouSphinxLCase)))||((memberOfInAD.toLowerCase().contains(lCase)) \n                    && (memberOfInAD.toLowerCase().contains(ouCheckLCase)))){\n                  log.error(\"This requested group is a sphinx or centrify group\"+ memberOfInAD);\n                  checkSatisfied= true;\n                  break;\n                }\n              }\n            }\n            if(checkSatisfied){\n              break;\n            }\n          }\n          log.debug(\"checkSatisfied is\" + checkSatisfied);\n          if(checkSatisfied){\n            List sidAndUID= new ArrayList();\n            String objectSid= \"\";\n            String uidNumber= \"\";\n            String searchString= \"(distinguishedName=\" + nativeIdentityName + \")\";\n\n            try{\n              sidAndUID= getObjectSidAnduidNumber(searchString);\n            } catch (Exception ex) {\n              log.error(\"Couldn\'t try grabbing objectSid and uidNumber\"+ ex.getMessage());\n              throw new GeneralException(\"Couldn\'t try grabbing objectSid and uidNumber\",ex.getMessage());\n            }\n\n            log.debug(\"The value of sidAndUID is\" + sidAndUID);\n            if(sidAndUID!=null && !sidAndUID.isEmpty()){\n              objectSid= sidAndUID.get(0);\n              uidNumber= sidAndUID.get(1);\n\n              if(uidNumber.equals(\"NA\") && (objectSid!=null)){\n                try{\n                  log.error(\"The uidNumber is NA\");\n                  String uidNumber= getUIDNumber(objectSid);\n                  log.error(\"The value of generated uidNumber is\"+uidNumber);\n                  provisionUIDNumber(plan.getNativeIdentity(),uidNumber,nativeIdentityName);\n                } catch (Exception ex) {\n                  log.error(\"Couldn\'t provision uidNumber\"+ ex.getMessage());\n                  throw new GeneralException(\"Couldn\'t provision uidNumber\",ex.getMessage());\n                }\n              }\n              else{\n                //do nothing\n                log.error(\"The uid Number already exists or objectSid not present\");\n              }\n            } else{\n              log.error(\"The value of list returned after LDAP search is empty\");\n            }\n          }\n        }\n      }\n      //ends\n      //Getting sAMAccountName and domain\n      Custom adCustomObject = context.getObjectByName(Custom.class, CUSTOM_OBJECT_NAME);\n      if (accReq.getAttributeRequest(\"sAMAccountName\") != null) {\n        sAMAccountName = (String) accReq.getAttributeRequest(\"sAMAccountName\").getValue();\n      }\n      if (accReq.getAttributeRequest(\"displayName\") != null) {\n        sMDisplayName = (String) accReq.getAttributeRequest(\"displayName\").getValue();\n      }\n      String domain = adCustomObject.get(\"_AD_DOMAIN_NAME\");\n      log.debug(\"A-domain: \"+domain);\n      if (result != null && result.isCommitted()) {\n        updateAccReqOU(accReq);\n        ////IAM-97573 : Transfer case for cyberark email\n        if (AccountRequest.Operation.Modify.equals(accReq.getOperation()) \n            && accReq.getNativeIdentity().contains(\"OU=Resource Mailboxes,OU=Exchange\") \n            && plan.getArguments().getMap().get(\"Requesttype\") != null \n            && \"Shared MailBox Modify\".equals(plan.getArguments().getMap().get(\"Requesttype\")) \n            && plan.getArguments().getMap().get(\"operation\") != null \n            && \"Change Owner\".equals(plan.getArguments().getMap().get(\"operation\"))) {\n\n          //getting samaccount from link\n          String sAMAccountName = null;         \n          Identity identity = context.getObjectByName(Identity.class,plan.getNativeIdentity());\n          IdentityService service = new IdentityService(context);\n          if(identity!=null && application!=null ){\n            Link sAMaccountLink = service.getLink(identity, application, null, accReq.getNativeIdentity());\n            sAMAccountName = sAMaccountLink!=null ? (sAMaccountLink.getAttribute(\"sAMAccountName\")!=null?sAMaccountLink.getAttribute(\"sAMAccountName\"):accReq.getNativeIdentity()):\"LinkNull\";\n          }\n          //end samaccount from link\n        \n          //String sAMAccountName = accReq.getNativeIdentity();\n          String operation = \"Change Owner\";\n          String domain = accReq.getNativeIdentity().contains(\"DC=\")?\"\":\"\";\n          String newOwner = accReq.getAttributeRequest(\"physicalDeliveryOfficeName\").getValue();\n          Identity serviceIdentity = context.getObjectByName(Identity.class,plan.getNativeIdentity());\n          String currentOwnerId = serviceIdentity.getAttribute(\"ManagedBy\");\n          if(newOwner != null){\n            //Updating the custom object for sharedmailbox epv_enduser provisioning\n            String displayName=\"\\\\\"+newOwner;\n            String linkNativeIdentiy =null;\n            QueryOptions qo = new QueryOptions();\n            qo.addFilter(Filter.eq(\"application.name\",\"Active Directory\"));\n            qo.addFilter(Filter.eq(\"identity.name\",newOwner));\n            qo.addFilter(Filter.eq(\"displayName\",displayName));\n            Iterator iterator = null;\n            try{\n              iterator = context.search(Link.class,qo,\"nativeIdentity\");\n              if(iterator!=null){\n                while(iterator.hasNext()){\n                  Object[] props = (Object[])iterator.next();\n                  linkNativeIdentiy = (String)props[0];\n                }\n              }\n            }catch (Exception e){\n              throw e;\n            } finally {\n              Util.flushIterator(iterator);\n            }\n            if(linkNativeIdentiy!=null && !linkNativeIdentiy.equals(\"\")){\n              Custom custom = context.getObject(Custom.class,\" AD SharedMailBox EPVEndUser Custom Object\");\n              if(custom!=null){\n                //custom = ObjectUtil.lockObject(context, Custom.class, customObject.getId(), Util.uuid(),PersistenceManager.LOCK_TYPE_TRANSACTION,ObjectUtil.DEFAULT_LOCK_TIMEOUT );\n                String entryValue  = \"ChangeOwner::\"+newOwner+\"::\"+linkNativeIdentiy;\n                if(custom.get(\"AccessRequests\")==null){\n                  custom.put( \"AccessRequests\" , entryValue );\n                } else {\n                  List requests = Util.asList(custom.get(\"AccessRequests\"));\n                  requests.add(\"ChangeOwner::\"+newOwner+\"::\"+linkNativeIdentiy);\n                  Set finalSet = new HashSet( requests );\n                  requests.clear();\n                  requests.addAll( finalSet );\n                  custom.put( \"AccessRequests\" , requests );\n                }\n                context.saveObject(custom);\n                context.commitTransaction();\n              }\n            } //End updating custom object\n            Identity newSharedOwnerIdentity = context.getObjectByName(Identity.class, newOwner);\n            log.debug(\"serviceIdentity: \"+serviceIdentity);\n            if (newSharedOwnerIdentity != null) {\n              String firstname = newSharedOwnerIdentity.getFirstname()!=null?newSharedOwnerIdentity.getFirstname():\"\" ;\n              String lastname = newSharedOwnerIdentity.getLastname() !=null? newSharedOwnerIdentity.getLastname() :\"\";\n              String emailID = newSharedOwnerIdentity.getEmail() != null? newSharedOwnerIdentity.getEmail():\"\";\n              log.debug(\"About to send email to the mailboxOwner: \"+mailboxOwner);\n              String identityRequestId = (String) plan.get(\"identityRequestId\");\n              sMDisplayName = (String) plan.get(\"mailDisplayName\");\n              //sendSharedMailboxCyberArkEmail(currentOwnerId,newOwner,operation,firstname,lastname,emailID,sAMAccountName,domain);\n              vaultADAffiliatedAccountInCyberArk(\"SharedMailBox\", newOwner,newOwner,currentOwnerId, \"Active Directory\" , identityRequestId ,sAMAccountName,sMDisplayName);\n            }\n          }\n        }\n        ////IAM-97573 : Transfer case for cyberark email end\n        if (AccountRequest.Operation.Create == accReq.getOperation()) {\n          //Creation of cyberark accounts\n          String accountName = null;\n          String requestID = (String) plan.get(\"identityRequestId\");\n          //Identity identity = plan.getIdentity();\n          //IAM-97573 : create case for cyberark email\n          String accountSubtype = (String) accReq.getArgument(\"systemAccountSubType\");\n          String previousOwner = \"N/A\";\n          String sAMAccountName = null;\n          String operation = \"Create\";\n          String domain = accReq.getNativeIdentity().contains(\"DC=\")?\"\":\"\";\n\n          log.debug(\"*******BEGIN SHARED MAILBOX/kiosk EMAIL NOTIFICATION*****\");\n          //log.debug(\"mailbox: \"+mailbox);\n          log.debug(\"accountSubtype: \"+accountSubtype);\n\n          if (accountSubtype!=null && accountSubtype.equalsIgnoreCase(\"Shared Mailbox\")) {\n            log.debug(\"System sub account type is Shared Mailbox\");\n\n            if (accReq.getAttributeRequest(\"sAMAccountName\") != null) {\n              sAMAccountName = (String) accReq.getAttributeRequest(\"sAMAccountName\").getValue();\n            }\n            log.debug(\"sAMAccountName: \"+sAMAccountName);\n            Identity serviceIdentity = context.getObjectByName(Identity.class, accReq.getArgument(\"exchangeEID\"));\n            log.debug(\"serviceIdentity: \"+serviceIdentity);\n            if (serviceIdentity != null) {\n\n              String svcIdentityName = serviceIdentity.getName();\n              String newOwner = serviceIdentity.getAttribute(\"ManagedBy\");\n              //Updating the custom object for sharedmailbox epv_enduser provisioning\n              String displayName1=\"\\\\\"+newOwner;\n              String linkNativeIdentiy =null;\n              String identityRequestId = (String) plan.get(\"identityRequestId\");\n              QueryOptions qo = new QueryOptions();\n              qo.addFilter(Filter.eq(\"application.name\",\"Active Directory\"));\n              qo.addFilter(Filter.eq(\"identity.name\",newOwner));\n              qo.addFilter(Filter.eq(\"displayName\",displayName1));\n              Iterator iterator = null;\n              try{\n                iterator = context.search(Link.class,qo,\"nativeIdentity\");\n                if(iterator!=null){\n                  while(iterator.hasNext()){\n                    Object[] props = (Object[])iterator.next();\n                    linkNativeIdentiy = (String)props[0];\n                  }\n                }\n              }catch (Exception e){\n                throw new GeneralException(\"Exception thrown while executing  AD AFter Provisioning Rule\",e);\n              }finally {\n                Util.flushIterator(iterator);\n              }\n          \n              if(linkNativeIdentiy!=null && !linkNativeIdentiy.equals(\"\")){\n                Custom custom = context.getObject(Custom.class,\" AD SharedMailBox EPVEndUser Custom Object\");\n                if(custom!=null){\n                  //custom = ObjectUtil.lockObject(context, Custom.class, customObject.getId(), Util.uuid(),PersistenceManager.LOCK_TYPE_TRANSACTION,ObjectUtil.DEFAULT_LOCK_TIMEOUT );\n                  String entryValue  = identityRequestId+\"::\"+newOwner+\"::\"+linkNativeIdentiy;\n                  if(custom.get(\"AccessRequests\")==null){\n                    custom.put( \"AccessRequests\" , entryValue );\n                  } else {\n                    List requests = Util.asList(custom.get(\"AccessRequests\"));\n                    requests.add(\"identityRequestId::\"+newOwner+\"::\"+linkNativeIdentiy);\n                    Set finalSet = new HashSet( requests );\n                    requests.clear();\n                    requests.addAll( finalSet );\n                    custom.put( \"AccessRequests\" , requests );\n                  }\n                  context.saveObject(custom);\n                  context.commitTransaction();\n                }\n              } \n              //End updating custom object\n//Changes to update getObjectByName to fix Lazy initialization error - IAM-209448 STARTS          \n              //Identity newOwnerIdentity = context.getObject(Identity.class,newOwner);\n              Identity newOwnerIdentity = context.getObjectByName(Identity.class,newOwner);              \n//Changes to update getObjectByName to fix Lazy initialization error - IAM-209448 ENDS              \n              String firstname = newOwnerIdentity.getFirstname()!=null?newOwnerIdentity.getFirstname():\"\" ;\n              String lastname = newOwnerIdentity.getLastname() !=null? newOwnerIdentity.getLastname() :\"\";\n              String emailID = newOwnerIdentity.getEmail() != null? newOwnerIdentity.getEmail():\"\";\n              log.debug(\"About to send email to the mailboxOwner: \"+mailboxOwner);\n              String identityRequestId = (String) plan.get(\"identityRequestId\");\n              vaultADAffiliatedAccountInCyberArk(\"SharedMailBox\", newOwner,newOwner,previousOwner, \"Active Directory\" , identityRequestId ,sAMAccountName,sMDisplayName);\n              //sendSharedMailboxCyberArkEmail(previousOwner,newOwner,operation,firstname,lastname,emailID,sAMAccountName,domain);\n            }         \n          } \n          //END : IAM-97573 : create case for cyberark email\n\n          // Start P- account vaulting \n          if(accReq.getAttributeRequest(\"sAMAccountName\") != null){\n            accountName = (String) accReq.getAttributeRequest(\"sAMAccountName\").getValue();\n          }\n          boolean pHyphenSuccess = false;\n          log.error(\" AD AfterProvisioning Rule: P- Vaulting: nativeIdentity: \" +nativeIdentity);\n          log.error(\" AD AfterProvisioning Rule: P- Vaulting: accountName: \" +accountName);\n          if(accountName != null && accountName.startsWith(\"P-\")){\n            pHyphenSuccess =  vaultADAffiliatedAccountInCyberArk(\"PDash\", identityName,identityName,null,\"Active Directory\",requestID,accountName,null);\n            \n            //IAM-191881 deleting Dash CyberArk Vault Account start\n            manageCyberArkVaultAccessDashAccount(accountName, plan, accReq.getOperation().name());\n            //IAM-191881 deleting Dash CyberArk Vault Account end\n            \n            log.error(\" AD AfterProvisioning Rule: P- Vaulting: pHyphenSuccess: \" +pHyphenSuccess);\n            if(!pHyphenSuccess){\n              result.addError(\"Unable to post password for the AD Account: \" +nativeIdentityName);\n            }\n          }\n          // End P- account vaulting \n\n          // posting the password - Changes implemented from IAM-112519\n          String strsecretManagement=(String) plan.getString(\"secretManagement\");\n          log.debug(\" AD AfterProvisioning Rule: strsecretManagement: \"+strsecretManagement);\n\n          if (strsecretManagement==null && password != null \n              && !isADPHyphenAccount(nativeIdentityName) \n              && !isADAHyphenAccount(nativeIdentityName)){\n            String accountType = (String) accReq.getArgument(\"accountType\");\n            log.debug(\" AD AfterProvisioning Rule: accountType: \"+accountType);\n            // Doing nothing if the account type is a User\n            /* \n            if(accountType != null && accountType.equals(\"User\")){\n              updatePwdInOlad(password, identityName, \"ADDED\", \"AllAccess\", null, applicationName, \"ITO\", nativeIdentityName);\n              String identityRequestId = (String) plan.get(\"identityRequestId\");\n              boolean isPassPost = updatePwdInCyberArk(identityRequestId, password, identityName, nativeIdentityName, applicationName);\n              log.debug(\"User account- isPassPost: \"+isPassPost);\n              if (isPassPost == false){\n                result.addError(\"Unable to post password for \" + nativeIdentityName + \" to CyberArk\");\n              }\n              else{\n                Identity userIdn = context.getObjectByName(Identity.class, identityName);\n                if(Util.isNotNullOrEmpty(userIdn.getEmail())){\n                  String email = userIdn.getEmail();\n                  Map args = new HashMap();\n                  args.put(\"To\", email);\n                  args.put(\"appName\", applicationName);\n                  args.put(\"owner\", userIdn);\n                  args.put(\"loginId\", nativeIdentityName);\n                  EmailTemplate template = context.getObjectByName(EmailTemplate.class,\" CyberArk Account Create Notification\");\n                  EmailOptions  emailOptions = new EmailOptions(email, args);\n                  context.sendEmailNotification(template, emailOptions);\n                  log.debug(\"Email Notification processed :\" + emailOptions);\n                }\n              }\n            } \n            */\n            if(accountType != null && accountType.equals(\"System\")){\n              if(accountSubtype!=null && accountSubtype.equalsIgnoreCase(\"Shared Mailbox\")){\n                String sharedMailboxDisplayName = null;\n                // notify only\n                String sAMAccountName = null;\n                if(accReq.getAttributeRequest(\"sAMAccountName\") != null){\n                  sAMAccountName = (String) accReq.getAttributeRequest(\"sAMAccountName\").getValue();\n                }\n                if(accReq.getAttributeRequest(\"displayName\") != null){\n                  sharedMailboxDisplayName = (String) accReq.getAttributeRequest(\"displayName\").getValue();\n                }\n\n                Identity serviceIdentity = context.getObjectByName(Identity.class, accReq.getArgument(\"exchangeEID\"));\n                if(serviceIdentity != null){\n                  String svcIdentityName = serviceIdentity.getName();\n                  String mailboxOwner = serviceIdentity.getAttribute(\"ManagedBy\");\n                  //sendSharedMailboxOwnerEmail(svcIdentityName, sAMAccountName,mailboxOwner,sharedMailboxDisplayName,accountSubtype);\n                }\n              } else{ // Vault in the CyberArk \n                log.debug(\" AD AfterProvisioning Rule: System Account - Not Shared MailBox\");\n\n                String identityRequestId = (String) plan.get(\"identityRequestId\");\n                boolean isPassPost = updatePwdInCyberArk(identityRequestId, password, identityName, nativeIdentityName, applicationName);\n                log.error(\"System account isPassPost- \"+isPassPost);\n\n                // notify after vaulting\n                if(isPassPost){\n                  Identity srvIdn = context.getObjectByName(Identity.class, identityName);\n                  Identity managedByIdentity = null;\n                  if(srvIdn.getAttribute(\"AccountType\") != null && \"System\".equals(srvIdn.getAttribute(\"AccountType\"))){\n                    String eid=identity.getAttribute(\"ManagedBy\");\n                    managedByIdentity = context.getObjectByName(Identity.class,eid);\n                  }\n                  if(Util.isNotNullOrEmpty(managedByIdentity.getEmail())){\n                    Map args = new HashMap();\n                    args.put(\"To\", managedByIdentity.getEmail());\n                    args.put(\"appName\", applicationName);\n                    args.put(\"owner\", managedByIdentity);\n                    args.put(\"loginId\", nativeIdentityName);\n                    EmailTemplate template = context.getObjectByName(EmailTemplate.class,\" CyberArk Account Create Notification\");\n                    EmailOptions  emailOptions = new EmailOptions(managedByIdentity.getEmail(), args);\n                    context.sendEmailNotification(template, emailOptions);\n                    log.debug(\"Email Notification processed :\" + emailOptions);\n                  }\n                } else {\n                  result.addError(\"Unable to post password for \" + nativeIdentityName + \" to CyberArk for \" + applicationName);\n                }\n              }\n            }\n          } // End of Changes implemented from IAM-112519\n        } else if (AccountRequest.Operation.Delete == accReq.getOperation()) {\n          log.error(\" AD AfterProvisioning Rule DELETE operation :: start\");\n          log.error(\" AD AfterProvisioning Rule DELETE operation :: nativeIdentity \"+nativeIdentityName);\n          if (isADAHyphenAccount(nativeIdentityName) || isADPHyphenAccount(nativeIdentityName)) {\n            log.error(\" AD AfterProvisioning Rule DELETE operation :: removing CyberArk dash account\");\n            String adAccountName = nativeIdentityName.substring(nativeIdentityName.indexOf(\"=\")+1,nativeIdentityName.indexOf(\",\"));\n            log.error(\" AD AfterProvisioning Rule DELETE operation :: adAccountName \"+adAccountName);\n            //IAM-191881 deleting Dash CyberArk Vault Account start\n            manageCyberArkVaultAccessDashAccount(adAccountName, plan, accReq.getOperation().name());\n            //IAM-191881 deleting Dash CyberArk Vault Account end\n          } \n        } \n\n// adding logic for the disable of the CyberArkc dash accounts\n        else if (AccountRequest.Operation.Disable == accReq.getOperation()) {\n          log.error(\" AD AfterProvisioning Rule DELETE operation :: start\");\n          log.error(\" AD AfterProvisioning Rule DELETE operation :: nativeIdentity \"+nativeIdentityName);\n          if (isADAHyphenAccount(nativeIdentityName) || isADPHyphenAccount(nativeIdentityName)) {\n            log.error(\" AD AfterProvisioning Rule DELETE operation :: removing CyberArk dash account\");\n            String adAccountName = nativeIdentityName.substring(nativeIdentityName.indexOf(\"=\")+1,nativeIdentityName.indexOf(\",\"));\n            log.error(\" AD AfterProvisioning Rule DELETE operation :: adAccountName \"+adAccountName);\n            //IAM-191881 deleting Dash CyberArk Vault Account start\n            manageCyberArkVaultAccessDashAccount(adAccountName, plan, accReq.getOperation().name());\n            //IAM-191881 deleting Dash CyberArk Vault Account end\n          } \n        } \n        prepareMap();\n\n        /*\n        if (mailbox != null && mailbox.equalsIgnoreCase(\"Yes\") && accountSubtype!=null && !accountSubtype.equalsIgnoreCase(\"Shared Mailbox\")) {\n          String eid = null;\n          String alias = null;\n          String svctier = null;\n          String organization = null;\n          String sAMAccountName = null;\n\n          eid = (String) accReq.getArgument(\"exchangeEID\");\n          alias = (String) accReq.getArgument(\"exchangeAlias\");\n\n          if (accReq.getAttributeRequest(\"sAMAccountName\") != null) {\n            sAMAccountName = (String) accReq.getAttributeRequest(\"sAMAccountName\").getValue();\n          }\n          String[] splAtt = getSpecialAttribute(accReq);\n\n          svctier = splAtt[0];\n          organization = splAtt[1];\n\n          String csvStr = eid + \",\" + svctier + \",\" + alias + \",\" + organization;\n\n          if (pushExchangeCsv(csvStr, sAMAccountName)) {\n            log.debug(\"CSV transfered in remote host\");\n          } else {\n            throw new Exception(\"CSV transfer failed in remote host. Please check logs for errors.\");\n          }\n        }\n        if(result!=null && result.isCommitted() ){\n          if (accReq.getArgument(\"systemAccountSubType\") != null && \"Shared Mailbox\".equals(accReq.getArgument(\"systemAccountSubType\"))) {\n            Identity serviceIdentity = context.getObjectByName(Identity.class, accReq.getArgument(\"exchangeEID\"));\n            String mailboxOwner = serviceIdentity.getAttribute(\"ManagedBy\");\n            String csvString = (accReq.getAttributeRequest(\"sAMAccountName\").getValue().toString() + \",\" + accReq.getArgument(\"systemAccountName\") + \",\" + mailboxOwner + \",\" + \"\" + \",\" + \"Shared\");\n            pushSharedMailboxCsv(csvString, accReq.getAttributeRequest(\"sAMAccountName\").getValue().toString());\n          }\n        }\n        */\n\n      } else if (AccountRequest.Operation.Delete.equals(accReq.getOperation())) {\n        String nativeIdentity = accReq.getNativeIdentity();\n        if (isADAHyphenAccount(nativeIdentity)) {\n          sendADAHyphenAccountDeletionMail(plan, accReq, plan.getIdentity());\n        }\n        String requestID=(String)plan.get(\"identityRequestId\");\n        log.debug(\"Req ID\"+requestID);\n        if(nativeIdentity!=null && nativeIdentity.startsWith(\"CN=P-\")){\n          try {\n            accountName = \"P-\"+identityName;\n            log.debug(\"Accountname\"+accountName);\n            log.debug(\" AD AfterProvisioning Rule delete if loop \"+accountName);\n            cyberarkNotify(identity, requestID,accountName);\n          } catch (Exception e) {\n            e.printStackTrace();\n          }\n        }\n      }\n\n      // Start A- account vaulting \n      if (isADAHyphenAccount(nativeIdentityName)) {\n        if (AccountRequest.Operation.Create.equals(accReq.getOperation()) && result != null && result.isCommitted()) {\n          log.debug(\" AD AfterProvisioning Rule: A- Vaulting: operation: \"+accReq.getOperation());\n          log.debug(\" AD AfterProvisioning Rule: A- Vaulting: sAMAccountName: \"+sAMAccountName);\n          log.debug(\" AD AfterProvisioning Rule: A- Vaulting: domain: \"+domain);\n          boolean aHyphenSuccess = false;\n          if(StringUtils.containsIgnoreCase(nativeIdentityName , \"swe.com\") && nativeIdentityName.toUpperCase().startsWith(\"CN=A-\")){\n            log.debug(\" AD AfterProvisioning Rule: A- Vaulting: Inside /A- loop\");\n            String identityRequestId = (String) plan.get(\"identityRequestId\");\n            log.debug(\" AD AfterProvisioning Rule: A- Vaulting: identityRequestId: \"+identityRequestId);\n            aHyphenSuccess =  vaultADAffiliatedAccountInCyberArk(\"ADash\", identityName,identityName,null, \"Active Directory\" , identityRequestId  ,sAMAccountName,null);\n            //IAM-191881 deleting Dash CyberArk Vault Account start\n            manageCyberArkVaultAccessDashAccount(sAMAccountName, plan, accReq.getOperation().name());\n            //IAM-191881 deleting Dash CyberArk Vault Account end\n          } else {\n            aHyphenSuccess = sendADAHyphenAccountCreationMail(password, nativeIdentityName, identity, applicationName, plan, sAMAccountName, domain);\n          }\n          log.error(\" AD AfterProvisioning Rule: A- Vaulting: aHyphenSuccess: \"+aHyphenSuccess);\n          \n          if(!aHyphenSuccess) {\n            result.addError(\"Unable to post password for the AD Account: \" +nativeIdentityName);\n          }\n        }\n      }// End A- account vaulting\n\n      // Provisioning Failure Notification\n      if (result != null && result.isFailed()) {\n        log.info(\"Enter  Failure Notification\" );\n        AccountRequest provInfo = (AccountRequest) XMLObjectFactory .getInstance().cloneWithoutId(accReq, context);\n\n        ProvisioningPlan notificationPlan = new ProvisioningPlan();\n        notificationPlan.setNativeIdentity(plan.getNativeIdentity());\n        notificationPlan.setIdentity(identity);\n        notificationPlan.setTargetIntegration(plan.getTargetIntegration());\n        notificationPlan.setArguments(attributes);\n        notificationPlan.add(provInfo);\n        notificationPlan.setResult(provInfo.getResult());\n        sendProvisioningFailureNotification(notificationPlan);\n        log.info(\"Exit  Failure Notification\" );\n      }\n      //code for sending lock level email starts here\n      /*\n      if (plan != null) {\n        String resultStatus = null;\n        List accReqList = plan.getAccountRequests(\"Active Directory\");\n        if (accReqList != null && !accReqList.isEmpty()) {\n          for (ProvisioningPlan.AccountRequest accReq: accReqList) {\n\n            if (accReq.getResult() != null) {\n              resultStatus = accReq.getResult().getStatus();\n            }\n\n            List attrReqList = accReq.getAttributeRequests();\n            if (attrReqList != null && !attrReqList.isEmpty()) {\n              for (ProvisioningPlan.AttributeRequest attrReq: attrReqList) {\n                String attrReqValue = attrReq.getValue().toString();\n                if (attrReqValue != null) {\n                  if ((attrReqValue.contains(\"LockLevel-00\") || attrReqValue.contains(\"LockLevel-Developers\")) \n                    && \"Add\".equalsIgnoreCase(attrReq.getOp().toString()) && resultStatus.equalsIgnoreCase(\"committed\")) {\n                      sendLockLevelEmail(identity);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      */\n      //code for Lock Level email notification ends here\n      log.info(\"Exit rule  AD After Provisioning Rule\");\n    }\n  } catch (Exception e) {\n    log.debug(\"Exception occured due to:\" + e.getMessage());\n    e.printStackTrace();\n  }\n\n  \n  ','AfterProvisioning',' ',NULL,NULL),('a9fe0bbd940617a1819406a56fca004b',1735278292938,1739425296579,NULL,NULL,NULL,'AD Allowed Values Rule','Allowed Values Rules are used by provisioning policies to determine the possible values of the policy fields.\n\n    Note that an Attributes map of arguments from the current WorkflowContext is passed into the Allowed Values Rule. However, the contents of this map are dependent on the use case of the rule.  In the default case, the allowed value list is considered static.  The rule is evaluated when the form is constructed, and the form will retain that value for the life of the work item presenting the form.  In this case, all of the workflow variables are passed to the rule in the Attributes map.  In the \"dynamic\" case, the rule will be evaluated whenever the user interacts with the rule component, thereby allowing it to be sensitive to other fields that have been set in the form.  In the \"dynamic\" case, only the variables that were sent into the work item are passed to the rule in the Attributes map.','beanshell','\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport java.util.ArrayList;\nimport java.util.List;\nimport sailpoint.object.Custom;\nLog log = LogFactory.getLog(\"com..rap.ADAllowedValuesRule\");\nlog.info(\"Enter rule  AD Allowed Values Rule\");\nString APPLICATION_NAME = \"Active Directory\";\nString FIELD_NAME_DOMAIN_NAME =  \"domainName\";\nString FIELD_NAME_ACCOUNT_TYPE =  \"accountType\";\nString FIELD_NAME_USER_TYPE =   \"userType\";\nString FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE =  \"systemAccountSubType\";\nString FIELD_NAME_MAILBOX =  \"mailbox\";\nString FIELD_NAME_EXTERNAL_EMAIL =  \"externalEmail\";\nString FIELD_NAME_SYSTEM_ACCOUNT_NAME =  \"systemAccountName\";\nString FIELD_NAME_SAMACCOUNTNAME =  \"sAMAccountName\";\nString FIELD_NAME_DISTINGUISHED_NAME =  \"distinguishedName\";\nString FIELD_NAME_MEMBER_OF =  \"memberOf\";\nString FIELD_NAME_PASSWORD =  \"password\";\nString FIELD_NAME_USER_PASSWORD =  \"userPassword\";\nString FIELD_NAME_PWD_LAST_SET =  \"pwdLastSet\";\nString FIELD_NAME_FIRST_NAME =  \"givenName\";\nString FIELD_NAME_LAST_NAME =  \"sn\";\nString FIELD_NAME_DESCRIPTION =  \"description\";\nString FIELD_NAME_INITIALS =  \"initials\";\nString FIELD_NAME_DISPLAY_NAME =  \"displayName\";\nString FIELD_NAME_USER_PRINCIPAL_NAME =  \"userPrincipalName\";\nString FIELD_NAME_EXTENSION_ATTRIBUTE_8 =  \"extensionAttribute8\";\nString FIELD_NAME_EXTENSION_ATTRIBUTE_9 =  \"extensionAttribute9\";\nString FIELD_NAME_USER_ACCOUNT_CONTROL =  \"userAccountControl\";\nString FIELD_NAME_EXCHANGE_ALIAS = \"exchangeAlias\";\nString forcedAccountStr = (customForceAccount != void && customForceAccount != null) ? customForceAccount : \"false\";\nString DOMAIN_NAME = (domainName != void && domainName != null) ? domainName : \"\";\nString ACCOUNT_TYPE = (accountType != void && accountType != null) ? accountType : \"\";\nString SYSTEM_ACCOUNT_SUB_TYPE = (systemAccountSubType != void && systemAccountSubType != null) ? systemAccountSubType : \"\";\n  String CUSTOM_NAME_AD = \" AD Provisioning Policy Custom Object\";\nlog.debug(\"Field Name:\"+field.getName());\n  \n	String fieldName = field.getName();\n	String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1); \n	List allowedValues = new ArrayList();\nlog.debug(\"currentField = \" + currentField);\n\n  \nif(FIELD_NAME_DOMAIN_NAME.equals(currentField)){\n  \n  if(forcedAccountStr!=null && forcedAccountStr.equalsIgnoreCase(\"true\") ){\n      allowedValues.add(\"swe\");\n  }else{\n	\n	//check the AccountType attribute of the identity to see if this should be a system account request\n		Custom custom = context.getObjectByName(Custom.class,CUSTOM_NAME_AD);\n              if(custom == null){\n              log.debug(\"AD Custom Object Not Found. Please contact system admin\");\n              return null;\n              }\n              else{\n              List listDomains = custom.get(\"domains\");\n              if(listDomains != null && listDomains.size() > 0){\n              allowedValues.addAll(listDomains);\n              }\n              }\n		field.setHelpKey(\"Please Select the domain to which you want to create the user\");\n}\n}\n  \n  else if(FIELD_NAME_ACCOUNT_TYPE.equals(currentField)){\n	\n	//check the AccountType attribute of the identity to see if this should be a system account request\n	String type = identity.getAttribute(\"AccountType\");\n	if(\"System\".equals(type)){\n		allowedValues.add(\"System\");\n	} else{\n    if(\"swe2\".equalsIgnoreCase(domainName)){\n      		allowedValues.add(\"D-\");\n}\n  else if(\"swe\".equalsIgnoreCase(domainName)|| \"swe\".equalsIgnoreCase(domainName)){\n        allowedValues.add(\"D-\");\n        allowedValues.add(\"A-\");\n        allowedValues.add(\"W-\");\n        allowedValues.add(\"P-\");\n    }else{\n          allowedValues.add(\"User\");\n          allowedValues.add(\"A-\");\n          allowedValues.add(\"W-\");\n          allowedValues.add(\"P-\");\n    }\n		field.setHelpKey(\"If you are not requesting for \'A-\', \'P-\' or \'W-\' account, please select \'User\'. If you are requesting for a Role, then always select \'User\'\");\n	}\n}\nelse if(FIELD_NAME_USER_TYPE.equals(currentField)){\n	if(\"User\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"Bank Central Teller\");\n		allowedValues.add(\"Bank Central Non-Teller\");\n		allowedValues.add(\"Bank South Teller\");\n		allowedValues.add(\"Bank South Non-Teller\");\n		allowedValues.add(\"North East Teller\");\n		allowedValues.add(\"North East Non-Teller\");\n		allowedValues.add(\"Not a Bank User\");\n		allowedValues.add(\"LL15 User\");\n	}\n	else if(\"A-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n	\n	else if(\"W-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n	else if(\"P-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n	else if(\"System\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n  	else if(\"D-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n}\nelse if(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE.equals(currentField)){\n	if(\"User\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n	else if(\"A-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}	\n	else if(\"P-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n	else if(\"W-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n  else if(\"D-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"N/A\");\n	}\n		else if(\"System\".equals(ACCOUNT_TYPE)){\n    if(!DOMAIN_NAME.equalsIgnoreCase(\"swe\")){\n      		allowedValues.add(\"Service\");\n\n    }else{\n		//allowedValues.add(\"Service\");\n		allowedValues.add(\"Test\");\n		allowedValues.add(\"COPP\"); /*Changes for AM-12836 COPP sub Account Type Changes*/\n		allowedValues.add(\"Training\");\n		allowedValues.add(\"Kiosk\");\n      allowedValues.add(\"Shared Mailbox\");\n    }\n	}\n}\nelse if(FIELD_NAME_MAILBOX.equals(currentField)){\n	if(\"User\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"Yes\");\n		allowedValues.add(\"No\");\n	}\n	else if(\"A-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"P-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"W-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"System\".equals(ACCOUNT_TYPE)){\n	  	allowedValues.add(\"Yes\");\n		allowedValues.add(\"No\");\n	}\n  else if(\"D-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n}\nelse if(FIELD_NAME_EXTERNAL_EMAIL.equals(currentField)){\n	if(\"User\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"Yes\");\n		allowedValues.add(\"No\");\n	}\n	else if(\"A-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"P-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"W-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n	else if(\"System\".equals(ACCOUNT_TYPE)){\n	  	allowedValues.add(\"Yes\");\n		allowedValues.add(\"No\");\n	}\n  else if(\"D-\".equals(ACCOUNT_TYPE)){\n		allowedValues.add(\"No\");\n	}\n}\n  else{\n	log.error(\"Unsupported Field Name \" + currentField);\n	log.info(\"Exit rule  AD Allowed Values Rule\");\n	return null;\n}\nlog.info(\"Exit rule  AD Allowed Values Rule\");\nreturn allowedValues;\n  ','AllowedValues',' ',NULL,'Object'),('a9fe0bbd940617a1819406a58e04004d',1735278300676,NULL,NULL,NULL,NULL,'AD Password Generation Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a58f3d004e',1735278300989,NULL,NULL,NULL,NULL,'Shared mailbox account name generation rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a59057004f',1735278301272,1739425297706,NULL,NULL,NULL,'AD Field Value Rule','This rule can be used to generate a field value (eg - an account name) using data from the given Identity. If this rule is run in the context of a workflow step then the arguments passed into the step will also be available. Also, any field values that have been processed so far from the policy related to the Application/Role will be available.','beanshell','\n\n  import java.text.SimpleDateFormat;\n  import java.util.Date;\n  import sailpoint.object.*;\n  import sailpoint.object.ExpansionItem;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.object.ProvisioningPlan.Operation;\n  import java.util.Map;\n  import java.util.HashMap;\n\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  Log log = LogFactory.getLog(\"com..rap.ADFieldValueRule\");\n  log.info(\"Enter rule  AD Field Value Rule\");\n\n  String CUSTOM_OBJECT_NAME = \" AD Provisioning Policy Custom Object\";\n  String APPLICATION_NAME = \"Active Directory\";\n  String FIELD_NAME_FORCEDSACCOUNT = \"customForceAccount\";\n  String FIELD_NAME_DOMAIN_NAME =  \"domainName\";\n  String FIELD_NAME_ACCOUNT_TYPE = \"accountType\";\n  String FIELD_NAME_USER_TYPE =  \"userType\";\n  String FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE = \"systemAccountSubType\";\n  String FIELD_NAME_MAILBOX = \"mailbox\";\n  String FIELD_NAME_EXTERNAL_EMAIL = \"externalEmail\";\n  String FIELD_NAME_SYSTEM_ACCOUNT_NAME = \"systemAccountName\";\n  String FIELD_NAME_SAMACCOUNTNAME = \"sAMAccountName\";\n  String FIELD_NAME_DISTINGUISHED_NAME = \"distinguishedName\";\n  String FIELD_NAME_MEMBER_OF = \"memberOf\";\n  String FIELD_NAME_PASSWORD = \"password\";\n  String FIELD_NAME_USER_PASSWORD = \"userPassword\";\n  String FIELD_NAME_PWD_LAST_SET = \"pwdLastSet\";\n  String FIELD_NAME_FIRST_NAME = \"givenName\";\n  String FIELD_NAME_LAST_NAME = \"sn\";\n  String FIELD_NAME_DESCRIPTION = \"description\";\n  String FIELD_NAME_INITIALS = \"initials\";\n  String FIELD_NAME_DISPLAY_NAME = \"displayName\";\n  String FIELD_NAME_USER_PRINCIPAL_NAME = \"userPrincipalName\";\n  String FIELD_NAME_EXTENSION_ATTRIBUTE_8 = \"extensionAttribute8\";\n  String FIELD_NAME_EXTENSION_ATTRIBUTE_9 = \"extensionAttribute9\";\n  String FIELD_NAME_USER_ACCOUNT_CONTROL = \"userAccountControl\";\n  String FIELD_NAME_EXCHANGE_EID = \"exchangeEID\";\n  String FIELD_NAME_EXCHANGE_ALIAS = \"exchangeAlias\";\n  String FIELD_NAME_AC_NEWPARENT = \"AC_NewParent\";\n  String FIELD_NAME_EMAIL=\"mail\";\n  String FIELD_NAME_EXTENSION_ATTRIBUTE_5=\"extensionAttribute5\";\n  String FIELD_NAME_PHYSICALDELIVERY_OFFICENAME=\"physicalDeliveryOfficeName\";\n  String FIELD_NAME_PROXYADDRESSES=\"proxyAddresses\";\n  String FIELD_NAME_SOURCEASV = \"sourceASV\";\n  String DOMAIN_NAME = (domainName != void && domainName != null) ? domainName : \"\";\n  String ACCOUNT_TYPE = (accountType != void && accountType != null) ? accountType : \"\";\n  String USER_TYPE = (userType != void && userType != null) ? userType : \"\";\n  String SYSTEM_ACCOUNT_SUB_TYPE = (systemAccountSubType != void && systemAccountSubType != null) ? systemAccountSubType : \"\";\n  String SYSTEM_ACCOUNT_NAME = (systemAccountName != void && systemAccountName != null) ? systemAccountName : \"\";\n  String EXTERNAL_EMAIL = (externalEmail != void && externalEmail != null) ? externalEmail : \"\";\n  String FIRSTNAME = identity.getFirstname();\n  String LASTNAME = identity.getLastname();\n  String MAILBOX = (mailbox != void && mailbox != null) ? mailbox : \"\";\n  String SAMACCOUNTNAME = (sAMAccountName != void && sAMAccountName != null) ? sAMAccountName : \"\";\n  String DISPLAYNAME = (displayName != void && displayName != null) ? displayName : \"\";\n 	String SOURCE_ASV = \"\";\n\n  /* \n * Get expansion items off the provisioning project and set accountType, \n * userType, mailbox, and externalEmail if they are already set.\n * This is for provisioning policies that are set from roles, which we \n * need to make available to this rule.\n */\n  List expansionItems = null;\n  if(project != void && project != null){\n    log.debug(\"project is initialized\");\n    expansionItems = project.getExpansionItems();\n  } else {\n    log.debug(\"project is not initialized\");\n  }\n  if(expansionItems == null){\n    expansionItems = new ArrayList();\n  }\n  for(ExpansionItem expansionItem : expansionItems){\n    Object app = expansionItem.getApplication();\n    Object att = expansionItem.getName();\n    Object value = expansionItem.getValue();\n\n    if(APPLICATION_NAME.equals(app)){\n      if(FIELD_NAME_DOMAIN_NAME.equals(att)){\n        DOMAIN_NAME = value;\n        log.debug(\"Found expansion item.  Setting DOMAIN_NAME to \" + value);\n      }\n      else if(FIELD_NAME_ACCOUNT_TYPE.equals(att)){\n        ACCOUNT_TYPE = value;\n        log.debug(\"Found expansion item.  Setting ACCOUNT_TYPE to \" + value);\n      }\n      else if(FIELD_NAME_USER_TYPE.equals(att)){\n        USER_TYPE = value;\n        log.debug(\"Found expansion item.  Setting USER_TYPE to \" + value);\n      }\n      else if(FIELD_NAME_MAILBOX.equals(att)){\n        MAILBOX = value;\n        log.debug(\"Found expansion item.  Setting MAILBOX to \" + value);\n      }\n      else if(FIELD_NAME_EXTERNAL_EMAIL.equals(att)){\n        EXTERNAL_EMAIL = value;\n        log.debug(\"Found expansion item.  Setting EXTERNAL_EMAIL to \" + value);\n      }\n      else if(FIELD_NAME_DISPLAY_NAME.equals(att)){\n        DISPLAYNAME = value;\n        //log.debug(\"Found expansion item.  Setting DISPLAYNAME to \" + value);  \n        log.debug(\"FIELD_NAME_DISPLAY_NAME DISPLAYNAME\"+DISPLAYNAME);\n      }else if(FIELD_NAME_SAMACCOUNTNAME.equals(att)){\n        SAMACCOUNTNAME = value;\n        //log.debug(\"Found expansion item.  Setting DISPLAYNAME to \" + value);  \n        log.debug(\"FIELD_NAME_SAMACCOUNTNAME SAMACCOUNTNAME\"+SAMACCOUNTNAME);\n      }\n    }\n  }\n\n//Code added to read field values from attributes ----\nif(null != accountRequest && accountRequest instanceof AccountRequest)\n{\n	if(null != accountRequest.getArgument(\"RequestType\") && (\"SharedMailboxRequest\".equals(accountRequest.getArgument(\"RequestType\")) || \"DQA\".equals(accountRequest.getArgument(\"RequestType\")) || \"swe\".equals(accountRequest.getArgument(\"RequestType\"))))\n	{\n		//IAM-115398 - Provisioning Description for secret Management Request.\n   		if(field.getName().equalsIgnoreCase(FIELD_NAME_DESCRIPTION) && null != accountRequest.getArgument(FIELD_NAME_DESCRIPTION) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_DESCRIPTION)))\n		{\n			String description = accountRequest.getArgument(FIELD_NAME_DESCRIPTION);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_DESCRIPTION + \" : \" + description);\n			return description;\n		}	  \n	        //The following request is a sharemailbox request, it has extra attributes in the accountRequest.\n		//check for null values just in case this is modified in the future.\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_DOMAIN_NAME) && null != accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME)))\n		{\n			DOMAIN_NAME = accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_DOMAIN_NAME + \" : \" + DOMAIN_NAME);\n			return DOMAIN_NAME;\n		}\n		else if (null != accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME)))\n		{\n			DOMAIN_NAME = accountRequest.getArgument(FIELD_NAME_DOMAIN_NAME);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_ACCOUNT_TYPE) && null != accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE)))\n		{\n			ACCOUNT_TYPE = accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_ACCOUNT_TYPE + \" : \" + ACCOUNT_TYPE);\n			return ACCOUNT_TYPE;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE)))\n		{\n			ACCOUNT_TYPE = accountRequest.getArgument(FIELD_NAME_ACCOUNT_TYPE);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_USER_TYPE) && null != accountRequest.getArgument(FIELD_NAME_USER_TYPE) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_USER_TYPE)))\n		{\n			USER_TYPE = accountRequest.getArgument(FIELD_NAME_USER_TYPE);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_USER_TYPE + \" : \" + USER_TYPE);\n			return USER_TYPE;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_USER_TYPE) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_USER_TYPE)))\n		{\n			USER_TYPE = accountRequest.getArgument(FIELD_NAME_USER_TYPE);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_MAILBOX)  && null != accountRequest.getArgument(FIELD_NAME_MAILBOX) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_MAILBOX)))\n		{\n			MAILBOX = accountRequest.getArgument(FIELD_NAME_MAILBOX);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_MAILBOX + \" : \" + MAILBOX);\n			return MAILBOX;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_MAILBOX) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_MAILBOX)))\n		{\n			MAILBOX = accountRequest.getArgument(FIELD_NAME_MAILBOX);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_EXTERNAL_EMAIL)  && null != accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL)))\n		{\n			EXTERNAL_EMAIL = accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_EXTERNAL_EMAIL + \" : \" + EXTERNAL_EMAIL);\n			return EXTERNAL_EMAIL;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL)))\n		{\n			EXTERNAL_EMAIL = accountRequest.getArgument(FIELD_NAME_EXTERNAL_EMAIL);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_DISPLAY_NAME) && null != accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME)))\n		{\n			DISPLAYNAME = accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_DISPLAY_NAME + \" : \" + DISPLAYNAME);\n			return DISPLAYNAME;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME)))\n		{\n			DISPLAYNAME = accountRequest.getArgument(FIELD_NAME_DISPLAY_NAME);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_SAMACCOUNTNAME) && null != accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME)))\n		{\n			SAMACCOUNTNAME = accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_SAMACCOUNTNAME + \" : \" + SAMACCOUNTNAME);\n			return SAMACCOUNTNAME;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME)))\n		{\n			SAMACCOUNTNAME = accountRequest.getArgument(FIELD_NAME_SAMACCOUNTNAME);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE) && null != accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE)))\n		{\n			SYSTEM_ACCOUNT_SUB_TYPE = accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE + \" : \" + SYSTEM_ACCOUNT_SUB_TYPE);\n			return SYSTEM_ACCOUNT_SUB_TYPE;\n		}\n		else if(null != accountRequest.getArgument(SYSTEM_ACCOUNT_SUB_TYPE) && !\"\".equals(accountRequest.getArgument(SYSTEM_ACCOUNT_SUB_TYPE)))\n		{\n			SYSTEM_ACCOUNT_SUB_TYPE = accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE);\n		}\n		\n		if(field.getName().equalsIgnoreCase(FIELD_NAME_SYSTEM_ACCOUNT_NAME) && null != accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME)))\n		{\n			SYSTEM_ACCOUNT_NAME = accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_SYSTEM_ACCOUNT_NAME + \" : \" + SYSTEM_ACCOUNT_NAME);\n			return SYSTEM_ACCOUNT_NAME;\n		}\n		else if(null != accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME)))\n		{\n			SYSTEM_ACCOUNT_NAME = accountRequest.getArgument(FIELD_NAME_SYSTEM_ACCOUNT_NAME);\n		}\n	  //141505- mamatha code\n	  if(field.getName().equalsIgnoreCase(FIELD_NAME_SOURCEASV) && null != accountRequest.getArgument(FIELD_NAME_SOURCEASV) && !\"\".equals(accountRequest.getArgument(FIELD_NAME_SOURCEASV)))\n		{\n			SOURCE_ASV = accountRequest.getArgument(FIELD_NAME_SOURCEASV);\n			log.debug(\"Set value from attr request: \" + FIELD_NAME_SOURCEASV + \" : \" + SOURCE_ASV);\n			return SOURCE_ASV;\n		}\n	}\n}\n// end of field attribute value code.  \n\n  String fieldName = field.getName();\n  String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\n  Custom adCustomObject = context.getObjectByName(Custom.class, CUSTOM_OBJECT_NAME);\n  Map accountTypes= new HashMap();\n   Map customDomainMap=new HashMap();\n   Map accountTypeMap=new HashMap();\nlog.debug(\"currentField = \" + currentField);\n\n  if(adCustomObject == null){\n    Error e = new Error(\"unable to retrieve custom object: \" + CUSTOM_OBJECT_NAME);\n    log.debug(e.getMessage());\n    throw e;\n  }\n if(DOMAIN_NAME!=null &&  !DOMAIN_NAME.equals(\"\") &&   adCustomObject.get(DOMAIN_NAME)!=null){\n  log.debug(\"DOMAIN_NAME inside \"+DOMAIN_NAME);\n    customDomainMap= adCustomObject.get(DOMAIN_NAME);\n    DOMAIN = customDomainMap.get(\"DOMAIN_NAME\");\n    DC = customDomainMap.get(\"DC\");\n  }\n\n  /* JC - Added to allow for new UPN Domain suffix\nto support the migration of new accounts to Office 365 Cloud*/\n  UPNDOMAIN = \"login.capone.com\";\n\n  if(currentField.contains(FIELD_NAME_USER_TYPE)){\n    String userType = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      userType = \"Not a Bank User\";\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      userType = \"N/A\";\n    }\n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      userType = \"N/A\";\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      userType = \"N/A\";\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      userType = \"N/A\";\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      userType = \"N/A\";\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_USER_TYPE + \" = \" + userType);\n    return userType;\n  }\n  else if(currentField.contains(FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE)){\n    String systemAccountSubType = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"N/A\";\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"N/A\";\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"N/A\";\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"N/A\";\n    }else if(\"D-\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"N/A\";\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      systemAccountSubType = \"\";\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_SYSTEM_ACCOUNT_SUB_TYPE + \" = \" + systemAccountSubType);\n    return systemAccountSubType;\n  }\n  else if(currentField.contains(FIELD_NAME_MAILBOX)){\n    String mailbox = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      mailbox = \"Yes\";\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      mailbox = \"No\";\n    } \n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      mailbox = \"No\";\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      mailbox = \"No\";\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      mailbox = \"No\";\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n           if(\"Shared Mailbox\".equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n              mailbox = \"Yes\";\n      }else{\n             mailbox = \"No\";\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_MAILBOX + \" = \" + mailbox);\n    return mailbox;\n  }\n  else if(currentField.contains(FIELD_NAME_EXTERNAL_EMAIL)){\n    String externalEmail = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      if(\"Bank Central Teller\".equals(USER_TYPE)){\n        externalEmail = \"No\";\n      }\n      else if(\"Bank Central Non-Teller\".equals(USER_TYPE)){\n        externalEmail = \"Yes\";\n      }\n      else if(\"Bank South Teller\".equals(USER_TYPE)){\n        externalEmail = \"No\";\n      }\n      else if(\"Bank South Non-Teller\".equals(USER_TYPE)){\n        externalEmail = \"Yes\";\n      }\n      else if(\"North East Teller\".equals(USER_TYPE)){\n        externalEmail = \"No\";\n      }\n      else if(\"North East Non-Teller\".equals(USER_TYPE)){\n        externalEmail = \"Yes\";\n      }\n      else{ //\"Not a Bank User\".equals(USER_TYPE) and any others\n        externalEmail = \"Yes\";\n      }\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      externalEmail = \"No\";\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      externalEmail = \"No\";\n    }\n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      externalEmail = \"No\";\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      externalEmail = \"No\";\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      externalEmail = \"No\";\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_EXTERNAL_EMAIL + \" = \" + externalEmail);\n    return externalEmail;\n  }\n  else if(currentField.contains(FIELD_NAME_SYSTEM_ACCOUNT_NAME)){\n    String systemAccountName = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      systemAccountName = \"N/A\";\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n\n      systemAccountName = \"N/A\";\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      systemAccountName = \"N/A\";\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      systemAccountName = \"N/A\";\n    }else if(\"D-\".equals(ACCOUNT_TYPE)){\n      systemAccountName = \"N/A\";\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      if(\"Shared Mailbox\".equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n        field.setHidden(false);\n        if(field.getValue()==null){\n\n          systemAccountName = generateAccountName();\n        }\n        else if(!systemAccountName.equals(field.getValue())){\n\n          systemAccountName = generateAccountName();\n\n        }	\n\n        else{\n\n          systemAccountName = field.getValue();\n        }\n\n        field.setReadOnly(true);\n        field.setPostBack(true);\n      }\n\n      //kiosk starts\n      else if(\"Kiosk\".equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n\n        if(field.getValue()==null) {\n\n          systemAccountName = generateAccountNameForKiosk();\n\n        }\n\n        else if(!systemAccountName.equals(field.getValue())){\n\n          systemAccountName = generateAccountNameForKiosk();\n\n\n        }	\n\n        else{\n\n          systemAccountName = field.getValue();\n        }\n\n        field.setReadOnly(true);\n        field.setPostBack(true);\n\n      }\n\n      //kiosk ends\n\n\n\n      else{\n        systemAccountName = \"\";\n        field.setReadOnly(false);\n      }\n    }\n    log.debug(\"currentField: \" + FIELD_NAME_SYSTEM_ACCOUNT_NAME + \" = \" + systemAccountName);\n\n    return systemAccountName;\n  }\n  else if(currentField.contains(FIELD_NAME_SAMACCOUNTNAME)){\n    String sAMAccountName = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = identity.getName();\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = \"A-\" + identity.getName();\n\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = \"P-\" + identity.getName();\n\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = \"W-\" + identity.getName();\n    }\n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = \"D-\" + identity.getName();\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      sAMAccountName = SYSTEM_ACCOUNT_NAME;\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_SAMACCOUNTNAME + \" = \" + sAMAccountName);\n    return sAMAccountName;\n  }\n  else if(currentField.contains(FIELD_NAME_DISTINGUISHED_NAME)){\n    String cn = (sAMAccountName != void && sAMAccountName != null) ? sAMAccountName : \"\";\n    String ou = \"\";\n    String dn = \"\";\n Map accountTypeMap =null;\n    if(customDomainMap!=null &&  customDomainMap.get(\"accountType\")!=null){\n    Map accountTypes = customDomainMap.get(\"accountType\");\n    accountTypeMap = accountTypes.get(ACCOUNT_TYPE);\n    }\n\n   log.debug(\"accountTypeMap \"+accountTypeMap);\n\n    if(accountTypeMap != null){\n      if(\"User\".equals(ACCOUNT_TYPE)){\n        cn = SAMACCOUNTNAME;\n\n        Map userTypes = accountTypeMap.get(\"userType\");\n        Map userTypeMap = userTypes.get(USER_TYPE);\n        if(userTypeMap != null){\n          ou = userTypeMap.get(\"OU\");\n        } else{\n          log.debug(\"unsupported User Type \" + USER_TYPE);\n        }\n      }\n      else if(\"A-\".equals(ACCOUNT_TYPE)){\n\n        ou = accountTypeMap.get(\"OU\");\n      }\n      else if(\"P-\".equals(ACCOUNT_TYPE)){\n\n        ou = accountTypeMap.get(\"OU\");\n      }\n      else if(\"W-\".equals(ACCOUNT_TYPE)){\n        ou = accountTypeMap.get(\"OU\");\n      }\n      else if(\"D-\".equals(ACCOUNT_TYPE)){\n        ou = accountTypeMap.get(\"OU\");\n      }\n      else if(\"System\".equals(ACCOUNT_TYPE)){\n        Map systemAccountNames = accountTypeMap.get(\"systemAccountSubType\");\n        Map systemAccountSubTypeMap = systemAccountNames.get(SYSTEM_ACCOUNT_SUB_TYPE);\n        if(systemAccountSubTypeMap != null){\n          ou = systemAccountSubTypeMap.get(\"OU\");\n        } else {\n          log.debug(\"unsupported System Account Sub Type \" + SYSTEM_ACCOUNT_SUB_TYPE);\n        }\n      }\n    } else {\n      log.debug(\"unsupported Account Type \" + ACCOUNT_TYPE);\n    }\n\n    dn = \"CN=\" + cn + \",\" + ou + \",\" + DC;\n\n  log.debug(\"currentField: \" + FIELD_NAME_DISTINGUISHED_NAME + \" = \" + dn);\n    return dn;\n  }\n  else if(currentField.contains(FIELD_NAME_MEMBER_OF)){\n\n    List memberOf = new ArrayList();\n\n    Map accountTypeMap =null;\n    if(customDomainMap!=null &&  customDomainMap.get(\"accountType\")!=null){\n    Map accountTypes = customDomainMap.get(\"accountType\");\n    accountTypeMap = accountTypes.get(ACCOUNT_TYPE);\n    }\n    if(accountTypeMap != null){\n      if(\"User\".equals(ACCOUNT_TYPE)){\n\n        Map userTypes = accountTypeMap.get(\"userType\");\n        Map userTypeMap = userTypes.get(USER_TYPE);\n        if(userTypeMap != null){\n          memberOf = userTypeMap.get(\"memberOf\");\n        } else{\n          log.debug(\"unsupported User Type \" + USER_TYPE);\n        }\n      }\n      else if(\"A-\".equals(ACCOUNT_TYPE)){\n        memberOf = accountTypeMap.get(\"memberOf\");\n        log.debug(\"inside A- map memberOf = *** \" +memberOf);\n\n      }	else if(\"D-\".equals(ACCOUNT_TYPE)){\n        memberOf = accountTypeMap.get(\"memberOf\");\n        log.debug(\"inside D- map memberOf = *** \" +memberOf);\n\n      }\n      else if(\"P-\".equals(ACCOUNT_TYPE)){\n        memberOf = accountTypeMap.get(\"memberOf\");\n        log.debug(\"inside P- map memberOf = *** \" +memberOf);\n      }\n      else if(\"W-\".equals(ACCOUNT_TYPE)){\n        memberOf = accountTypeMap.get(\"memberOf\");\n        log.debug(\"inside W- map memberOf = *** \" +memberOf);\n      }\n      else if(\"System\".equals(ACCOUNT_TYPE)){\n        Map systemAccountNames = accountTypeMap.get(\"systemAccountSubType\");\n        Map systemAccountSubTypeMap = systemAccountNames.get(SYSTEM_ACCOUNT_SUB_TYPE);\n        if(systemAccountSubTypeMap != null){\n          memberOf = systemAccountSubTypeMap.get(\"memberOf\");\n        } else {\n          log.debug(\"unsupported System Account Sub Type \" + SYSTEM_ACCOUNT_SUB_TYPE);\n        }\n      }\n    } else {\n      log.debug(\"unsupported Account Type \" + ACCOUNT_TYPE);\n    }\n\n    if(memberOf == null){\n      memberOf = new ArrayList();\n    }\n\n    //IMPORTANT: make sure the list we are working with is only a copy of the list from the custom object\n    if(memberOf != null){\n      memberOf = new ArrayList(memberOf);		\n    }\n\n    //Check externalEmail\n    if(\"No\".equals(EXTERNAL_EMAIL) && customDomainMap.get(\"externalEmailGroup\")!=null){\n      memberOf.add(customDomainMap.get(\"externalEmailGroup\"));\n    }\n\n    //add DC to all the groups\n    List tmpMemberOf = memberOf;\n    memberOf = new ArrayList();\n    for(String group : tmpMemberOf){\n      memberOf.add(group + \",\" + DC);\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_MEMBER_OF + \" = \" + memberOf);\n    return memberOf;\n  }\n  else if(currentField.contains(FIELD_NAME_USER_PASSWORD)){\n    String encryptedPassword = password != null ? context.encrypt(password) : null;\n    log.debug(\"currentField: \" + FIELD_NAME_USER_PASSWORD + encryptedPassword);\n    return password;\n  }\n  else if(currentField.contains(FIELD_NAME_PASSWORD)){\n    //password = generateADPassword(ACCOUNT_TYPE);\n    password = generateADPassword(ACCOUNT_TYPE,identity);\n    return password;\n  }\n  else if(currentField.contains(FIELD_NAME_FIRST_NAME)){\n    String firstName = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      firstName = identity.getFirstname();\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      firstName = identity.getFirstname();\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      firstName = identity.getFirstname();\n    }\n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      firstName = identity.getFirstname();\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      firstName = identity.getFirstname();\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      firstName = DISPLAYNAME;\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_FIRST_NAME + \" = \" + firstName);\n    return firstName;\n  }\n  else if(currentField.equalsIgnoreCase(FIELD_NAME_EMAIL)){\n    String email = \"\";\n\n\n    if(\"User\".equals(ACCOUNT_TYPE) && \"Yes\".equalsIgnoreCase(MAILBOX)){\n\n      Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableEmail\");\n      Map args = new HashMap();\n      args.put(\"eid\",identity.getName());\n      args.put(\"firstname\",identity.getFirstname());\n      args.put(\"lastname\",identity.getLastname());\n\n\n      if(myRule!=null)\n      {\n        email = (String)context.runRule(myRule,args);\n      }\n\n    } else if(\"System\".equals(ACCOUNT_TYPE) && \"Yes\".equalsIgnoreCase(MAILBOX)){\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n\n        Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableSharedEmail\");\n        Map args = new HashMap();\n        args.put(\"displayname\",DISPLAYNAME);\n        if(DISPLAYNAME != null)\n        {\n\n\n          if(myRule!=null)\n          {\n            email = (String)context.runRule(myRule,args);\n          }\n\n        }\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n\n        Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableSharedEmail\");\n        Map args = new HashMap();\n        args.put(\"displayname\",DISPLAYNAME);\n        if(DISPLAYNAME != null)\n        {\n\n\n          if(myRule!=null)\n          {\n            email = (String)context.runRule(myRule,args);\n          }\n\n        }\n      }\n    }\n    log.debug(\"currentField: \" + FIELD_NAME_EMAIL + \" = \" + email);\n    return email;\n\n  }\n  else if(currentField.contains(FIELD_NAME_EXTENSION_ATTRIBUTE_5)){\n    String username = identity.getAttribute(\"ManagedBy\");\n    String extensionAttribute5 = \"\";\n\n    if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"System\".equals(ACCOUNT_TYPE)){\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && username != null){\n        extensionAttribute5=\"google\";\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && username != null){\n        extensionAttribute5=\"google\";\n      }\n    }\n    //modified to add google in user mail box also in addition to shared mail box\n    if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"User\".equals(ACCOUNT_TYPE)){\n      extensionAttribute5=\"google\";\n    }\n    //end modified to add google for user mailbox\n    log.debug(\"currentField: \" + FIELD_NAME_EXTENSION_ATTRIBUTE_5 + \" = \" + extensionAttribute5);\n    return extensionAttribute5;\n  }\n  else if(currentField.contains(FIELD_NAME_PHYSICALDELIVERY_OFFICENAME)){\n    String username = identity.getAttribute(\"ManagedBy\");\n    String physicalDeliveryOfficeName = \"\";\n\n    if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"System\".equals(ACCOUNT_TYPE)){\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && username != null){\n        physicalDeliveryOfficeName=username;\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && username != null){\n        physicalDeliveryOfficeName=username;\n      }\n    }\n    log.debug(\"currentField: \" + FIELD_NAME_PHYSICALDELIVERY_OFFICENAME + \" = \" + physicalDeliveryOfficeName);\n    return physicalDeliveryOfficeName;\n  }\n  else if(currentField.contains(FIELD_NAME_PROXYADDRESSES))\n  {\n\n    log.debug(\"Inside the proxy address field value**\");\n\n    String bigSMTP = \"\";\n    String small_smtp = \"\";\n    String extended_smtp = \"\";\n    List proxyAddressesList = new ArrayList();\n\n    if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"User\".equals(ACCOUNT_TYPE))\n    {\n\n      log.debug(\"Inside the USER Account type and mailbox is YES\");\n      Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableEmail\");\n      Map args = new HashMap();\n      args.put(\"eid\",identity.getName());\n      args.put(\"firstname\",identity.getFirstname());\n      args.put(\"lastname\",identity.getLastname());\n\n\n      if(myRule!=null)\n      {\n        bigSMTP = (String)context.runRule(myRule,args);\n      }\n\n\n      small_smtp= SAMACCOUNTNAME+\"@capitalone.com\";\n\n      extended_smtp = SAMACCOUNTNAME+\"@login.capone.com\";\n\n    } \n    else if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"System\".equals(ACCOUNT_TYPE))\n    {\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && SAMACCOUNTNAME != null)\n      {\n\n        log.debug(\"Inside the System Account type and mailbox is YES\");\n        Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableSharedEmail\");\n        Map args = new HashMap();\n        args.put(\"displayname\",DISPLAYNAME);\n        if(DISPLAYNAME != null)\n        {\n          if(myRule!=null)\n          {\n            bigSMTP = (String)context.runRule(myRule,args);\n          }\n        }\n        small_smtp= SAMACCOUNTNAME+\"@capitalone.com\";\n\n\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && SAMACCOUNTNAME != null)\n      {\n\n        log.debug(\"Inside the System Account type and mailbox is YES\");\n        Rule myRule = context.getObjectByName(Rule.class,\" Rule AD LDAP GetAvailableSharedEmail\");\n        Map args = new HashMap();\n        args.put(\"displayname\",DISPLAYNAME);\n        if(DISPLAYNAME != null)\n        {\n          if(myRule!=null)\n          {\n            bigSMTP = (String)context.runRule(myRule,args);\n          }\n        }\n        small_smtp= SAMACCOUNTNAME+\"@capitalone.com\";\n        extended_smtp = SAMACCOUNTNAME+\"@login.capone.com\";\n\n\n      }\n    }\n    log.debug(\"currentField: \" + FIELD_NAME_PROXYADDRESSES + \" = \" + proxyAddresses);\n    proxyAddressesList.add(\"SMTP:\"+bigSMTP);\n    proxyAddressesList.add(\"smtp:\"+small_smtp);\n    proxyAddressesList.add(\"smtp:\"+extended_smtp);\n    log.debug(\"proxyAddressesList: \"+proxyAddressesList);\n    return proxyAddressesList;\n  }\n\n  else if(currentField.contains(FIELD_NAME_LAST_NAME)){\n    String lastName = \"\";\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      lastName = identity.getLastname();\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n\n      lastName = identity.getLastname();\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      lastName = identity.getLastname();\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      lastName = identity.getLastname();\n    }else if(\"D-\".equals(ACCOUNT_TYPE)){\n      lastName = identity.getLastname();\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      if( (\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n        lastName = \"(Shared)\";\n      }\n      if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n        lastName = \"(Kiosk)\";\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_LAST_NAME + \" = \" + sn);\n    return lastName;\n  }\n  else if(currentField.contains(FIELD_NAME_DESCRIPTION)){\n    String description = \"\";\n    Date date = new Date();\n    date.setTime(System.currentTimeMillis());\n    String dateString = new SimpleDateFormat(\"MM/dd/yy\").format(date);\n\n    description = \"Created \" + dateString + \" by All Access\";\n\n    if(null != project.getQuestionHistory())\n    {\n      for(Question provQuestion : project.getQuestionHistory()) \n      {\n         if( null!= provQuestion.getAttributeName() && FIELD_NAME_DESCRIPTION.equals(provQuestion.getAttributeName()))\n         {\n         	  if(null != provQuestion.getField() && null != provQuestion.getField().getValue())\n            {\n              description = (String)provQuestion.getField().getValue();\n            }\n         }\n      }\n    }\n    \n    if(null != DOMAIN_NAME && DOMAIN_NAME.isEmpty())\n    {\n      description = \"\";\n    }\n    \n    if(field.getValue() != null)\n    {\n    	description = field.getValue();\n    }  \n	  \n    log.debug(\"currentField: \" + FIELD_NAME_DESCRIPTION + \" = \" + description);\n    return description;\n  }\n  else if(currentField.contains(FIELD_NAME_INITIALS)){\n    String initials = identity.getAttribute(\"MiddleName\");\n\n    //there is a 6 character limit constraint on Active Directory for intials attribute.  Because of this we have to strip the value down to 6 characters\n    if(initials instanceof String){\n      int endIndex = initials.length();\n      if(endIndex > 6){\n        initials = initials.substring(0,6);\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_INITIALS + \" = \" + initials);\n    return initials;\n  }\n  else if(currentField.contains(FIELD_NAME_DISPLAY_NAME)){\n\n    String employeeType = (String)identity.getAttribute(\"EmployeeType\");\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      displayName = LASTNAME + \", \" + FIRSTNAME;\n      if(\"Not a Bank User\".equals(USER_TYPE) || \"LL15 User\".equals(USER_TYPE)  ){\n        if(\"C\".equals(employeeType)){\n          displayName += \" (CONT)\";\n        }\n      }\n      else{\n        displayName += \" (BANK)\";\n      }\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n      displayName = LASTNAME + \", \" + FIRSTNAME;\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      displayName = LASTNAME + \", \" + FIRSTNAME;\n    }\n    else if(\"D-\".equals(ACCOUNT_TYPE)){\n      displayName = LASTNAME + \", \" + FIRSTNAME;\n    }\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      displayName = LASTNAME + \", \" + FIRSTNAME;\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n\n        displayName = \"\";\n\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n\n        displayName = \"\";\n\n      }\n      else{\n\n        displayName = SAMACCOUNTNAME;\n\n      }\n\n    }\n    log.debug(\"currentField: \" + FIELD_NAME_DISPLAY_NAME + \" = \" + displayName);\n    return displayName;\n  }\n  /*JC - Changed the domain suffix using the newly dfined UPN domain suffix to allow\nnew uers to be configued corrctly with new Office 356 account suffix\n*/\n  else if(currentField.contains(FIELD_NAME_USER_PRINCIPAL_NAME)){\n    String userPrincipalName = SAMACCOUNTNAME + \"@\" + UPNDOMAIN;\n\n    log.debug(\"currentField: \" + FIELD_NAME_USER_PRINCIPAL_NAME + \" = \" + userPrincipalName);\n    return userPrincipalName;\n  }\n  else if(currentField.contains(FIELD_NAME_EXTENSION_ATTRIBUTE_8)){\n    if(!(DOMAIN_NAME.equalsIgnoreCase(\"swe\") || DOMAIN_NAME.equalsIgnoreCase(\"swe\"))){\n    String username = identity.getName();\n    String ManagedBy=identity.getAttribute(\"ManagedBy\");\n    String extensionAttribute8 = \"\";\n\n    if(\"No\".equals(MAILBOX)){\n      if(\"User\".equals(ACCOUNT_TYPE)){\n        extensionAttribute8 = SAMACCOUNTNAME;\n      }\n      else if(\"A-\".equals(ACCOUNT_TYPE)){\n\n        extensionAttribute8 = SAMACCOUNTNAME;\n      }\n      else if(\"P-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute8 = SAMACCOUNTNAME;\n      }\n      else if(\"W-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute8 = SAMACCOUNTNAME;\n      }	else if(\"D-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute8 = SAMACCOUNTNAME;\n      }\n      else if(\"System\".equals(ACCOUNT_TYPE)){\n      	 // extensionAttribute8 = \"S-\" + username;\n	 //setting extensionAttribute8 to S-EID instead of S-serviceIdentityName\n	  extensionAttribute8 = \"S-\" + ManagedBy;\n      }\n    } else if(\"Yes\".equalsIgnoreCase(MAILBOX) && \"System\".equals(ACCOUNT_TYPE)){\n      if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && ManagedBy != null){\n        extensionAttribute8 = \"S-\" + ManagedBy;\n      }\n      else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE) && ManagedBy != null){\n        extensionAttribute8 = \"S-\" + ManagedBy;\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_EXTENSION_ATTRIBUTE_8 + \" = \" + extensionAttribute8);\n    return extensionAttribute8;\n	}\n  }\n  else if(currentField.contains(FIELD_NAME_EXTENSION_ATTRIBUTE_9)){\n    if(!(DOMAIN_NAME.equalsIgnoreCase(\"swe\") || DOMAIN_NAME.equalsIgnoreCase(\"swe\"))){\n    String extensionAttribute9 = \"\";\n\n    Map accountTypeMap =null;\n    if(customDomainMap!=null &&  customDomainMap.get(\"accountType\")!=null){\n    Map accountTypes = customDomainMap.get(\"accountType\");\n    accountTypeMap = accountTypes.get(ACCOUNT_TYPE);\n    }\n\n    if(\"No\".equals(MAILBOX)){\n      if(\"User\".equals(ACCOUNT_TYPE)){\n        Map userTypes = accountTypeMap.get(\"userType\");\n        Map userTypeMap = userTypes.get(USER_TYPE);\n        if(userTypeMap != null){\n          extensionAttribute9 = userTypeMap.get(\"extensionAttribute9\");\n        } else{\n          log.debug(\"unsupported User Type \" + USER_TYPE);\n        }	\n      }\n      else if(\"A-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute9 = accountTypeMap.get(\"extensionAttribute9\");\n      }\n      else if(\"P-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute9 = accountTypeMap.get(\"extensionAttribute9\");\n      }\n\n      else if(\"W-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute9 = accountTypeMap.get(\"extensionAttribute9\");\n      }\n      else if(\"System\".equals(ACCOUNT_TYPE)){\n        //extensionAttribute9 = accountTypeMap.get(\"extensionAttribute9\");\n        extensionAttribute9 = DOMAIN_NAME.toUpperCase();\n      }else if(\"D-\".equals(ACCOUNT_TYPE)){\n        extensionAttribute9 = accountTypeMap.get(\"extensionAttribute9\");\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_EXTENSION_ATTRIBUTE_9 + \" = \" + extensionAttribute9);\n    return extensionAttribute9;\n	}\n  }\n  else if(currentField.contains(FIELD_NAME_USER_ACCOUNT_CONTROL)){\n    Integer userAccountControl = null;\n    int UF_NORMAL_ACCOUNT = 0x0200;\n    int UF_DONT_EXPIRE_PASSWORD = 0x10000;\n    int UF_ACCOUNT_DISABLE = 0x00000002;\n\n    if(\"User\".equals(ACCOUNT_TYPE)){\n      log.debug(\"ADTestUser\");\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n    }\n    else if(\"A-\".equals(ACCOUNT_TYPE)){\n\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n    }\n    else if(\"P-\".equals(ACCOUNT_TYPE)){\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n    }\n\n    else if(\"W-\".equals(ACCOUNT_TYPE)){\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n    }	else if(\"D-\".equals(ACCOUNT_TYPE)){\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n    }\n    else if(\"System\".equals(ACCOUNT_TYPE)){\n      userAccountControl = new Integer(UF_NORMAL_ACCOUNT + UF_DONT_EXPIRE_PASSWORD);\n      if(\"COPP\".equals(SYSTEM_ACCOUNT_SUB_TYPE)) /*Changes for AM-12836 COPP sub Account Type Changes*/\n        userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n      if(\"Shared Mailbox\".equals(SYSTEM_ACCOUNT_SUB_TYPE)) {\n        userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n      } \n      if(\"Kiosk\".equals(SYSTEM_ACCOUNT_SUB_TYPE)) {\n        userAccountControl = new Integer(UF_NORMAL_ACCOUNT);\n      }\n    }\n\n    log.debug(\"currentField: \" + FIELD_NAME_USER_ACCOUNT_CONTROL + \" = \" + userAccountControl);\n    return userAccountControl;\n  }\n  else if(currentField.contains(FIELD_NAME_EXCHANGE_EID)){\n    return identity.getName();\n  }\n  else if(currentField.contains(FIELD_NAME_EXCHANGE_ALIAS)){\n    String alias = \"\";\n    String exchangeFirstName = FIRSTNAME;\n    String exchangeLastName = LASTNAME;\n    if((\"Shared Mailbox\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n      alias = SAMACCOUNTNAME;\n\n    }\n\n    else if((\"Kiosk\").equals(SYSTEM_ACCOUNT_SUB_TYPE)){\n      alias = SAMACCOUNTNAME;\n\n    }\n    else{\n      if(exchangeFirstName != null && !exchangeFirstName.isEmpty()){\n        exchangeFirstName = exchangeFirstName.toLowerCase();\n        exchangeFirstName = exchangeFirstName.substring(0,1).toUpperCase() + exchangeFirstName.substring(1);\n      }\n      if(exchangeLastName != null && !exchangeLastName.isEmpty()){\n        exchangeLastName = exchangeLastName.toLowerCase();\n        exchangeLastName = exchangeLastName.substring(0,1).toUpperCase() + exchangeLastName.substring(1);\n      }\n      alias = exchangeFirstName + \".\" + exchangeLastName;\n      log.debug(\"currentField: \" + FIELD_NAME_EXCHANGE_EID + \" = \" + alias);\n      return alias;\n    }\n  }\n  else if(currentField.contains(FIELD_NAME_AC_NEWPARENT)){\n    String acNewParent = \"\";\n\n    ProvisioningPlan plan = project.getPlan(APPLICATION_NAME);\n    if(plan!=null){\n\n      List accReqList = plan.getAccountRequests(APPLICATION_NAME);\n      if(accReqList!=null && !accReqList.isEmpty()){\n\n        for(ProvisioningPlan.AccountRequest accReq : accReqList){\n\n          List attrReqList = accReq.getAttributeRequests();\n          if(attrReqList!=null && !attrReqList.isEmpty()){\n\n            for(ProvisioningPlan.AttributeRequest attrReq : attrReqList ){\n\n              if(attrReq!=null && ProvisioningPlan.Operation.Add.equals(attrReq.getOperation())){\n\n                if(null != attrReq.getValue() && attrReq.getValue().toString().contains(\"LockLevel\")){\n		  String domainName = DOMAIN_NAME;\n                  if(DOMAIN_NAME.isEmpty()){\n                    List domains = adCustomObject.get(\"domains\");\n                    for(String domain : domains){\n                      	String domainSt = \"dc=\" + domain.toLowerCase();\n                        if((attrReq.getValue().toString().toLowerCase()).contains(domainSt)){\n                          domainName = domain;\n                        }   \n                    }\n                  }\n                  customDomainMap = adCustomObject.get(domainName);\n                  Map lockLevelMap = customDomainMap.get(\"lockLevelGroupMapping\");\n                  String lockLevelValue = attrReq.getValue().toString();\n                  String lockLevelName = lockLevelValue.substring(lockLevelValue.indexOf(\'=\')+1,lockLevelValue.indexOf(\',\'));\n                  if(lockLevelMap!=null){\n                    if(lockLevelMap.get(lockLevelName)!=null){\n                      acNewParent = lockLevelMap.get(lockLevelName);\n                    }\n                  }\n                }\n              }\n\n            }   \n          }\n        }\n      }\n      log.debug(\"currentField: \" + FIELD_NAME_AC_NEWPARENT + \" = \" + acNewParent);\n      return acNewParent;\n    }\n  } \n  else if(currentField.contains(FIELD_NAME_FORCEDSACCOUNT)){\n    String forceAccStr=\"false\";\n    ProvisioningPlan plan = project.getPlan(APPLICATION_NAME);\n    if(plan!=null){\n      List accReqList = plan.getAccountRequests(APPLICATION_NAME);\n      if(accReqList!=null && !accReqList.isEmpty()){\n\n        for(ProvisioningPlan.AccountRequest accReq : accReqList){\n\n          Attributes argAccountRequest=accReq.getArguments();\n          List attributeReqs=accReq.getAttributeRequests(\"memberOf\");\n          if(argAccountRequest!=null && argAccountRequest.get(\"forceNewAccount\")!=null && !attributeReqs.isEmpty()){\n            forceAccStr=\"true\"; \n\n          }\n        }\n      }\n    }\n    field.setHidden(true);\n    return forceAccStr;\n  }\n  else if(currentField.contains(FIELD_NAME_SOURCEASV)){\n	String  sourceASVStr = \"NoValue\";\n    if(null != DOMAIN_NAME && DOMAIN_NAME.isEmpty())\n    {\n      sourceASVStr = \"\";\n    }  \n    if(field.getValue() != null)\n    {\n    	sourceASVStr = field.getValue();\n    } \n    return sourceASVStr;\n\n  }  \n  //all other cases, log an error\n  else{\n    log.debug(\"Unsupported Field Name \" + currentField);\n    return null;\n  }\n\n  log.info(\"Exit rule  AD Field Value Rule\");\n\n\n  ','FieldValue',' ',NULL,'String'),('a9fe0bbd940617a1819406a5b6440050',1735278310980,NULL,NULL,NULL,NULL,'SSH CI Validation',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406a5b7200051',1735278311201,NULL,NULL,NULL,NULL,'ServiceDog common Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd940617a1819406cfd6fc009e',1735281071868,1739425298957,NULL,NULL,NULL,'AD Managed Attribute Customization Rule','ManagedAttributePromotion rule is called when ManagedAttributes are automatically created during aggregation, refresh, or from the missing entitlement descriptions task.\n	This rule sets the attribute to non-requestable.','beanshell','\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n	import sailpoint.object.Application;\n	\n\n	log = LogFactory.getLog(\"com..rap.rule.ManagedAttributeCustomizationRule\");\n	\n	log.debug(\"Inside the Managed Attribute Rule for : \" + attribute);\n\n	attribute.setRequestable(false);\n	','ManagedAttributePromotion',' ',NULL,NULL),('a9fe0bbd940617a1819411e3318801f3',1735466889608,1739425340050,NULL,NULL,NULL,'WebService Field Value Rule','This rule can be used to generate a field value (eg - an account name) using data from the given Identity. If this rule is run in the context of a workflow step then the arguments passed into the step will also be available. Also, any field values that have been processed so far from the policy related to the Application/Role will be available.','beanshell','\n    \nimport org.apache.commons.logging.LogFactory;\nimport org.apache.commons.logging.Log;\nimport sailpoint.api.SailPointContext;\nimport sailpoint.object.Application;\nimport sailpoint.object.Custom;\nimport sailpoint.object.Field;\nimport sailpoint.object.Identity;\nimport sailpoint.object.Form;\nimport sailpoint.object.Link;\nimport sailpoint.api.IdentityService;\nimport sailpoint.object.ProvisioningProject;\nimport sailpoint.object.ProvisioningPlan.AccountRequest;\nimport sailpoint.object.ProvisioningPlan.AttributeRequest;\nimport java.util.*;\nimport sailpoint.tools.xml.XMLObjectFactory;\n\nLog log = LogFactory.getLog(\"com.FieldValueRule\");\nlog.debug(\"Enter rule Visa Online Field Value Rule\");\n\n\nString FIELD_NAME_EMAIL=\"emails.primary.value\";\nString FIELD_NAME_FNAME=\"givenName\";\nString FIELD_NAME_LNAME=\"familyName\";\nString FIELD_NAME_TITLE=\"title\";\nString FIELD_NAME_DEPARTMENT=\"department\";\nString FIELD_NAME_WORKADDRESS=\"location\";\n\n\nString fieldName = field.getName();\nfieldName = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\nString returnString = \"\";\n\nboolean isSystemAccount = false;\nIdentity managedByIdentity = null;\n//getting System Account\nString acctType = identity.getAttribute(\"AccountType\");\nif (\"System\".equals(acctType)) {\n	isSystemAccount = true;\n	String eid=identity.getAttribute(\"ManagedBy\");\n	managedByIdentity=context.getObjectByName(Identity.class,eid);\n\n} else {\n	isSystemAccount = false;\n}\n\n\n//EMAIL\nif (FIELD_NAME_EMAIL.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getEmail() != null) {\n			log.debug(\"Entering is System email\"+managedByIdentity.getEmail());\n			returnString = managedByIdentity.getEmail();\n		}\n	}else{\n		if (identity.getEmail() != null) {\n			log.debug(\"Entering is email\"+identity.getEmail());\n			returnString = identity.getEmail();\n\n		}\n	}\n\n}\n\n//First Name\nelse if (FIELD_NAME_FNAME.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getFirstname() != null) {\n			log.debug(\"Entering is System First Name\"+managedByIdentity.getFirstname());\n			returnString = managedByIdentity.getFirstname();\n		}\n	}else{\n		if (identity.getFirstname() != null) {\n			log.debug(\"Entering is Firstname\"+identity.getFirstname());\n			returnString = identity.getFirstname();\n\n		}\n	}\n\n}\n\n//Last Name\nelse if (FIELD_NAME_LNAME.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getLastname() != null) {\n			log.debug(\"Entering is System Lastname\"+managedByIdentity.getLastname());\n			returnString = managedByIdentity.getLastname();\n		}\n	}else{\n		if (identity.getLastname() != null) {\n			log.debug(\"Entering is Lastname\"+identity.getLastname());\n			returnString = identity.getLastname();\n\n		}\n	}\n\n}  \n\n//Department\nelse if (FIELD_NAME_DEPARTMENT.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getAttribute(\"DeptIDDesc\") != null) {\n			log.debug(\"Entering is System DeptIDDesc\"+managedByIdentity.getAttribute(\"DeptIDDesc\"));\n			returnString = managedByIdentity.getAttribute(\"DeptIDDesc\");\n		}\n	}else{\n		if (identity.getAttribute(\"DeptIDDesc\") != null) {\n			log.debug(\"Entering is DeptIDDesc\"+identity.getAttribute(\"DeptIDDesc\"));\n			returnString = identity.getAttribute(\"DeptIDDesc\");\n\n		}\n	}\n\n}\n\n//Title\nelse if (FIELD_NAME_TITLE.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getAttribute(\"Title\") != null) {\n			log.debug(\"Entering is System Title\"+managedByIdentity.getAttribute(\"Title\"));\n			returnString = managedByIdentity.getAttribute(\"Title\");\n		}\n	}else{\n		if (identity.getAttribute(\"Title\") != null) {\n			log.debug(\"Entering is Title\"+identity.getAttribute(\"Title\"));\n			returnString = identity.getAttribute(\"Title\");\n\n		}\n	}\n\n}\n\n\n//Workaddress\nelse if (FIELD_NAME_WORKADDRESS.equals(fieldName)) {\n	if(isSystemAccount){\n		if (managedByIdentity!=null && managedByIdentity.getAttribute(\"SiteLocation\") != null) {\n			log.debug(\"Entering is System SiteLocation\"+managedByIdentity.getAttribute(\"SiteLocation\"));\n			returnString = managedByIdentity.getAttribute(\"SiteLocation\");\n		}\n	}else{\n		if (identity.getAttribute(\"SiteLocation\") != null) {\n			log.debug(\"Entering is Lastname\"+identity.getAttribute(\"SiteLocation\"));\n			returnString = identity.getAttribute(\"SiteLocation\");\n\n		}\n	}\n\n}\n\n\n\nreturn returnString;\n\n  ','FieldValue',' ',NULL,'String'),('a9fe0bbd940617a1819411e34de401f4',1735466896868,1739425340691,NULL,NULL,NULL,'WebService BeforeOperation rule','This rule is used by the  Web Services connector before performing any operation like testconnection, aggregation etc .','beanshell',' \n    import org.apache.commons.logging.Log;\n    import org.apache.commons.logging.LogFactory;\n    import java.util.HashMap;\n    import java.util.Map;\n    Log log = LogFactory.getLog(\"BeforeRule\");\n\n    String  currentbody = requestEndPoint.getBody().get(\"jsonBody\");\n\n    if(null != currentbody && null != oldResponseMap){\n      String email = oldResponseMap.get(\"emails.primary.value\").toString().replace(\"[\",\"\").replace(\"]\",\"\");\n      currentbody = currentbody.replace(\"plangiven\", oldResponseMap.get(\"givenName\"));\n      currentbody = currentbody.replace(\"planfamily\", oldResponseMap.get(\"familyName\"));\n      currentbody = currentbody.replace(\"planemail\", email);\n\n      log.debug(\"currentbody after\"+  currentbody);\n      Map newMap= new HashMap();\n\n      newMap.put(\"jsonBody\", currentbody);\n      newMap.put(\"bodyFormat\", \"raw\");\n\n      requestEndPoint.setBody(newMap);     \n    }\n\n    String appId = \"allaccess\";\n    String safeName = \"_ALL_ACCESS_CONNECTORS\";\n    String folder = \"root\";\n\n    String accountName = \"bearer@AuditBoard\";\n    String applicationName = \"AuditBoard\";\n\n    String auditBoardAuth = \"Bearer \" + getCyberarkPassword(appId, safeName, folder, accountName, applicationName);\n    Map auditBoardAuthMap = new HashMap();\n    auditBoardAuthMap.put(\"Authorization\",auditBoardAuth);\n    auditBoardAuthMap.put(\"Accept\",\"application/json;v=1\");\n    auditBoardAuthMap.put(\"Content-Type\",\"application/json\");\n    requestEndPoint.setHeader(auditBoardAuthMap);\n\n    return requestEndPoint;\n    ','WebServiceBeforeOperationRule',' ',NULL,'EndPoint'),('a9fe0bbd940617a1819411ebc8960203',1735467452566,1746771002075,NULL,NULL,NULL,'WebService ResourceObject Custimization Rule','This rule is configured on the application and is called after the connector has build a ResourceObject from the native application data.\r\n\r\nInitially designed for non-rule based connectors to add SPPrivileged flag to an object, but could be used to do any transformations.','beanshell','import sailpoint.object.Identity;\r\n  import org.apache.commons.logging.Log;\r\n  import org.apache.commons.logging.LogFactory; \r\n  import sailpoint.object.Filter;\r\n  import sailpoint.object.Filter.FilterCompiler;\r\n  import java.util.Map;\r\n  import sailpoint.object.QueryOptions;\r\n  import sailpoint.object.Filter;\r\n  import org.apache.log4j.Logger;\r\n  import org.apache.log4j.Level;\r\n\r\n  Logger log = Logger.getLogger(\"Rule.WebService.Customization\");\r\n  //log.setLevel((Level) Level.ERROR);\r\n\r\n  String active = object.getStringAttribute(\"active\");\r\n\r\n  if(active != null @and active.equalsIgnoreCase(\"true\"))\r\n  {\r\n    object.put(\"IIQDisabled\", false);\r\n    return object;\r\n  }\r\n  else {\r\n		\r\n    object.put(\"IIQDisabled\", true);\r\n    return object;\r\n  }','ResourceObjectCustomization',' ',NULL,'ResourceObject'),('a9fe0bbd940617a1819411f12ca4020b',1735467805860,1739425339787,NULL,NULL,NULL,'WebService Before Provisioning Rule','An IdentityIQ server-side rule that is executed before the connector\'s provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. \n\nThis rule will be called for any application found in a plan that also has a configured \'beforeProvisioningRule\' configured.  \n\nThe plan can be updated directly in the rule by reference and does not need to return the plan.','beanshell','\n  \nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport sailpoint.object.ProvisioningPlan.AccountRequest;\nimport sailpoint.object.ProvisioningPlan;\nimport sailpoint.object.ProvisioningPlan.AttributeRequest;\nimport sailpoint.object.Identity;\nimport sailpoint.object.Application;\nimport sailpoint.object.Link;\nimport sailpoint.api.IdentityService;\nimport sailpoint.object.Attributes;\nimport sailpoint.tools.GeneralException;\n\nLog log = LogFactory.getLog(\"Rule.WebServiceBeforeProvisioningRule\");\n\nString groupValueAudit = null;\nList groupValueList = new ArrayList();\n\nif(plan != null){\n    log.debug(\"plan before: \" + plan);\n    log.debug(\"identityName\" + plan.getNativeIdentity());\n\n    Identity identity = plan.getIdentity();\n    Link identityLink;\n	\n    String appName = application.getName();\n    log.debug(\"applicationName: \" + appName);\n\n    List acctRequests = plan.getAccountRequests(appName);\n    log.debug(\"acctRequests: \" + acctRequests);\n\n    for(AccountRequest accountRequest:acctRequests ){\n      AccountRequest.Operation op = accountRequest.getOperation();\n      log.debug(\"op: \" + op);\n\n      try{\n        IdentityService is = new IdentityService(context);\n        if(identity!=null && appName != null) {\n          List idenLinks = is.getLinks(identity, application);\n          for (Link link : idenLinks) {\n            if (Util.nullSafeCaseInsensitiveEq(link.getNativeIdentity(), accountRequest.getNativeIdentity())) {\n              identityLink = link;\n            }\n          }\n        }\n      } catch (Exception e){\n        throw new GeneralException(\"WebService Before Provisioning Rule :: Error while getting link :: \",e);\n      }\n\n      AttributeRequest email = accountRequest.getAttributeRequest(\"emails.primary.value\");\n      AttributeRequest givenName= accountRequest.getAttributeRequest(\"givenName\");\n      AttributeRequest familyName= accountRequest.getAttributeRequest(\"familyName\");\n      AttributeRequest group = accountRequest.getAttributeRequest(\"Group\");\n\n      if(op == AccountRequest.Operation.Modify \n         || op == AccountRequest.Operation.Disable \n         || op == AccountRequest.Operation.Enable \n         || op == AccountRequest.Operation.Delete){\n\n        log.debug(\"In Modify Operation***\");\n        log.debug(\"email: \" + email);\n        log.debug(\"givenName: \" + givenName);\n        log.debug(\"familyName: \" + familyName);\n        log.debug(\"group: \" + group);\n      }\n\n      if(group != null && group.getOperation() != null && group.getOperation().equals(ProvisioningPlan.Operation.Remove))\n      {\n        accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Disable);\n      }\n\n      if(op == AccountRequest.Operation.Delete){\n        accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Disable);\n      }\n\n      if(op == AccountRequest.Operation.Enable){\n        if(group==null){\n          Attributes linkAttributes = identityLink.getAttributes();\n          groupValueList = linkAttributes.get(\"Group\");\n          log.debug(\"groupValueList: \" + groupValueList);\n          for (String grpEach : groupValueList){\n            if(grpEach != null) {\n              groupValueAudit = grpEach;\n              break;\n            }\n          }\n\n          AttributeRequest attrGrpRequest = new AttributeRequest(\"Group\", ProvisioningPlan.Operation.Set, groupValueAudit);\n          accountRequest.add(attrGrpRequest);\n         }\n          else{\n          accountRequest.add(group);\n        }\n      }\n\n      log.debug(\"email: \" + email);\n      log.debug(\"givenName:\" + givenName);\n      log.debug(\"familyName: \" + familyName);\n      log.debug(\"accountRequest: \" + accountRequest);\n\n      AttributeRequest attreid = new AttributeRequest(\"username\", ProvisioningPlan.Operation.Add, identity.getName());\n      accountRequest.add(attreid);\n\n      if(email == null)\n      {\n        log.debug(\"email is null***\" + email);\n        AttributeRequest attremail = new AttributeRequest(\"emails.primary.value\", ProvisioningPlan.Operation.Add, identity.getEmail());\n        accountRequest.add(attremail);\n      }\n\n      if(givenName== null)\n      {\n        log.debug(\"givenName***\" + givenName);\n        AttributeRequest attrgivenName = new AttributeRequest(\"givenName\", ProvisioningPlan.Operation.Add, identity.getLastname());\n        accountRequest.add(attrgivenName);\n      }\n\n      if(familyName== null)\n      {\n        log.debug(\"familyName***\" + familyName);\n        AttributeRequest attrfamilyName = new AttributeRequest(\"familyName\", ProvisioningPlan.Operation.Add, identity.getFirstname());\n        accountRequest.add(attrfamilyName );\n      }\n    }\n  }\n\n  log.debug(\"Plan modified: \" + plan); \n\n','BeforeProvisioning',' ',NULL,NULL),('a9fe0bbd940617a1819411f14561020c',1735467812193,1739425339008,NULL,NULL,NULL,'WebService After Provisioning Rule','An IdentityIQ server-side rule that is executed after the connector\'s provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan AFTER it has been sent out to the specific applications. \n\n    This rule will be called for any application found in a plan that also has a configured \'afterProvisioningRule\' configured.','beanshell','\n  \n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.Identity;\n	import sailpoint.connector.ConnectorException;\n	import sailpoint.tools.GeneralException;\n	import sailpoint.object.ResourceObject;\n	import sailpoint.object.TaskResult;\n	import sailpoint.api.Aggregator;\n	import sailpoint.api.SailPointContext;\n	import sailpoint.api.SailPointFactory;\n	import sailpoint.api.Aggregator;\n	import sailpoint.object.Link;\n	import sailpoint.object.Application;\n	import sailpoint.connector.Connector;\n	import sailpoint.connector.ConnectorException;\n	import sailpoint.object.Attributes;\n	import sailpoint.api.Aggregator;\n\n\n	Logger log = Logger.getLogger(\"webserviceWebServiceafterrule\");\n	//log.setLevel((Level) Level.ERROR);\n	String appname = application.getName();\n\n	public static String identityAggregation(SailPointContext context,String applicationName,String distingushedName) throws ConnectorException, GeneralException{\n\n\n		String debugMessage = \"\";\n		String applicationName = applicationName;\n		String accountName = distingushedName;\n		log.debug(\"Doing after Single user Aggregation of WebService account: \"+accountName);\n\n		Application appObject = context.getObjectByName(Application.class, applicationName);\n		String appConnName = appObject.getConnector();\n		log.debug(\"Application \" + applicationName + \" uses connector \" + appConnName);\n		Connector appConnector = sailpoint.connector.ConnectorFactory.getConnector(appObject, null);\n\n		if (null == appConnector) {\n			debugMessage = \"Failed to construct an instance of connector [\" + appConnName + \"]\";\n			return debugMessage;\n		}\n\n		log.debug(\"Connector instantiated, calling getObject() to read account details...\");\n		ResourceObject rObj = null;\n\n		try {\n			rObj = (ResourceObject) appConnector.getObject(\"account\", accountName, null);\n		} catch (sailpoint.connector.ObjectNotFoundException onfe) {\n			debugMessage = \"Connector could not find account: [\" + accountName + \"]\";\n			debugMessage += \" in application [\" + applicationName + \"]\";\n			log.debug(debugMessage);\n			log.debug(onfe);\n			return debugMessage;\n		}\n		if (null == rObj) {\n			debugMessage = \"debug: Could not get ResourceObject for account: \" + accountName;\n			log.debug(debugMessage);\n			return debugMessage;\n		}\n\n		Attributes argMap = new Attributes();\n		argMap.put(\"promoteAttributes\", \"false\");\n		argMap.put(\"correlateEntitlements\", \"false\");\n		argMap.put(\"noOptimizeReaggregation\", \"true\");\n		Aggregator agg = new Aggregator(context, argMap);\n\n		if (null == agg) {\n			debugMessage = \"Null Aggregator returned from constructor. Unable to Aggregate!\";\n			log.debug(debugMessage);\n			return debugMessage;\n		}\n\n		log.debug(\"Calling aggregate() method for WebService \");\n		TaskResult taskResult = agg.aggregate(appObject, rObj);\n		log.debug(\"aggregation complete.\");\n\n		if (null == taskResult) {\n			debugMessage = \"debug: Null taskResult returned from aggregate() call.\";\n			log.debug(debugMessage);\n			return debugMessage;\n		}\n		return (\"Success\");\n\n	}\n\n	if(plan != null){\n		String identityName = plan.getNativeIdentity().toString();\n		Identity identity = context.getObjectByName(Identity.class, identityName);\n		List acctRequests = plan.getAccountRequests(\"WebService\");\n		for(AccountRequest accountRequest:acctRequests ){\n			AccountRequest.Operation op = accountRequest.getOperation();\n			if(op == AccountRequest.Operation.Modify){\n				AttributeRequest group= accountRequest.getAttributeRequest(\"Group\");      \n				if(group != null && group.getOperation() != null && group.getOperation().equals(ProvisioningPlan.Operation.Add))\n				{\n					log.debug(\"In modify Operation in after\");\n					String auditid = accountRequest.getNativeIdentity();\n					if(auditid != null){\n						//DO AGGREGATION\n						identityAggregation(context,appname,auditid);}\n				}\n			}\n\n		}\n	}\n  \n  ','AfterProvisioning',' ',NULL,NULL),('a9fe0bbd940617a1819411f30e3a020e',1735467929146,1739425339526,NULL,NULL,NULL,'WebService Application Account Correlation Rule','Identity Correlation Rules are used to find identities to which new accounts can be attached.\n\nA correlation rule must return a Map with one of the specified Return arguments.','beanshell','\n  \nimport sailpoint.object.Identity;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory; \nimport sailpoint.object.Filter;\nimport sailpoint.object.Filter.FilterCompiler;\nimport java.util.Map;\nimport sailpoint.object.QueryOptions;\nimport sailpoint.object.Filter;\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\n\nLogger log = Logger.getLogger(\"Rule.WebService.Correlation\");\n// log.setLevel((Level) Level.ERROR);\n\nlog.debug(\"Enter rule  CorrelationRule\");\n\nMap correlationMap = new HashMap();\n\nList emaillist = account.getAttribute(\"emails.primary.value\");\nlog.debug(\"emaillist ***\" + emaillist);\n\nif(null != emaillist @and emaillist.size()>0){\n\n	for(String str: emaillist){\n		log.debug(\"str***\" + str);\n\n\n		Identity identity = context.getUniqueObject(Identity.class, Filter.ignoreCase(Filter.eq(\"email\", str)));\n		if(identity != null){\n			log.debug(\"identity not null***\" + identity);\n			correlationMap.put(\"identity\", identity);\n			break;\n		}\n	}\n}\n\n\n// return map\nreturn correlationMap;\n\n','Correlation',' ',NULL,'Map'),('a9fe0bbd94fd12518194fdd399aa000f',1739425290667,NULL,NULL,NULL,NULL,'AD Before Provisioning Rule','This rule will be used to set the attributes of AD account to be provisioned and remove the attributes that cannot be provisioned.','beanshell','\n  \n  import sailpoint.object.*;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.server.Exporter;\n  import sailpoint.tools.GeneralException;\n  import sailpoint.tools.Util;\n  import sailpoint.api.IdentityService;\n  import java.io.*;\n  import java.util.*;\n  import java.util.ArrayList;\n  import sailpoint.object.ProvisioningPlan.Operation;\n  import sailpoint.persistence.Sequencer;\n  import sailpoint.api.SailPointFactory;\n  import sailpoint.api.SailPointContext;\n\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n\n  import java.util.regex.Matcher;\n  import java.util.regex.Pattern;\n\n  import sailpoint.object.Identity;\n  import java.text.SimpleDateFormat;\n  import java.util.Date;\n  import java.util.HashMap;\n  import java.util.List;\n  import java.util.Map;\n  import sailpoint.object.EmailOptions;\n  import sailpoint.object.EmailTemplate;\n\n  import org.apache.http.entity.StringEntity;\n  import org.json.JSONObject;\n\n  import sailpoint.object.Attributes;\n  import sailpoint.object.AuditEvent;\n  import sailpoint.object.Custom;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.server.Auditor;\n\n	Log log = LogFactory.getLog(\"com..rap.ADBeforeProvisioningRule\");\n	log.info(\"Enter rule AD Before Provisioning Rule\");\n\n	try {\n		boolean isCreateReq = false;\n\n		if(plan.getAccountRequests() != null){\n		  Identity user=plan.getIdentity();\n		  Iterable accountRequests = Util.safeIterable(plan.getAccountRequests());\n\n			for (ProvisioningPlan.AccountRequest accountRequest : accountRequests) {\n				//Exclude groups from provisioning\n				accountRequest=checkForPrivilegedEntitlements(accountRequest);\n\n				boolean isAdded = false;\n			\n				if (accountRequest.getOperation().name().equalsIgnoreCase(\"Delete\") ) {\n					\n				}\n				if (accountRequest.getOperation().name().equalsIgnoreCase(\"Disable\") ) {\n					log.debug(\"AD Before Provisioning Rule / Inside Disable Request\");\n					String accountRequestNativeIdentity = (String) accountRequest.getNativeIdentity();\n					log.debug(\"AD Before Provisioning Rule / accountRequestNativeIdentity:\" + accountRequestNativeIdentity);\n					Attributes attributes = plan.getArguments();\n					log.debug(\"AD Before Provisioning Rule / attributes:\" + attributes);\n					String requestorName = attributes.get(\"requester\");\n					log.debug(\"AD Before Provisioning Rule / requestorName:\" + requestorName);\n					if(requestorName.equalsIgnoreCase(\"Scheduler\") && accountRequestNativeIdentity.startsWith(\"CN=P-\")) {\n						log.debug(\"AD Before Provisioning Rule/Account type is P-\");\n						Date currentDate = new Date();\n						String DATE_FORMAT = \"MM/dd/yyyy\";\n						SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\n						String strCurrentDate = sdf.format(currentDate);\n						log.debug(\"AD Before Provisioning Rule / currentDate\" + strCurrentDate);\n						AttributeRequest attTermDate = new AttributeRequest(\"extensionAttribute1\", sailpoint.object.ProvisioningPlan.Operation.Add, strCurrentDate);\n						String description = \"Termed on \" + strCurrentDate;\n						log.debug(\"AD Before Provisioning Rule / description\" + description);\n						AttributeRequest attDescription = new AttributeRequest(\"description\", sailpoint.object.ProvisioningPlan.Operation.Add, description);\n						accountRequest.add(attTermDate);\n						accountRequest.add(attDescription);\n					}\n					if(accountRequest.getNativeIdentity().contains(\"OU=Service Accounts,\")){\n					AttributeRequest adGroup1 = new AttributeRequest(\"memberOf\", sailpoint.object.ProvisioningPlan.Operation.Add, \"Admin\");\n					accountRequest.add(adGroup1);\n					}\n				}\n\n				if (accountRequest.getOperation().name().equalsIgnoreCase(\"Enable\")) {\n\n				  log.debug(\"AD Before Provisioning Rule / Inside Enable Request\");\n				  String accountRequestNativeIdentity = (String) accountRequest.getNativeIdentity();\n				  log.debug(\"AD Before Provisioning Rule / Enable accountRequestNativeIdentity:\" + accountRequestNativeIdentity);\n\n				  if(accountRequestNativeIdentity.startsWith(\"CN=P-\")) {\n					log.debug(\"AD Before Provisioning Rule/ Enable Account type is P-\");\n					AttributeRequest blankTermDate = new AttributeRequest(\"extensionAttribute1\", sailpoint.object.ProvisioningPlan.Operation.Add, \"\");\n\n					Date currentDate = new Date();\n					String DATE_FORMAT = \"MM/dd/yyyy\";\n					SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);\n					String strCurrentDate = sdf.format(currentDate);\n					log.debug(\"AD Before Provisioning Rule / Enable currentDate\" + strCurrentDate);\n					String description = \"Restored on \" + strCurrentDate;\n\n					AttributeRequest blankDescription = new AttributeRequest(\"description\", sailpoint.object.ProvisioningPlan.Operation.Add, description);\n					accountRequest.add(blankTermDate);\n					accountRequest.add(blankDescription);\n				  }\n				}\n					\n\n				if (plan.getNativeIdentity()!=null && plan.getAccountRequests(\"Active Directory\")!=null)\n				{\n				String NativeUser_EID = plan.getNativeIdentity();\n				log.debug(\"NativeUser_EID: \"+NativeUser_EID);\n				boolean NativeMatch = false;\n				List accReqsts = plan.getAccountRequests(\"Active Directory\");\n				for (AccountRequest accReq: accReqsts)\n				{\n					if (accReq.getOperation().name().equalsIgnoreCase(\"Create\"))\n					{\n					log.debug(\"Inside condition\");\n					String NativeAcct = accReq.getNativeIdentity();\n					// Check User Links\n					IdentityService identityService_AD = new IdentityService(context);\n					List User_ADlinks = identityService_AD.getLinks(plan.getIdentity(),application);\n					for(Link linkAD : User_ADlinks)\n					{\n					  if (linkAD.getNativeIdentity()!=null && linkAD.getNativeIdentity().equals(NativeAcct))\n					  {\n						NativeMatch = true;\n					  }\n					}\n					log.debug(\"Native Exists:\"+NativeMatch);\n					if (NativeMatch)\n					{\n						//create new AccReq\n						AccountRequest accReqNew=new AccountRequest();\n						accReqNew.setApplication(\"Active Directory\");\n						accReqNew.setNativeIdentity(NativeAcct);\n						accReqNew.setOperation(AccountRequest.Operation.Modify);\n\n						log.debug(\"New account Request: \"+accReqNew);\n						//get memberOf attribute requests and add to new Acct request\n						for (AttributeRequest attReq : accReq.getAttributeRequests())\n						{\n							if (attReq.getName()!=null && attReq.getName().equalsIgnoreCase(\"memberOf\") && attReq.getValue()!=null)\n							{\n								log.debug(\"Inside memberof if loop: attReq:\"+attReq);\n								accReqNew.add(attReq);\n							}\n						}\n						log.debug(\"accReqNew: \"+accReqNew);\n						plan.add(accReqNew);\n\n						//remove accReq from plan\n						plan.remove(accReq);\n					}\n					}\n				}\n				}//if identity refresh\n			} catch (Exception ex) {\n			  log.debug(\"Error while Executing AD before Prov Rule for Priv Ents on EID block: \"+ex);\n			}\n			\n			}\n\n		if (isCreateReq) {\n			plan = plan.collapse(false);\n			context.commitTransaction();\n		}\n    }\n\n  } catch (Exception e) {\n    log.debug(\"Exception occurred due to:\"+e.getMessage());\n    e.printStackTrace();\n  }\n\n  log.info(\"Exit rule AD Before Provisioning Rule\");\n  \n  ','BeforeProvisioning',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd3cf390010',1739425304377,NULL,NULL,NULL,NULL,'Account Selector Rule','Account Selector Rule','beanshell','\n		import sailpoint.object.Link;\n		import org.apache.commons.logging.Log;\n		import org.apache.commons.logging.LogFactory;\n\n		Log log = LogFactory.getLog(\"com.ADAccountSelectorRule\");\n		log.info(\"Active Directory Account Selector Rule\");\n		\n		String sAMAccountName;\n		String eid = identity.getName();\n		log.debug(\"inside 1 - AD Primary Link Selector\");\n		if(links == null)\n		{\n		 log.debug(\"links is null - AD Primary Link Selector\");\n		   return null;\n		}   \n		if(links != null)\n		{\n			for(Link link: links)\n			{\n				log.debug(\"inside - AD Primary Link Selector\");\n				sAMAccountName = link.getAttribute(\"sAMAccountName\");\n				if(eid != null && sAMAccountName != null){\n					log.debug(\"sAMAccountName :\"+sAMAccountName);\n					if(sAMAccountName.equalsIgnoreCase(eid)){\n						log.debug(\"sAMAccountName : link \"+link.getNativeIdentity());\n						return link;\n					}\n				}\n			}\n		}\n		log.debug(\"returning prompt - AD Primary Link Selector\");\n		return \"prompt\";\n	','AccountSelector',' ',NULL,'Link'),('a9fe0bbd94fd12518194fdd3dfab0011',1739425308587,NULL,NULL,NULL,NULL,'Approval Assignment Rule','\n     This example rule switches all of the owners to spadmin.  The idea \n     of this rule is to allow some customization of the approvals \n     so the ownership can be cacluated for cases where you might\n     use and exteneded attribute or some other means outside our\n     default mechanisms to derive the owner of the Approval.\n     \n     This rule is typically configured on the Approval Step\n     in the LCM Provisioning Workflow or can be set on any\n     steps based on the \"Provisioning Approval\" step \n     library.\n	','beanshell','\n    import sailpoint.object.Workflow;\n    import sailpoint.object.Workflow.Approval;\n    \n    List newApprovals = null;\n    if ( approvals != null ) {\n        newApprovals = new ArrayList();\n        for ( Approval approval : approvals ) {\n            if ( approval != null ) {\n                // update the approver/owner and the description of the approval\n                approval.addArg(Workflow.ARG_WORK_ITEM_DESCRIPTION, \"Approval Assignment Rule Generated\" + identityName);\n                approval.setOwner(\"spadmin\");\n                newApprovals.add(approval);\n            }\n        }\n    }  \n    return newApprovals;\n  ','ApprovalAssignment',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd3f3940012',1739425313684,NULL,NULL,NULL,NULL,'Call PowerShell Rule',NULL,'beanshell','\n    \n	import sailpoint.object.Identity;\n	 \n	import java.util.List;\n	import java.util.ArrayList;\n	import java.util.HashMap;\n	import java.util.Map;\n\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	import sailpoint.object.RpcRequest;\n	import sailpoint.object.RpcResponse;\n	import sailpoint.connector.RPCService;\n\n	Map data = new HashMap();\n	data.put(\"postScript\", \"Powershell Rule\");\n\n	Application ad = context.getObjectByName(Application.class, \"Active Directory\");\n	data.put(\"Application\", ad.getAttributes());\n\n	AccountRequest accountRequest = new AccountRequest();\n	accountRequest.setApplication(\"IIQ\");\n	accountRequest.setNativeIdentity(identityName);\n	accountRequest.setOperation(AccountRequest.Operation.Modify);\n\n	accountRequest.add(new AttributeRequest(\"email\", ProvisioningPlan.Operation.Add, \"test@gmail.com\"));\n\n	// Add to the IQService params\n	data.put(\"Request\", accountRequest);\n\n\n	RPCService service = new RPCService(\"iqServiceHost\", \"iqServicePort\", false, useTLS); \n	RpcRequest request = new RpcRequest(\"ScriptExecutor\", \"runAfterScript\", data);\n	RpcResponse response = service.execute(request);\n\n	Map res = response.getResultAttributes();\n\n	if(res.getMessages() != null && res.getMessages().size() > 0){\n\n		if(res.getMessages().get(0).equals(\"Success\")){\n			if(res.get(\"user\") != null){\n			\n			}\n		}\n\n	}\n\n    \n  ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd3f4ea0013',1739425314026,NULL,NULL,NULL,NULL,'Certification Auto Close Rule','This rule is run when the certification is automatically closed.','beanshell','\n	import java.util.List;\n	import sailpoint.api.IdentityService;\n	import sailpoint.api.Provisioner;\n	import sailpoint.api.SailPointContext;\n	import sailpoint.object.Application;\n	import sailpoint.object.Link;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.ProvisioningProject;\n	import sailpoint.object.*;\n	import sailpoint.object.Identity;\n	import java.util.*;\n	import sailpoint.object.Certification; \n	import sailpoint.object.CertificationAction; \n	import sailpoint.object.CertificationEntity; \n	import sailpoint.object.CertificationItem;  \n	import sailpoint.api.Certificationer; \n	import sailpoint.api.certification.RemediationManager;\n	import sailpoint.tools.GeneralException; \n	import sailpoint.tools.Message; \n	import sailpoint.tools.Util;  \n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n\n		Log logObj = LogFactory.getLog(\"com.Certification-Auto-Close-Rule\");\n		logObj.info(\"Entering Certification Auto Close Rule\");\n		try{ \n			List entities = certification.getEntities();\n			for(entity : entities)\n			{\n				if(!entity.isComplete()) \n				{\n					Identity identObj=entity.getIdentity(context); // Get userID for Entity\n					Application activeDirectoryApp = context.getObjectByName(Application.class, \"Active Directory\");\n\n					Link link = null;\n					String sAMAccountName = \"\";\n					String distinguishedName=\"\";\n					IdentityService IS=new IdentityService(context); \n       \n					List linkList = IS.getLinks(identObj, activeDirectoryApp);\n					for(Link eachLink: linkList)\n					{\n						// find the primary account\n						if(null != eachLink && null != eachLink.getNativeIdentity() && eachLink.getNativeIdentity().toLowerCase().contains(\"cn=\"+identObj.getName().toLowerCase()))\n						{\n							link=eachLink;\n							logObj.debug(\"Found Primary Link\"+ link);\n							break;\n						}\n					}\n					\n					if(link != null) \n					{\n						sAMAccountName = (String) link.getAttribute(\"sAMAccountName\");\n						if(sAMAccountName.equalsIgnoreCase(identObj.getName())) \n						{\n							distinguishedName = link.getAttribute(\"distinguishedName\");\n							List requests = new ArrayList();\n\n							ProvisioningPlan plan = new ProvisioningPlan();\n							ProvisioningProject project=new ProvisioningProject();\n\n							AccountRequest accReq = new AccountRequest();\n							accReq.setOperation(AccountRequest.Operation.Disable); \n							accReq.setApplication(link.getApplicationName());\n							accReq.setNativeIdentity(distinguishedName);\n							requests.add(accReq);\n							plan.setIdentity(identObj);\n							plan.put(\"requester\",\"Certification Admin Workgroup\"); \n\n							plan.setAccountRequests(requests);\n\n							Provisioner provisioner = new Provisioner(context);\n							project = provisioner.compile(plan);\n							provisioner.execute(project);\n							\n							AuditEvent auditEvent=new AuditEvent();\n							auditEvent.setApplication(\"Active Directory\");\n							auditEvent.setAccountName(distinguishedName);\n							auditEvent.setAction(\"Disabling unactioned identity\'s AD Account\");\n							auditEvent.setTarget(identObj.getId());\n							auditEvent.setSource(\"Certification Auto Close Rule\");\n							auditEvent.setString1(\"Certification :\"+ certification.getId());\n							auditEvent.setString2(\"Identity :\"+ identObj.getId());\n							context.saveObject(auditEvent);\n							context.commitTransaction();\n						}\n					}\n				}\n		}\n	} catch(Exception e) {\n		e.printStackTrace();\n	}\n  ','CertificationAutomaticClosing',' ',NULL,'void'),('a9fe0bbd94fd12518194fdd3f62d0014',1739425314349,NULL,NULL,NULL,NULL,'Certification EmailRecipient rule','This rule is used to select an identity or a list of identities who will receive email.','beanshell','\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	import sailpoint.object.Identity;\n	import sailpoint.object.WorkItem;\n	  \n	import sailpoint.object.Certification;\n	import sailpoint.object.CertificationEntity;\n\n \n	import java.util.regex.Matcher;\n	import java.util.regex.Pattern;\n\n	Log logObj = LogFactory.getLog(\"com.CertificationCcManagerRule\");\n	logObj.debug(\"Enter Certification Cc Manager Rule\");\n\n	Identity owner = item.getNotificationOwner(context);\n	List recipientList = new ArrayList(); //list of identity names to whom this notification should be sent  \n\n	if(owner != null){\n		//add the current owner to the owner list\n		String ownerName = owner.getName();\n		recipientList.add(ownerName);\n\n		if(!owner.isWorkgroup()){\n			Identity manager = owner.getManager();\n			if(manager != null){\n				String managerName = manager.getName();\n				if(logObj.isDebugEnabled())\n					logObj.debug(\"adding [\" + managerName + \"] to recipient list\");\n				recipientList.add(managerName);\n\n			}else{\n				if(logObj.isDebugEnabled())\n					logObj.debug(\"Identity [\" + owner.getName() + \"] does not have a manager\");\n			}\n		}\n	} else{\n		logObj.error(\"could not find owner for work item\");\n	}\n\n	logObj.info(\"Exit COF Certification Cc Manager Rule\");\n	return recipientList;\n	','EmailRecipient',' ',NULL,'String or List of Strings'),('a9fe0bbd94fd12518194fdd3f76c0015',1739425314668,NULL,NULL,NULL,NULL,'Certification FallBack Approver Rule','A rule used to pick a fallback owner for a work item in case current owner will cause self-certification.','beanshell','\n	import sailpoint.api.SailPointContext;\n	import sailpoint.api.ObjectUtil;\n\n	import sailpoint.object.Certification;\n	import sailpoint.object.CertificationDefinition;\n	import sailpoint.object.CertificationEntity;\n	import sailpoint.object.Identity;\n	import sailpoint.object.Attributes;\n	import sailpoint.object.WorkItem;\n\n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n	\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory; \n  \n	Log logObj = LogFactory.getLog(\"com..rap.Certification_Fall_Back_Approver_Rule\");\n\n	try\n	{\n		if(WorkItem.Type.Certification.equals(item.getType()))\n		{\n			Certification certification = context.getObjectById(Certification.class, item.getCertification());  \n\n			String certID = certification.getId();\n			String DEFAULT_CERTIFIER = \"All Access Admin Workgroup\";\n			String SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP = \"CertificationAdminWorkgroup\";\n			String CERT_ADMIN_WORKGROUP = context.getConfiguration().getString(SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP);\n\n			String certifierName = \"\";\n			if (owner != null) \n			{\n				certifierName = owner.getName();\n				List certifierNameList=certification.getCertifiers();\n        \n				Certification.Type certType = certification.getType();\n				Identity certifierIdentity = null;\n			if(certType == Certification.Type.Manager)\n			{\n				certifierIdentity = context.getObjectByName(Identity.class,certification.getManager());\n			}\n			else if(certType == Certification.Type.Identity)\n				{\n				CertificationDefinition cd = context.getObjectById(CertificationDefinition.class,certification.getCertificationDefinitionId());\n				if(null == cd)\n				{\n					return owner;\n				}\n				Attributes attb = cd.getAttributes();\n				if(null == attb)\n				{\n					return owner;\n				}\n				String certifierType = attb.get(\"certifierType\");\n\n				if(null != certifierType && certifierType.equalsIgnoreCase(\"Manager\"))\n				{            \n					String identityName = attb.get(\"identities\");\n					Identity certifiedIdentity = context.getObjectByName(Identity.class,identityName);\n					certifierIdentity = certifiedIdentity.getManager();\n					\n					if(null == certifierIdentity)\n					{\n						certifierIdentity = context.getObjectByName(Identity.class,attb.get(\"certifier\"));\n					}\n				} else if(null != certifierType && certifierType.equalsIgnoreCase(\"Manual\"))\n				{\n					certifierIdentity = context.getObjectByName(Identity.class,attb.get(\"certifier\"));\n					if(null == certifierIdentity)\n					{\n						certifierIdentity = context.getObjectByName(Identity.class,attb.get(\"owners\"));\n					}\n				}\n			}\n				\n				if( null == certifierIdentity)\n				{\n					logObj.debug(\"couldn\'t figure out the fall back approver. returning the owner as \"+owner);\n					return owner;\n				}\n		\n			}\n\n    }\n	}\n	catch(Exception e)\n	{\n		logObj.error(\"Exception : \",e);\n	}\n  \n	return owner;\n\n    ','FallbackWorkItemForward',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd3ff140016',1739425316628,NULL,NULL,NULL,NULL,'Common Delimited PostIterate Rule','This rule is called after the connector processes the data in a file.\n\nStats is a Map passed in by the connector with the information it has gathered. Custom keys can be added here if necessary for validation.','beanshell','\n  \n \nimport java.io.File;\nimport java.io.IOException;\n  \nimport sailpoint.object.Schema;\nimport sailpoint.object.Application;\n    \nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n\n  \nLog log = LogFactory.getLog(\"com.cof.rap.rule.DDE.PostIterate\");\n  \n   String objectType=\"\";\n   if (schema !=null)\n   {\n     objectType=(String) schema.getObjectType();\n   }\n  \n  \n  try{\n	if(!objectType.equals(\"\") && objectType.equals(\"account\") && objectType !=null)\n		{\n			log.debug(\"The schema is account\");\n			String path = application.getAttributes().get(\"file\");\n			if(path!=null)\n			{\n				log.debug(\"Path is::: \"+ path);\n				File file = new File(path);\n				log.debug(\"File is::: \"+ file);\n				if(file.exists())\n				{\n					log.debug(\"Delete\");\n					file.delete();\n				}\n				else\n				{\n				log.debug(\"File does not exist\");\n				}\n			}\n   \n		}\n		\n		else if(!objectType.equals(\"\") && objectType.equals(\"group\") && objectType !=null)\n		{  \n			log.debug(\"The schema is group\");\n			String path = application.getAttributes().get(\"group.file\");\n			if(path!=null)\n			{\n				log.debug(\"Group Path is::: \"+ path);\n				File file = new File(path);\n				log.debug(\"Group File is::: \"+ file);\n				if(file.exists())\n				{\n					log.debug(\"Group file Delete\");\n					file.delete();\n				}\n				else\n				{\n				log.debug(\"Group File does not exist\");\n				}\n			}\n   \n		}\n  }\n  catch(Exception e)\n  {\n  	log.debug(e);\n  }\n    log.debug(\"The aggregation isSuccessful: Exiting postIterate Rule\");\n\n  \n  ','PostIterate',' ',NULL,'void'),('a9fe0bbd94fd12518194fdd404a40017',1739425318052,NULL,NULL,NULL,NULL,'Entitlement Self-Service Allowed Values Rule',NULL,'beanshell','\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n	import sailpoint.object.Field;\n	import sailpoint.object.Filter;\n	import sailpoint.object.Form;\n	import sailpoint.object.Identity;\n	import sailpoint.object.ManagedAttribute;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Application;\n	import sailpoint.object.Schema;\n	import sailpoint.tools.Util;\n	import sailpoint.object.Application;\n\n	log = LogFactory.getLog(\"com.EntitlementSelfServiceAllowedValuesRule\");\n	log.info(\"Enter Entitlement Self Service Allowed Values Rule\");\n\n	List returnList = new ArrayList();\n	String applicationName = field.getApplication();\n	String fieldName = field.getName();\n\n	//sometimes IIQ will pass over the field name as application:fieldName, so we have to remove this\n	String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\n	log.debug(\"currentField = \" + currentField);\n\n	if (\"Attribute\".equals(currentField)) {\n		log.debug(\"Inside aattribute\");\n		Set uniqueSet = new HashSet();\n\n		//only search for attribute if application has been selected\n		if (Applications != void && Applications != null && !Applications.isEmpty()) {\n			log.debug(\"app is not null\");\n			String appId = Applications;\n\n			QueryOptions queryOptions = new QueryOptions();\n			Filter filter;\n			List filterList = new ArrayList();\n			if(\"RelatedApplication\".equalsIgnoreCase(context.getObjectById(Application.class, Applications).getType())){\n				log.debug(\"It is inside related app\");\n				filterList.add(Filter.eq(\"EntRelatedApplication\", context.getObjectById(Application.class, Applications).getName()));\n			}\n			else{\n				filterList.add(Filter.eq(\"application.id\", appId));\n				log.debug(\"inside regular app\");\n			}\n			filter = Filter.and(filterList);\n			queryOptions.addFilter(filter);\n\n			Iterator iterator = null;\n			try{\n				iterator = context.search(ManagedAttribute.class, queryOptions, \"attribute\");\n\n				while (iterator.hasNext()){\n					Object[] props = (Object[])iterator.next();\n					String attributeName = (String)props[0];\n					uniqueSet.add(attributeName);\n				}\n\n			}catch (Exception ex){\n				log.debug(ex);\n			}finally {\n				if(iterator != null)\n					sailpoint.tools.Util.flushIterator(iterator);\n			}\n		}\n		returnList = new ArrayList(uniqueSet);\n		return returnList;\n	} else if (\"Values\".equals(currentField)) {\n		if (Attribute != void && Attribute != null && !Attribute.isEmpty()) {\n\n			Filter filter1 = Filter.eq(\"ManagedAttribute.application.id\", Applications);\n			Filter filter2 = Filter.eq(\"ManagedAttribute.attribute\", Attribute);\n			QueryOptions qo = new QueryOptions();\n			qo.add(filter1);\n			qo.add(filter2);\n			iterator = context.search(ManagedAttribute.class, qo);\n			while (iterator.hasNext()) {\n				ManagedAttribute ma = new ManagedAttribute();\n				ma = iterator.next();\n				returnList.add(ma.getValue());\n			}\n		}\n		return returnList;\n	} else if (\"Entitlement\".equals(currentField)) {\n		if (Values != void && Values != null && !Values.isEmpty()) {\n			log.debug(\"Inside Loop\");\n			Filter filter1 = Filter.eq(\"ManagedAttribute.application.id\", Applications);\n			Filter filter2 = Filter.eq(\"ManagedAttribute.attribute\", Attribute);\n			Filter filter3 = Filter.eq(\"ManagedAttribute.value\", Values);\n			QueryOptions qo = new QueryOptions();\n			qo.add(filter1);\n			qo.add(filter2);\n			qo.add(filter3);\n\n			iterator = context.search(ManagedAttribute.class, qo);\n			while (iterator.hasNext()) {\n				ManagedAttribute ma = new ManagedAttribute();\n				ma = iterator.next();\n				returnList.add(ma);\n			}\n		}\n		if (Entitlement != null) {\n			returnList.add(Entitlement);\n		}\n		return returnList;\n	}\n\n	//all other cases, log an error\n	else {\n		log.debug(\"Unsupported Field Name \" + currentField);\n		return null;\n	}\n\n	log.debug(\"currentField: \" + currentField + \" = \" + returnList);\n\n	log.info(\"Exit Entitlement Self Service Allowed Values Rule\");\n	return returnList;    \n  ','AllowedValues',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd408650018',1739425319013,NULL,NULL,NULL,NULL,'Fallback WorkItem Rule','This example falls back to the owner\'s manager as the new owner of the work item. If the owner has no manager, then fall back to the admin of the certification.','beanshell','\n	import sailpoint.object.Certification;\n\n	String SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP = \"CertificationAdminWorkgroup\";\n	String CERT_ADMIN_WORKGROUP = context.getConfiguration().getString(SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP);\n	if (Certification.Type.Manager.equals(type) ||\n		 Certification.Type.Identity.equals(type)) {\n		if (owner.getManager() != null) {\n		   newOwner = owner.getManager().getName();\n		} else { \n		   newOwner = CERT_ADMIN_WORKGROUP;\n		}\n	} else {\n	   newOwner = owner.getName();\n	   System.out.println(\"Keep existing owner for cert type\" + type);\n	}\n\n	System.out.println(\"Completed Fallback work item forward rule.\");\n	System.out.println(\"Forwarding to \" + newOwner);\n\n	return newOwner;\n	','FallbackWorkItemForward',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd409df0019',1739425319392,NULL,NULL,NULL,NULL,'Field Validation Rule','This rule is used to validate the Field values on a provisioning plan.','beanshell','\n   import sailpoint.api.PasswordPolice;\n  import sailpoint.object.Application;\n  import sailpoint.object.Identity;\n  import java.util.List;\n  import java.util.ArrayList;\n  import sailpoint.api.PasswordPolicyException;\n  import sailpoint.tools.Util;\n  import sailpoint.tools.Message;\n  import sailpoint.tools.GeneralException;\n  import sailpoint.object.*;\n\n\n	if(null != value && void != value)\n	{\n		if (value.indexOf(\" \")>=0) {\n			return \"Missing value for required Group Name.\";\n		} else if(value.length() > 8) {\n			form.getField(\"groupname\").setValue(\"\");\n			return \"Group name must be of 8 characters or less.\";\n		}\n	}\n','Validation',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd40ddc001a',1739425320413,NULL,NULL,NULL,NULL,'Group Refresh Rule-NonRequestable Ents','This rule is used to set the owner or modify the account group before it is persisted to the database.','beanshell','import sailpoint.object.Custom;\nimport sailpoint.object.ManagedAttribute;\nimport sailpoint.object.Identity;\nimport java.util.Iterator;\nimport sailpoint.object.QueryOptions;\nimport sailpoint.object.Filter;\n\nimport java.util.Map;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\n//Log log = LogFactory.getLog(\"com.GroupAggregationRefreshRule\");\nlog.debug(\"Entering Group Aggregation Refresh Rule\");\n\nString customName=\"Group Aggregation Applications Custom Object\";\n\nString appName=accountGroup.getApplication().getName();\n//log.debug(\"Application Name is:\"+appName);\n\nCustom custom=context.getObjectByName(Custom.class,customName);\nMap map=custom.get(\"Group_Aggr_Apps\");\nif(map.containsKey(appName))\n    {\n		//String attributeType=map.get(appName);\n		String entName = accountGroup.getValue();\n		log.error(\"####Entitlement name###\"+entName);\n		QueryOptions qo = new QueryOptions();\n		//qo.addFilter(Filter.eq(\"value\", entName));\n		//qo.addFilter(Filter.eq(\"application.name\", appName));\n		qo.add(Filter.eq(\"value\", entName));\n		qo.add(Filter.eq(\"application.name\", appName));\n		Iterator entItr = context.search(ManagedAttribute.class,qo);\n		if(entItr == null) {\n			accountGroup.setRequestable(false);\n		}\n                else{\n		ManagedAttribute managedAttribute=(ManagedAttribute)entItr.next();\n		if(!managedAttribute.isRequestable()){\n	    accountGroup.setRequestable(false);	\n			}\n		}\n}\nlog.debug(\"Exiting Group Refresh Rule\");\nreturn accountGroup;','GroupAggregationRefresh',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd4105e001b',1739425321054,NULL,NULL,NULL,NULL,'Identity Creation Field Value Rule','This rule can be used to generate a field value (eg - Access Level) based on the role selected in the request.','beanshell','\n	import java.lang.String;\n	import java.util.List;\n	import java.util.ArrayList;\n	import java.util.Map;\n	import java.util.HashMap;\n\n	import sailpoint.object.Identity;\n	import sailpoint.object.Field;\n\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n  \n	Log log = LogFactory.getLog(\"com.IdentityCreationFieldValueRule\");\n	log.info(\"Enter rule Identity Creation Field Value Rule\");\n\n	String FIELD_NAME_FIRSTNAME =  \"firstname\";\n	String FIELD_NAME_LASTNAME=  \"lastname\";\n	String FIELD_NAME_DISPLAYNAME=  \"displayName\";\n	String FIELD_NAME_MANAGEDBY=  \"cofManagedBy\";\n	//String FIELD_NAME_MANAGER=  \"manager\";\n\n	String fieldName = null;\n\n	if(field != null)\n	{\n        fieldName = field.getName();\n        fieldName = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\n    }  \n\n	log.error(\"fieldName = \" + fieldName);\n\n	Field nameField = form.getField(\"name\");\n	String name = null;\n	String eid = null;\n	if(nameField != null){\n		name = nameField.getValue();\n		if(name!=null)\n			eid = name.substring(0,6);\n		log.error(\"Get eid : \" + eid);\n	}\n	\n	Identity id = context.getObjectByName(Identity.class, eid);\n	if(id!=null){\n\n	//First Name Field\n	if(FIELD_NAME_FIRSTNAME.equals(fieldName)){\n		log.error(\"***********return first name: \" + id.getFirstname());\n		return id.getFirstname();\n	}\n	//Last Name Field\n	else if(FIELD_NAME_LASTNAME.equals(fieldName)){\n	log.error(\"***********return last name: \" + id.getLastname());\n		return id.getLastname();\n	}\n\n	//Display Name Field\n	else if(FIELD_NAME_DISPLAYNAME.equals(fieldName)){\n	log.error(\"***********return display name: \" + id.getDisplayName());\n		return id.getDisplayName();\n	}\n\n	//Managed By Field\n	else if(FIELD_NAME_MANAGEDBY.equals(fieldName)){\n	log.error(\"***********return managed by : \" + eid);\n		return eid;\n	}\n	/*\n	//Manager field\n	else if(FIELD_NAME_MANAGER.equals(fieldName)){\n		Identity manager = id.getManager();\n		String managerId = null;\n		\n		log.error(\"***********return manager : [\" + manager + \"]\");\n		if(manager != null)\n			managerId = manager.getId();\n		\n		return managerId;\n	}\n	*/\n	}\n	\n	return null;\n\n	log.info(\"Exit rule COF Service Identity Creation Field Value Rule\");\n\n','FieldValue',' ',NULL,'String'),('a9fe0bbd94fd12518194fdd413dc001c',1739425321948,NULL,NULL,NULL,NULL,'Identity Selector Rule','This rule is used to select an Identity that is related to the given Identity','beanshell','\n  import sailpoint.object.*;\n  import sailpoint.api.SailPointContext;\n  import sailpoint.object.Application;\n  import sailpoint.object.Filter;\n  import sailpoint.object.Identity;\n  import sailpoint.api.IdentityService;\n  import sailpoint.api.*;\n  import sailpoint.object.Link;\n  import sailpoint.object.QueryOptions;\n\n  import sailpoint.tools.GeneralException;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  import java.util.ArrayList;\n\n  import java.util.Iterator;\n  import java.util.LinkedList;\n  import java.util.List;\n  \n	IdentityService idService = new IdentityService(context);\n	String immediateOffboard = (String) identity.getAttribute(\"immediateOffboard\");\n\n	boolean hasWAccount = false;\n	boolean inactiveStatus = identity.isInactive();\n	boolean result = false;\n\n	String ADAppName = \"Active Directory\";\n	List adAccountList = new ArrayList();\n\n	Application adAppObject = context.getObjectByName(Application.class, ADAppName);\n	List links = identity.getLinks();\n	List adLinks = idService.getLinks(identity, adAppObject);\n\n	if(adLinks==null || adLinks.size() <= 0){\n		return false;\n	} else{\n		for (Link link: adLinks) {   \n			if(!link.isDisabled() && link.getNativeIdentity()!=null && 			(link.getNativeIdentity().toLowerCase().contains(\"cn=w-\")) ){\n				hasWAccount = true;\n				break;\n			}\n		}\n	}\n\n \n	if (immediateOffboard == null && !inactiveStatus  && hasWAccount)\n	{ \n		result = true;\n	}\n\n  return result;','IdentitySelector',' ',NULL,'boolean'),('a9fe0bbd94fd12518194fdd414d3001d',1739425322196,NULL,NULL,NULL,NULL,'IdentityMapping displayName Rule','Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.\n\nThis rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the \"link\" argument which is not passed in global mapping rules.','beanshell','String first = (String)link.getAttribute(\"FIRSTNAME\");\nString last = (String)link.getAttribute(\"LASTNAME\");\nString middle = (String)link.getAttribute(\"MIDDLENAME\");\n\n//null checking\nfirst = first == null ? \"\" : first + \" \";\nmiddle = middle == null ? \"\" : middle + \" \";\nlast = last == null ? \"\" : last;\n\nreturn first + middle + last;','IdentityAttribute',' ',NULL,'String'),('a9fe0bbd94fd12518194fdd41a42001e',1739425323586,NULL,NULL,NULL,NULL,'Inactive Owner WorkItem Forward Rule','\n    Escalation rule that triggers when a workitem owner becomes inactive. \n  ','beanshell','\n	import sailpoint.object.Application;\n	import sailpoint.object.Certification;\n	import sailpoint.object.Identity;\n	import sailpoint.object.RemediationItem;\n	import sailpoint.object.WorkItem;\n\n	import sailpoint.api.ObjectUtil;\n	import sailpoint.api.SailPointContext;\n\n	import sailpoint.tools.Util;\n\n	import java.util.ArrayList;\n	import java.util.HashMap;\n	import java.util.Map;\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory; \n\n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n\n	//Log log = LogFactory.getLog(\"com..rap.globalWorkItemForwardRule\");\n\n	Logger log = Logger.getLogger(\"com..rap.InactiveOwnerWorkItemForwardRule\");\n	log.setLevel((Level) Level.TRACE);  // TODO: Remove this in production rules.\n\n	//Method to pull the proper owner for the identity regardless of its type.\n	public Identity getTheOwner(Identity iden) {\n		log.debug(\"InactiveOwnerWorkItemForwardRule getTheOwner method :: start\");\n		log.debug(\"InactiveOwnerWorkItemForwardRule getTheOwner method :: identity \"+iden);\n		if(iden != null){\n			if(!iden.isWorkgroup()){\n				log.debug(\"InactiveOwnerWorkItemForwardRule getTheOwner method :: identity is not a workgroup\");\n			return iden;\n		} else {\n			log.debug(\"InactiveOwnerWorkItemForwardRule getTheOwner method :: identity is a workgroup\");\n			Iterator worgroupMembers = ObjectUtil.getWorkgroupMembers(context, iden, new ArrayList());\n			while(worgroupMembers.hasNext()){\n				Identity wgMember = (Identity) worgroupMembers.next()[0];\n				log.debug(\"InactiveOwnerWorkItemForwardRule getTheOwner method :: identity in workgroup \"+wgMember);\n				return wgMember;\n			}\n		}\n		}\n		return null;\n	}\n  \n	/*MAIN METHOD STARTS HERE*/\n	if(WorkItem.Type.Certification.equals(item.getType()))\n	{\n		log.debug(\"owner before we start any thing \" +owner);\n		//Getting owner through the method to process items owned by workgroup properly\n		Identity owner = getTheOwner(item.getOwner());\n		String ADMIN_WORKGROUP = context.getConfiguration().getString(\"AdminWorkgroupName\");\n		String SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP = \"CertificationAdminWorkgroup\";\n		String CERT_ADMIN_WORKGROUP = context.getConfiguration().getString(SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP);\n\n		Identity newOwner = owner;\n		boolean isTerminated = false;\n\n		newOwner = owner.getManager();\n\n		if(newOwner != null)\n		{\n			String immediateOffBoard = newOwner.getAttribute(\"ImmediateOffboard\");\n			if(\"true\".equals(immediateOffBoard))\n				isTerminated = true;\n		}\n\n		//enclose the entire code block in a try catch and return the fall back workgroup if anything goes wrong\n		try\n		{\n			\n			boolean isRoleCertification = false;\n			boolean isIdentityCertification = false;\n			if(item.isCertificationRelated()) \n			{  \n				Certification cert = context.getObjectById(Certification.class, item.getCertification());  \n				if(cert != null) {  \n					if(cert.getType() == Certification.Type.BusinessRoleComposition || cert.getType() == Certification.Type.BusinessRoleMembership) {  \n						if(item.getType() == WorkItem.Type.Remediation) {\n							isRoleCertification = true;\n						}  \n					} else if(cert.getType() == Certification.Type.ApplicationOwner || cert.getType() ==  Certification.Type.Identity || cert.getType() ==  Certification.Type.Manager){\n						isIdentityCertification = true;\n					}\n				}  \n			}\n		\n			//forward to fallback approver if inactive or null\n			if (newOwner == null || newOwner.isInactive() || isTerminated){\n				if(isIdentityCertification){\n					Identity certificationAdminWorkgroup = context.getObjectByName(Identity.class, CERT_ADMIN_WORKGROUP);\n					if(newOwner != null){\n						newOwner = certificationAdminWorkgroup;\n						log.debug(\"newOwner is null or inactive. Certification newOwner: \" + newOwner);\n					} else{\n						log.debug(\"newOwner is null or inactive.  newOwner: \" + newOwner);\n						newOwner = context.getObjectByName(Identity.class, ADMIN_WORKGROUP);\n					}\n				} else{\n					log.debug(\"newOwner is null or inactive.  newOwner: \" + newOwner);\n					newOwner = context.getObjectByName(Identity.class, ADMIN_WORKGROUP);\n				}\n			}\n			//forward to Certification Admin Workgroup if this is a remediation from a role certification\n			else if(isRoleCertification)\n			{\n				Identity certificationAdminWorkgroup = context.getObjectByName(Identity.class, CERT_ADMIN_WORKGROUP);   \n				newOwner = certificationAdminWorkgroup;\n			}\n		//return fallback approver if anything goes wrong during the rule\n		} catch (Exception e){\n			newOwner = context.getObjectByName(Identity.class, ADMIN_WORKGROUP); \n			if(newOwner != null){\n				log.error(\"encountered exception in work item forward rule.  Returning fall back approver [\" + newOwner.getName() + \"]\");\n				log.error(e);\n			} else {\n				log.error(\"Encountered exception in work item forward rule.  Attempted to return fall back approver, but cannot find fall back approver [\" + ADMIN_WORKGROUP + \"]\");\n			}\n		}\n			log.info(\"Exiting work item forward rule newOwner = \" +newOwner.getName());\n			return newOwner;\n	} else\n		return null;\n  \n  ','Escalation',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd4235d001f',1739425325918,NULL,NULL,NULL,NULL,'Launch Workflow Example','A rule used by a Workflow to determine a step action or variable value.\n	Note that an Attributes map of all variables from the current WorkflowContext, merged with the arguments from the Step, is also passed into the workflow rule.','beanshell','\n	import java.util.ArrayList;\n	import java.util.Collections;\n	import java.util.HashMap;\n	import java.util.List;\n\n	import org.apache.log4j.Logger;\n\n	import sailpoint.api.Workflower;\n	import sailpoint.object.Attributes;\n	import sailpoint.object.Identity;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.Workflow;\n	import sailpoint.object.WorkflowLaunch;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.Filter;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Link;\n	import sailpoint.object.Application;\n	import sailpoint.api.IdentityService;		  \n\n	String identityName = \"2020009\";\n	String workflow = \"Sample Workflow\";\n	HashMap 	launchArgsMap = new HashMap();\n	launchArgsMap.put(\"identityName\", identityName);\n	launchArgsMap.put(\"launcher\", \"spadmin\"); \n	\n	//Create WorkflowLaunch and set values\n	WorkflowLaunch wfLaunch = new WorkflowLaunch();\n	Workflow wf = (Workflow)context.getObjectByName(Workflow.class, workflow);\n	wfLaunch.setWorkflowName(wf.getName());\n	wfLaunch.setWorkflowRef(wf.getName());\n	wfLaunch.setVariables(launchArgsMap);\n\n	//Create Workflower and launch workflow from WorkflowLaunch\n	Workflower workflower = new Workflower(context);\n	WorkflowLaunch launch = workflower.launch(wfLaunch); \n	','Workflow',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd426d10020',1739425326801,NULL,NULL,NULL,NULL,'Managed Attribute Customization Rule','ManagedAttributePromotion rule is called when ManagedAttributes are automatically created during aggregation, refresh, or from the missing entitlement descriptions task. This rule sets the attribute to non-requestable.','beanshell','import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n	import sailpoint.object.Application;\n	\n\n	attribute.setRequestable(false);','ManagedAttributePromotion',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd428090021',1739425327113,NULL,NULL,NULL,NULL,'NPI Attribute Change Rule','This rule can be used when the ObjectAttribute being listened to has changed.','beanshell','\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport sailpoint.api.SailPointContext;\nimport sailpoint.object.AuthenticationAnswer;\nimport sailpoint.object.AuthenticationQuestion;\nimport sailpoint.object.Filter;\nimport sailpoint.object.Identity;\nimport sailpoint.object.ObjectAttribute;\nimport sailpoint.object.QueryOptions;\nimport sailpoint.tools.GeneralException;\nimport sailpoint.tools.Util;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n  \n\n	public Log log = LogFactory.getLog(\"com.NPI Attribute Change Rule\");\n	// Identity attributes\n	public static String IDENTITY_ATT_DOB = \"BirthDate\";\n	public static String IDENTITY_ATT_POB = \"BirthCity\";\n	public static String IDENTITY_ATT_SSN = \"NationalID\";\n	// Questions\n	public String COF_AUTH_QUESTION_DOB = \"auth_question_dob\";\n	public String COF_AUTH_QUESTION_POB = \"auth_question_place_of_birth\";\n	public String COF_AUTH_QUESTION_SSN = \"auth_question_ssn\";\n  \n\n		\n		\n	public void updateAuthAnswer(String questionStr, Identity identity,\n			String answer) {\n		log.debug(\"Enter updateAuthAnswer()\");\n		\n		QueryOptions option = new QueryOptions();\n		option.addFilter(Filter.eq(\"question\", questionStr));\n		Iterator questionIt = context.search(AuthenticationQuestion.class, option);\n		if (questionIt.hasNext()) {\n			AuthenticationQuestion question = questionIt.next();\n			log.info(\"question:\" + question.getQuestion());\n			List answers = identity.getAuthenticationAnswers();\n			log.info(\"answers:\" + answers);\n			\n			if (answers == null) {\n				answers = new ArrayList();\n			}\n			\n			Iterator answersIter = answers.iterator();\n			while (answersIter.hasNext()) {\n\n				AuthenticationAnswer oldAnswer = answersIter.next();\n				if (oldAnswer.getQuestion().getId().equals(question.getId())) {\n					answersIter.remove();\n					break;\n				}\n			}\n\n			if (answer != null && answer.trim().length() != 0) {\n				AuthenticationAnswer newAnswer = new AuthenticationAnswer();\n				newAnswer.setQuestion(question);\n				newAnswer.setAnswer(answer);\n				answers.add(newAnswer);\n				identity.assignAuthenticationAnswers(answers);\n			}\n		}\n		if(questionIt != null)\n			Util.flushIterator(questionIt);\n		log.debug(\"Exit updateAuthAnswer()\");\n	\n	}\n\n		log.debug(\"Enter NPI Attribute Change Rule\");\n		log.info(\"attributeName:\" + attributeName);\n		log.info(\"oldValue:\" + oldValue);\n		log.info(\"newValue:\" + newValue);\n\n		if (attributeName.equals(IDENTITY_ATT_DOB)) {\n			updateAuthAnswer(AUTH_QUESTION_DOB, identity, newValue);\n		} else if (attributeName.equals(IDENTITY_ATT_POB)) {\n			updateAuthAnswer(COF_AUTH_QUESTION_POB, identity, newValue);\n		} else if (attributeName.equals(IDENTITY_ATT_SSN)) {\n			updateAuthAnswer(COF_AUTH_QUESTION_SSN, identity, newValue);\n		}\n\n		log.debug(\"Exit COF NPI Attribute Change Rule\");\n		\n\nreturn;','Listener',' ',NULL,'void'),('a9fe0bbd94fd12518194fdd42d0e0022',1739425328398,NULL,NULL,NULL,NULL,'Orphan Creation Rule','Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be 	created during the aggregation of application accounts, or optionally created after pass-through authentication. One common operation is to change the name property of the identity when the default application name is complex (such as a directory DN). Another common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.','beanshell','\n	import sailpoint.object.Identity;\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory; \n	import sailpoint.object.Filter;\n	import sailpoint.object.Filter.FilterCompiler;\n	import java.util.Map;\n	import java.util.List;\n	import java.util.ArrayList;\n	import java.util.Iterator;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Link;\n	\n	import sailpoint.api.Correlator;\n	import sailpoint.object.Application;\n\n	String appShortName = application.getStringAttributeValue(\"ShortName\");\n	String uid = account.getStringAttribute(\"uid\");\n	String employeeType = account.getStringAttribute(\"employeeType\");\n	\n	//set orphan account name unique per app\n	if(appShortName == null || appShortName.equals(\"\")) {\n		identity.setName(uid);\n	} else {\n		identity.setName(appShortName + \"-\" + uid);\n	}\n\n	//set employeeType for service accounts\n	if(employeeType != null && employeeType.equalsIgnoreCase(\"Service\")){\n		identity.setAttribute(\"employeeType\", \"Service\");\n	}\n','IdentityCreation',' ',NULL,'void'),('a9fe0bbd94fd12518194fdd42e670023',1739425328744,NULL,NULL,NULL,NULL,'Example Owner Rule','\n    Owner Rules are used by provisioning policies to determine the owner of the\n    provisioning policy or its policy fields. \n  ','beanshell','\n      import sailpoint.object.Identity;\n\n		Identity owner = null;\n		if (role != null)\n			owner = role.getOwner();\n		else if (app != null)\n			owner = app.getOwner();\n		else\n			owner = identity.getManager();\n\n		if (owner == null)\n			owner = context.getObjectByName(Identity.class, \"spadmin\");\n\n      return owner;\n  ','Owner',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd42f860024',1739425329030,NULL,NULL,NULL,NULL,'Password Validation Rule','This rule is used to validate the Field values on a provisioning plan.','beanshell','\n   import sailpoint.api.PasswordPolice;\n  import sailpoint.object.Application;\n  import sailpoint.object.Identity;\n  import java.util.List;\n  import java.util.ArrayList;\n  import sailpoint.api.PasswordPolicyException;\n  import sailpoint.tools.Util;\n  import sailpoint.tools.Message;\n  import sailpoint.tools.GeneralException;\n  import sailpoint.object.*;\n\n  sailpoint.api.PasswordPolice police = new sailpoint.api.PasswordPolice(context);\n  List msgs = new ArrayList();\n\n  try { \n    PasswordPolicy passwordPolicy = context.getObjectByName(PasswordPolicy.class, \"AD Password Policy\");\n    police.checkPassword(null, passwordPolicy,value, null); \n    return null; \n  } \n  catch (PasswordPolicyException pe) {\n    List messages = pe.getAllMessages();\n    for (Message msg : messages) {\n      msgs.add(msg.getMessage());\n    }\n  }\n  catch (GeneralException ge) {\n    msgs.add(ge.getMessage());\n  }\n\n  return ( Util.size(msgs) > 0 ) ? msgs: null;\n','Validation',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd433160025',1739425329943,NULL,NULL,NULL,NULL,'Policy Owner Rule','\n    This example simply returns admin as an owner.\n  ','beanshell','\n	import sailpoint.object.Identity;\n	\n	Identity owner = identity.getManager();\n	if (null == owner){\n		owner = context.getObject(Identity.class, \"Admin\");\n	}\n	\n	return owner;\n  ','PolicyOwner',' ',NULL,'Identity'),('a9fe0bbd94fd12518194fdd436240026',1739425330725,NULL,NULL,NULL,NULL,'Powershell Rule','\n  This example is for IQService Before Script.  This is a sample PowerShell after script which ensures that the request was processed successfully and\ncreates home directory at the path specified in the request\n  ','beanshell','\n        Add-type -path utils.dll\n        # Read the environment variables\n        $sReader = New-Object System.IO.StringReader([System.String]$env:Request);\n        $sResult = New-Object System.IO.StringReader([System.String]$env:Result);\n        # Form the xml reader objects\n        $xmlReader = [System.xml.XmlTextReader]([sailpoint.utils.xml.XmlUtil]::getReader($sReader));\n        $xmlReader_Result = [System.xml.XmlTextReader]([sailpoint.utils.xml.XmlUtil]::getReader($sResult));\n        # Create SailPoint objects\n        $requestObject = New-Object Sailpoint.Utils.objects.AccountRequest($xmlReader);\n        $resultObject = New-Object Sailpoint.Utils.objects.ServiceResult($xmlReader_Result);\n		\n        $attributes = @{}\n		foreach ($attribute in $requestObject.AttributeRequests){\n			$attributes[$attribute.Name] = $attribute.Value;\n		}\n		\n		$email = $attributes[\"email\"]\n		\n		$user = Get-ADUser -Filter \"EmailAddress -eq $email\" -Properties EmailAddress \n		\n		Try {\n			# Handle input and do stuff here\n			$resultObject.Messages.add(\"Success!\");\n			$resultObject.Attribute[\"user\"] = $user\n		} catch [Exception] {   \n			# You should probably do some logging here too\n			$ErrorMessage = $_.Exception.ToString()\n			$resultObject.Errors.add($ErrorMessage);\n		} finally {\n			$resultObject.toxml() | out-file $args[0];\n		}  \n		\n		\n','ConnectorAfterCreate','<Attributes>\n  <Map>\n    <entry key=\"ObjectOrientedScript\" value=\"true\"/>\n    <entry key=\"disabled\" value=\"false\"/>\n    <entry key=\"extension\" value=\".ps1\"/>\n    <entry key=\"program\" value=\"powershell.exe\"/>\n    <entry key=\"timeout\" value=\"240\"/>\n  </Map>\n</Attributes>\n',NULL,NULL),('a9fe0bbd94fd12518194fdd4378a0027',1739425331082,NULL,NULL,NULL,NULL,'PreIterate Delimited File Applications','This rule is called before the connector processes the data in a file.','beanshell','import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Date;\nimport sailpoint.connector.Connector;\nimport sailpoint.connector.DelimitedFileConnector;\nimport sailpoint.object.Schema;\nimport sailpoint.api.SailPointFactory;\nimport sailpoint.api.SailPointContext;\nimport sailpoint.tools.GeneralException;\nimport sailpoint.tools.xml.XMLObjectFactory;\nimport sailpoint.object.Configuration;\n  \nimport org.apache.commons.io.FilenameUtils;\n\n// Get the directory that contains the extract files for this application\nString absPath = (String) stats.get(\"absolutePath\");\nString fileName = (String) stats.get(\"fileName\");\nString fileNameWithoutExtension = (String) FilenameUtils.removeExtension(fileName); \n  \nlog.debug(\"Current path: \" + absPath);\nlog.debug(\"Current fileName: \" + fileName);\nlog.debug(\"Current fileNameWithoutExt: \" + fileNameWithoutExtension);\n\nString directoryPath = absPath.replace(fileName, \"\");\n    \n// Find the last modified (most recent) file in this directory that contains the fileName in its name\n  String latestFileName = \"\";\n  if (absPath != null ){\n    File directory = new File(directoryPath);\n    File [] filesInDir = directory.listFiles();\n    Date temp_date = new  Date(0);  \n    \n    if  ( filesInDir != null ) {\n      \n					 int length = filesInDir.length; \n					 for  ( int i = 0; i  <  length; ++i ) {   \n							 \n             File f = filesInDir [i];\n             if ( f.getName().toLowerCase().contains(fileNameWithoutExtension.toLowerCase())){ \n             \n               Long lastModified = f.lastModified();\n               Date date = new  Date(lastModified);\n\n               if  ( f.isFile( ) ) {  \n                    if  ( date.after(temp_date) ) {\n                        temp_date = date;\n                        latestFileName = f.getName();\n                    }                             \n                 }\n             }\n             \n					 }\n         \n			  }\n     \n      // Open a new input stream for the most recent file and return it\n      // PreIterate rule lets you optionally return InputStream that will overwrite the stream it opens originally\n    	String completeAbsPath = directoryPath + latestFileName;\n      log.debug(\"Latest File : \" + latestFileName);\n			log.debug(\"Abs Dir : \" + completeAbsPath);\n    \n      InputStream in = null;\n    if (!latestFileName.equals(\"\")){\n        try {\n          in = new FileInputStream(completeAbsPath);\n          log.debug(\"File stream opened\");\n        } catch (IOException e){\n          log.error(e); \n        }\n    }\n    \n    return in;\n    \n  }','PreIterate',' ',NULL,'void'),('a9fe0bbd94fd12518194fdd43d3f0028',1739425332543,NULL,NULL,NULL,NULL,'QueryOptions Example Rule 1',NULL,'beanshell','\n	import java.util.*;\n	import sailpoint.object.*;\n	import sailpoint.api.Provisioner;\n	import sailpoint.api.*;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Filter;\n	import sailpoint.tools.Util;\n	import sailpoint.tools.GeneralException;\n\n\n	QueryOptions qo = new QueryOptions();\n    qo.addFilter(Filter.eq(\"type\", \"Logical\"));\n    Iterator logicalAppIter = context.search(Application.class, qo);\n        \n    // Iterate through each app and write its attributes to the properties file\n    while(logicalAppIter.hasNext()){\n		Application curApp = (Application) logicalAppIter.next();\n		String curAppName = curApp.getName();\n	}\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd43e530029',1739425332819,NULL,NULL,NULL,NULL,'QueryOptions Example Rule 2',NULL,'beanshell','\n	import java.util.*;\n	import sailpoint.object.*;\n	import sailpoint.api.Provisioner;\n	import sailpoint.api.*;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Filter;\n	import sailpoint.tools.Util;\n	import sailpoint.tools.GeneralException;\n\n\n	Custom custom = context.getObjectByName(Custom.class,\"Managed Attribute Non-Requestable Custom\");\n	List list = custom.getAttributes().get(\"NonRequestableApps\");\n	for(String li: list){\n	QueryOptions qo = new QueryOptions();\n    log.debug(\"**************** The application is***********\" + li);\n	Filter f = Filter.eq(\"application.name\",li);\n	f = Filter.and(f,Filter.eq(\"requestable\",true));\n	qo.addFilter(f);\n	\n	List att = context.getObjects(ManagedAttribute.class,qo);\n	for(ManagedAttribute mattr: att){\n		log.debug(\"*****************The managedAttribute display name is*******************\" +mattr.getDisplayableName());\n		log.debug(\"*****************The managedAttribute status is*******************\" +mattr.isRequestable());\n        \n		mattr.setRequestable(false);\n		context.saveObject(mattr);  \n		context.commitTransaction();  \n        \n		AuditEvent event = new AuditEvent();\n		event.setSource(context.getUserName());\n		event.setTarget(mattr.getDisplayName());\n		event.setAction(\"Requestable\");\n		event.setString1(\"Modify Requestable to Non Requestable\");\n\n\n		context.saveObject(event);\n		context.commitTransaction();\n		Auditor.log(event);\n\n	}\n	} \n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd440db002a',1739425333468,NULL,NULL,NULL,NULL,'QueryOptions Example Rule 4',NULL,'beanshell','\n	import sailpoint.api.Certificationer;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Filter;\n	import sailpoint.object.Certification;\n	import sailpoint.object.Certification.Phase;\n	import sailpoint.object.CertificationGroup;\n	import sailpoint.object.CertificationGroup.Status;\n	import sailpoint.task.AbstractTaskExecutor; \n	import sailpoint.task.TaskMonitor;  \n	import sailpoint.tools.Message;\n	import sailpoint.tools.xml.XMLObjectFactory; \n	import sailpoint.tools.xml.XMLReferenceResolver;\n	import java.util.ArrayList; \n	import java.util.List;\n	import java.util.Date;\n	import java.text.SimpleDateFormat;\n\n	import java.net.InetAddress;\n\n	import org.apache.log4j.Logger;  \n	import org.apache.log4j.Level;\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory; \n\n	//Logger logObj = Logger.getLogger(\"CertActivate\");\n	//logObj.setLevel((Level) Level.DEBUG);  // TODO: Remove this in production rules.\n  \n	Log logObj = LogFactory.getLog(\"CertActivate\");\n\n  \n	// Sanity checking to make sure we were passed a valid workItem String.\n	if ((void == workItem) || (null == workItem)) {\n		logObj.error(\"Received a null or void workItem string.\");\n		return;\n	}\n	if ( !(workItem instanceof String) ) {\n		logObj.error(\"Received a workItem that is not a String.\");\n		return;\n	} \n\n\n	try\n	{\n		Certificationer certificationer = new Certificationer(context);\n		Certification cert = context.getObjectById(Certification.class,workItem);\n\n		QueryOptions ops = new QueryOptions();\n		ops.addFilter(Filter.join(\"id\",\"Certification.certificationGroups.id\"));\n		ops.addFilter(Filter.eq(\"Certification.id\",workItem));\n		//ops.addFilter(Filter.eq(\"Certification.tags.name\",\"SWE-Cert\"));\n		ops.setDistinct(true);\n\n		List props = new ArrayList();\n		props.add(\"id\");\n\n		//logObj.debug(\"Current Phase is :\"+cert.getPhase().getMessageKey());    \n		//logObj.debug(\"Setting phase to Active on certification: \"+cert.getName());\n\n\n		if(null != cert)\n		{\n			logObj.debug(\"Activating the certification : \"+cert.getName());\n			certificationer.activate(workItem);\n			logObj.info(\"Activated the certification : \"+cert.getName());\n      \n			Iterator it = context.search(CertificationGroup.class, ops, props);\n			while (it.hasNext()) \n			{\n				Object [] result = it.next();\n				String cgId = (String) result[0];\n				CertificationGroup cg = context.getObjectById(CertificationGroup.class,cgId);\n\n				if (cg != null)\n				{\n					logObj.debug(\"Activating cert group: \"+ cg.getName());\n					cg.setStatus(CertificationGroup.Status.valueOf(\"Active\"));\n					context.saveObject(cg);\n					context.commitTransaction();\n					logObj.info(\"Activated cert group: \"+ cg.getName());\n				}\n			}\n      \n      \n			//context.saveObject(cert);\n			//context.commitTransaction();\n		}\n\n	}\n	catch(Exception e)\n	{\n		logObj.error(\"Caught error while activating the certification: \"+workItem,e); \n	}\n\n	return \"Success\";\n  ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd441dc002b',1739425333724,NULL,NULL,NULL,NULL,'QueryOptions Example Rule 5',NULL,'beanshell','\n	 import java.lang.Runtime;\n  import java.lang.management.ManagementFactory;\n  import java.text.SimpleDateFormat;\n  import java.net.InetAddress;\n  import java.util.ArrayList; \n  import java.util.List;\n  import java.util.Date;\n  import java.util.concurrent.ConcurrentHashMap;\n \n  import sailpoint.api.SailPointFactory;\n  import sailpoint.api.SailPointContext;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.object.Filter;\n  import sailpoint.object.TaskResult;\n  import sailpoint.object.Certification;\n  import sailpoint.object.Certification.Phase;\n  import sailpoint.object.CertificationGroup;\n\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory; \n\n  import org.apache.log4j.Logger;\n  import org.apache.log4j.Level;\n\n // Logger logObj = Logger.getLogger(\"MTCertActivate\");\n Log logObj = LogFactory.getLog(\"MTCertActivate\");\n // logObj.setLevel((Level) Level.DEBUG);  // TODO: Remove this in production rules.\n\n\n  // Sanity checking to make sure we were passed a valid workQueue reference.\n  if ((void == workQueue) || (null == workQueue)) {\n    logObj.error(\"Received a null or void workQueue reference.\");\n    return;\n  }\n  if ( !(workQueue instanceof java.util.concurrent.BlockingQueue) ) {\n    logObj.error(\"Received a workQueue that is not a BlockingQueue.\");\n    logObj.error(\"Data type for workQueue is: \" + workQueue.getClass().getName());\n    return;\n  }  \n\n  // Sanity checking to make sure we were passed a valid shared thread state.\n  if ((void == sharedThreadState) || (null == sharedThreadState)) {\n    logObj.error(\"Received a null or void sharedThreadState.\");\n    return;\n  }\n  if ( !(sharedThreadState instanceof ConcurrentHashMap) ) {\n    logObj.error(\"Received a sharedThreadState that is not a ConcurrentHashMap.\");\n    return;\n  } \n\n  String computerName = InetAddress.getLocalHost().getHostName();\n\n\n  logObj.debug(\"Running on machine: \"+computerName);\n\n  int serverCount = 0;\n\n  if (void != taskServers && null != taskServers)\n  {\n    serverCount = taskServers.size();\n  }\n\n  logObj.debug(\"serverCount: \"+serverCount);\n  logObj.debug(\"serverCount: \"+serverCount);\n  if (serverCount == 0)\n  {\n    logObj.fatal(\"Server Count in args.xml is either set to zero or not properly set. please Correctly indicate the number of task servers and rerun the rule\");\n    logObj.debug(\"Server Count in args.xml is either set to zero or not properly set. please Correctly indicate the number of task servers and rerun the rule\");\n    return;\n  }\n  else if((taskServers.get(computerName)) == null)\n  {\n    logObj.fatal(\"current machine: \"+computerName+\" isn\'t configured to run the cert generation. Modify the args.xml to indicate the index of the server as per readme.txt\");\n    logObj.debug(\"current machine: \"+computerName+\" isn\'t configured to run the cert generation. Modify the args.xml to indicate the index of the server as per readme.txt\");\n    return;\n  }\n\n  //logObj.debug(\"serverCount: \"+serverCount);\n  //logObj.debug(\"TaskServers in args.xml: \"+taskServers);\n  logObj.info(\"TaskServers in args.xml: \"+taskServers);\n\n  int currentIndex = Integer.parseInt(taskServers.get(computerName));\n  //logObj.debug(\"current Index: \"+currentIndex);\n  logObj.info(\"current Index: \"+currentIndex);\n\n  int[] totals = new int[serverCount];\n\n\n	QueryOptions ops = new QueryOptions();\n  //ops.addFilter(Filter.join(\"id\",\"Certification.certificationGroups.id\"));\n  ops.addFilter(Filter.eq(\"phase\",\"Staged\"));\n  ops.setDistinct(true);\n\n  //ops.addFilter(Filter.notnull(\"completed\"));\n  //ops.addFilter(Filter.eq(\"pendingSignoffs\", Integer.valueOf(0)));\n  //ops.addFilter(Filter.or(Filter.isnull(\"expiration\"), Filter.eq(\"expiration\", zero)));\n  //ops.addFilter(Filter.isnull(\"report\"));   // Lets skip the report TaskResults\n  //ops.addFilter(Filter.le(\"created\", threshold));\n  //ops.addFilter(Filter.eq());\n  //ops.addFilter(Filter.like(\"name\",\"20170202\",Filter.MatchMode.ANYWHERE));\n\n\n\n  List props = new ArrayList();\n  props.add(\"id\");\n\n  String tagText = \"\";\n  if(void == config || null == config)\n  {\n\n    tagText = tags!=null?tags:\"\";\n  }\n  else\n  {\n\n    tagText = config.get(\"tags\")!=null?config.get(\"tags\"):\"\";\n\n  }\n\n  logObj.debug(\"tagText: \"+tagText);\n  tagText = tagText.trim();\n  String[] tags = tagText.split(\",\");\n  logObj.debug(\"tags.length: \"+tags.length);\n  if (tags.length > 0 && tagText.length() > 0) \n  {\n\n    for (String tag : tags)\n    {\n      ops.addFilter(Filter.eq(\"tags.name\", tag));\n      logObj.info(\"Added the tag \'\"+tag+\"\' as filter.\");\n    }\n  }\n\n  \n\n\n  logObj.debug(\"Using query filter string : \"+ ops.toString());\n  //logObj.debug(\"Using query filter query : \"+ ops.getQuery());\n\n  \n  Iterator it = context.search(Certification.class, ops, props);\n  //Iterator it = context.search(TaskSchedule.class, ops, props);\n  //Iterator it = context.search(TaskResult.class, ops, props);\n  while (it.hasNext()) \n  {\n\n    //String id = (String)(it.next()[0]);\n    Object [] result = it.next();\n    String id = (String) result[0];\n    //logObj.debug(\"found CG:\"+id);\n    long hashCode = Math.abs(id.hashCode());\n    //logObj.debug(\"hashcode of cg: \"+id+\" is \"+hashCode);\n    int index = Math.abs(hashCode % serverCount);\n\n    if(index == currentIndex)\n    {\n      //logObj.debug(\"hashcode of cg: \"+id+\" is \"+hashCode+ \" and index is \"+index);\n      totals[index]++;\n      workQueue.add(id);\n\n    }\n\n  }\n  \n  sailpoint.tools.Util.flushIterator(it);\n\n  logObj.info(\"no. of workitems in queue: \" + workQueue.size());\n  logObj.info(\"CurrentIndex total: \" + totals[currentIndex]);\n  sharedThreadState.put(\"totalItems\",totals[currentIndex]);\n\n  logObj.debug(\"Completed QueueBuilder Rule.\");\n\n  return;\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd44acb002c',1739425336011,NULL,NULL,NULL,NULL,'SignOff Rule','This rule is run when each access review is signed off by certifier. If any of the certification item (entitlement or account) is revoked by certifier, it goes to secondary sign off work group to final sign off; else if all items are approved, no secondary sign off will be triggered.','beanshell','\n    \n	import sailpoint.object.Certification;\n	import sailpoint.object.CertificationEntity;\n	import sailpoint.object.CertificationItem;\n	import sailpoint.object.CertificationAction;\n	import sailpoint.object.SignOffHistory;\n	import sailpoint.object.Identity;\n	 \n	import java.util.List;\n	import java.util.ArrayList;\n	import java.util.HashMap;\n	import java.util.Map;\n\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	Log log = LogFactory.getLog(\"com.SignOffRule\");\n	log.info(\"Enter SignOff Rule\");\n	 \n	Map results = null;\n	String identityName = \"All Access Admin Workgroup\";\n	Identity signer = context.getObjectByName(Identity.class, identityName);\n \n	if(certification!=null && certifier!=null){\n		List signOffs = certification.getSignOffs();\n		if(signOffs != null && signOffs.size()>1){\n			log.debug(\"Final SignOff already Done!\");\n			return null;\n		}\n\n		if(certification!=null && signer!=null){\n\n			List entities = certification.getEntities();\n			for (CertificationEntity entity : entities){\n				List items = entity.getItems();\n				for (CertificationItem item : items){\n					CertificationAction action = item.getAction();\n					if(action.isRevokeAccount() || action.isRemediation()){\n						log.debug(\"**** Find revoked items*****\");\n						results = new HashMap();\n						results.put(\"identityName\", identityName);\n					}                                            \n				}\n			}\n		}\n	 \n	}\n\n	log.info(\"Exit SignOff Rule\");\n	return results;\n    \n  ','CertificationSignOffApprover',' ',NULL,'Map'),('a9fe0bbd94fd12518194fdd44bd5002d',1739425336277,NULL,NULL,NULL,NULL,'Sticky Cleanup PreRefresh Rule','This rule is used to test the application Connections','beanshell','\n  import sailpoint.api.IdentityService;\n        import sailpoint.object.*;\n        import sailpoint.object.AttributeAssignment;\n        import sailpoint.object.Link;\n        import sailpoint.tools.Util;\n \n		//Identity identity = context.getObject(Identity.class, \"sample user\");\n        // Sniff the AttributeAssignments and look for any pointing to a Link that doesn\'t exist. Set the nativeIdentity to null on said assignment\n        // and let it fall away naturally\n        IdentityService iSvc = new IdentityService(context);\n        boolean dirty = false;\n        List assignments = identity.getAttributeAssignments();\n        if (!Util.isEmpty(assignments)) {\n            for (Object assignmentObj : assignments) {\n                AttributeAssignment assignment = (AttributeAssignment)assignmentObj;\n                Link matched = null;\n                Application assApp = null;\n                if (assignment.getApplicationId() != null) {\n                    assApp = context.getObject(Application.class, assignment.getApplicationId());\n                }\n                String instance = assignment.getInstance();\n                String nativeIdentity = assignment.getNativeIdentity();\n                if (nativeIdentity != null && !\"\".equals(nativeIdentity.trim()) && assApp != null) {\n                    matched = iSvc.getLink(identity, assApp, instance, nativeIdentity);\n                }\n               //as we wanted to clean all attribute assignments if (matched == null) {\n                    assignment.setNativeIdentity(null);\n                    dirty = true;\n               // }\n            }\n        }\n       \n        if (dirty) {\n            context.saveObject(identity);\n            context.commitTransaction();\n        }\n    \n',NULL,' ',NULL,'boolean'),('a9fe0bbd94fd12518194fdd44cd1002e',1739425336529,NULL,NULL,NULL,NULL,'System Account LinkAttribute Rule','This rule is used when promoting account attributes from Links during aggregation.','beanshell','\n  import sailpoint.object.Identity;\n  import sailpoint.object.Link;\n\n	if(link != null){\n		if(link.getAttribute(\"acctSystem\") != null){\n			boolean sysAcct = (boolean) link.getAttribute(\"acctSystem\");\n			if(sysAcct)\n				return true;\n		}\n		Identity identity = link.getIdentity();\n		if(identity != null)\n		{\n			String cofAccountType = (String) identity.getAttribute(\"accountType\");\n			if(cofAccountType != null && \"System\".equals(accountType)){\n				return true;\n			}\n		}\n	}\n	return false;\n	','LinkAttribute',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd45ecb002f',1739425341131,NULL,NULL,NULL,NULL,'WebServiceAfter Operation Rule','This rule is used by the  Web Services connector to update parsed resource object. Create List of Objects  which will later converted to Resource object','beanshell','\n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n	import org.json.simple.JSONArray; \n	import org.json.simple.JSONObject;\n	import org.json.simple.parser.JSONParser; \n	\n	Logger log = Logger.getLogger(\"com.cof.rap.AutomationAnywhere.COF AutiomationAnywhereAfterOperationRule\");  \n	//log.setLevel(Level.DEBUG);  \n	log.debug(\"AFTER::: \" + rawResponseObject);\n	\n	//Get the current amount of recoreds pulled\n	Integer fetchedRecordsCount = 0;\n	if(null != processedResponseObject) \n	{\n		fetchedRecordsCount = ((List) processedResponseObject).size();\n	}\n	\n	//Get the offset and total from the reponse (this total includes the filter search)\n    JSONParser parser = new JSONParser(); \n    JSONObject jsonReponse = (JSONObject) parser.parse(rawResponseObject);\n    JSONObject offsetINFO = jsonReponse.get(\"page\");\n    Long offsetLong = offsetINFO.get(\"offset\");  \n    Long totalFilterLong = offsetINFO.get(\"totalFilter\");   \n    log.debug(\"Current OFFSET\" + offsetLong);	\n    \n    //Is there more?\n    Long newStart = offsetLong + fetchedRecordsCount;\n    boolean hasMore = false;\n    if(newStart < totalFilterLong)\n    {\n    	hasMore = true;\n    }\n    \n    //Set the hasmore flag and store the new offset value...\n	Map transientValues = application.getAttributeValue(\"transientValues\");\n	if(transientValues == null) \n	{\n		transientValues = new HashMap();\n		application.setAttribute(\"transientValues\", transientValues);\n	}\n	transientValues.put(\"hasMore\", hasMore);    \n   \n	if (hasMore) \n	{\n		if(null != offset) \n		{\n			log.debug(\"AFTER RULE: New Offset ==> \" + newStart);\n			transientValues.put(\"offset\", String.valueOf(newStart));\n		}\n	}   \n   \n   ','WebServiceAfterOperationRule',' ',NULL,'Object'),('a9fe0bbd94fd12518194fdd45fd00030',1739425341392,NULL,NULL,NULL,NULL,'WebServiceBeforeOperation rule','This rule is used by the  Web Services connector before performing any operation like testconnection, aggregation etc .','beanshell','\n  \nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\nimport java.util.HashMap;\nimport java.util.Map;\nLogger log = Logger.getLogger(\"cof.Rule.AuditBoardBeforeRule\");\n\nlog.debug(\"***currentbody***\"+  requestEndPoint.getBody().get(\"jsonBody\"));\nlog.debug(\"***oldresponse email***\"+  oldResponseMap.get(\"emails.primary.value\"));\nlog.debug(\"***oldresponse given***\"+  oldResponseMap.get(\"givenName\"));\nlog.debug(\"***oldresponse family***\"+  oldResponseMap.get(\"familyName\"));\n\nString email = oldResponseMap.get(\"emails.primary.value\").toString().replace(\"[\",\"\").replace(\"]\",\"\");\n\n\nString  currentbody = requestEndPoint.getBody().get(\"jsonBody\");\n\ncurrentbody = currentbody.replace(\"plangiven\", oldResponseMap.get(\"givenName\"));\n\ncurrentbody = currentbody.replace(\"planfamily\", oldResponseMap.get(\"familyName\"));\ncurrentbody = currentbody.replace(\"planemail\", email);\n\nlog.debug(\"currentbody after\"+  currentbody);\n\nMap newMap= new HashMap();\n\nnewMap.put(\"jsonBody\", currentbody);\nnewMap.put(\"bodyFormat\", \"raw\");\n\nrequestEndPoint.setBody(newMap);\n\n\nlog.debug(\"final body\"+  requestEndPoint.getBody());\n\nreturn requestEndPoint;\n\n\n','WebServiceBeforeOperationRule',' ',NULL,'EndPoint'),('a9fe0bbd94fd12518194fdd461ce0031',1739425341902,NULL,NULL,NULL,NULL,'WorkItem Forward Rule',NULL,'beanshell','\n        import sailpoint.object.Identity;\n\n		Identity workGroupIdentity = context.getObjectByName(Identity.class, \"Admin\");\n        Identity newOwner = workGroupIdentity;\n\n        String email = owner.getEmail();\n        if ( email == null || email.length() == 0 ) {\n            newOwner = workGroupIdentity;\n        }\n\n\n        return newOwner;\n  ','WorkItemForward',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd471320035',1739425345843,NULL,NULL,NULL,NULL,'SP BeanShell MultiThreading Framework Rule','Multi-Threading Framework for Bean Shell rule code ','beanshell','\n  \n// Library inclusions for BeanShell\nimport java.util.*;\nimport java.lang.*;\nimport java.text.*;\n\nimport java.util.concurrent.LinkedBlockingQueue;  // Thread-safe queue for items.\nimport java.util.concurrent.atomic.AtomicBoolean; // Flags for indicating status.\nimport java.util.concurrent.atomic.AtomicInteger; // Counting records processed.\nimport java.util.concurrent.ConcurrentHashMap;    // Data shared across threads.\n\nimport sailpoint.api.*;\nimport sailpoint.object.*;\nimport sailpoint.tools.Util;\nimport sailpoint.tools.Message;\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\n\n// Keep a time stamp tracking when things got started.\nlong startStamp = System.currentTimeMillis();\n\nLogger log = Logger.getLogger(\"sailpoint.services.BeanShellMultiThreading\");\n// log.setLevel((Level) Level.DEBUG);  // TODO: Remove debug logging in real use.\n\n// Keep a flag around to identify whether this rule is being run inside a Task\n// context or whether it is being run stand-alone from the console ore Debug \n// page.  For 6.3 and newer installs we can use the presence of the variable \n// \'taskResult\' to determine if we are running in task context.\n// We get the taskResult object\'s ID so that the worker threads can load it\n// so they can modify it on their own if necessary.\nString taskResultId = null;\nboolean inTaskContext = false;\nif ((void != taskResult) && (null != taskResult)) {   \n  inTaskContext = true;\n  taskResultId = taskResult.getId();    \n}\n\n// Specify the number of threads that will be used in parallel.  Default to\n// a function of the number of available cores.  Since much of the time is \n// spent on DB transactions,  the number can be significantly higher that the \n// number of cores available\nint numCpuCores = Runtime.getRuntime().availableProcessors(); \nint numWorkerThreads = 2 * numCpuCores;\n\n// Configurable items: Specify the names of two Rule objects.  The first Rule\n// is the rule invoked once per each item to process.  Different copies of this\n// Rule will be invoked in parallel in their own separate Threads with their\n// own separate SailPointContext objects.  As far as the rule is concerned it\n// is simply being passed an item to work on off on its own.  It knows nothing \n// about the other threads in flight at the same time.\n// The second rule is the rule that builds the queue of work item objects.\n// The queue is usually made of String objects, often IDs of some object to\n// process.  The entire queue should fit in RAM, do not fill it with large\n// CLOBs or with fully populated sailpoint.object.* items.  Each worker thread\n// is expected to load whatever data it needs to do its own work.\nstatic String perItemRuleName      = \"BeanShell MultiThreading Example Item Rule\";\nstatic String queueBuilderRuleName = \"BeanShell MultiThreading Example Queue Builder\";\nstatic String initializerRuleName  = \"BeanShell MultiThreading Example Initialization Rule\";\nstatic String cleanupRuleName      = \"BeanShell MultiThreading Example Cleanup Rule\";\n\n// If we are run from the UI/TaskDefintion that means we probably got rule \n// information in from the \"config\" object.  Let\'s see what got passed in.\nif ((void != config) && (null != config)) {\n\n   queueBuilderRuleName = config.get(\"queueBuilderRuleName\");\n   if ((null == queueBuilderRuleName) || (0 == queueBuilderRuleName.length())) {\n      return \"Error: invalid or empty queueBuilderRuleName passed in.\";\n   }\n   \n   perItemRuleName = config.get(\"perItemRuleName\");\n   if ((null == perItemRuleName) || (0 == perItemRuleName.length())) {\n      return \"Error: invalid or empty perItemRuleName passed in.\";\n   }\n   \n   initializerRuleName = config.get(\"initializationRuleName\");\n   if ((null == initializerRuleName) || (0 == initializerRuleName.length())) {\n      // no problem if not specified, this rule is optional.\n      log.warn(\"initializerRuleName is not specified, no init rule to run.\");\n   }\n   \n   cleanupRuleName = config.get(\"cleanupRuleName\");\n   if ((null == cleanupRuleName) || (0 == cleanupRuleName.length())) {\n      // no problem if not specified, this rule is optional.\n   } \n   \n   // This one is totally optional.  The user does not need to specify # threads.\n   String numThreads = config.get(\"numThreadsConfig\");   \n   if ((null != numThreads) && (0 != numThreads.length())) {\n      int tempInt = Integer.parseInt(numThreads);\n      if (0 < tempInt) {\n         // Only use the user-specified number if it is rational and makes sense.\n         numWorkerThreads = tempInt;\n         log.debug(\"Will allocate \" + numWorkerThreads + \" threads per TaskDefinition.\");         \n      }      \n   }\n    \n}\n\nif (inTaskContext) {\n   String ntmsg = \"Configured to use \" + numWorkerThreads + \" worker threads.\"; \n   taskResult.addMessage(new Message(Message.Type.Info, ntmsg, null));\n   context.saveObject(taskResult);         \n} \n\n// Sanity checks: make sure the Rule objects exist. Check by both name and id.\nRule perItemRule = context.getObjectByName(Rule.class, perItemRuleName);\nif (null == perItemRule) {\n   perItemRule = context.getObjectById(Rule.class, perItemRuleName);\n}  \nif (null == perItemRuleName) {\n   String msg = \"Could find load a Rule named: \" + perItemRuleName; \n   log.error(msg);\n   return \"ERROR: \" + msg;\n}\nRule queueBuilderRule = context.getObjectByName(Rule.class, queueBuilderRuleName);\nif (null == queueBuilderRule) {\n   queueBuilderRule = context.getObjectById(Rule.class, queueBuilderRuleName);\n}   \nif (null == queueBuilderRule) {\n   String msg = \"Could find load a Rule named: \" + queueBuilderRuleName; \n   log.error(msg);\n   return \"ERROR: \" + msg;\n}\n\n// A few concurrent-programming enabled variables coordinate traffic between\n// the parent (producer) thread and the worker threads.  \n// First we have a queue that contains the work items to process: \nstatic LinkedBlockingQueue queue = new LinkedBlockingQueue();\n\n// Next we have a boolean that is set to true when/if a worker thread throws\n// an exception.  If this happens all of the worker threads cease processing\n// the queue items entirely and the process aborts/gives up.\nstatic AtomicBoolean workerExceptionFound = new AtomicBoolean(false);\n\n// We also have a boolean that is set to true when the queue builder rule\n// is completed executing. This is a flag to let the worker threads know that\n// the queue is full and complete and will not be receiving any more work \n// items to proces.  If the queue is empty and the queue builder rule is \n// complete then the worker threads know for certain that the they are done\n// and they can safely exit and free up their resources.\nstatic AtomicBoolean queueBuilderComplete = new AtomicBoolean(false);\n\n// A peg counter for how many items the worker threads have processed.\nstatic AtomicInteger itemsProcessed = new AtomicInteger(0);\n\n// A thread-safe hash map that can contain objects shared by all threads.\n// This allows the initializer rule to load lookups tables or cache data used\n// in the per-item rules ahead of time.  It defaults to an empty item map.\nstatic ConcurrentHashMap sharedThreadState = new ConcurrentHashMap();  \n\n\n//  *********************************************************\n//  *        Runable method for spawned threads             *\n//  *********************************************************\n// This this the method that is run by the threads when they are started\n// it pops the workItems off the queue and deletes them one by one.  It passes\n// the workItem strings to the item rule for processing.  It also keeps track\n// of the work queue and flags so that it knows when it is done serching for\n// work to process.\nvoid run () { \n\n try {\n  \n   Logger log = Logger.getLogger(\"sailpoint.services.BeanShellMultiThreading\");\n   log.trace(\"enter run method\");  \n   // Each worker thread gets its own independent context/connection to the\n   // database supporting IdentityIQ.  \n   SailPointContext myContext = SailPointFactory.createContext();\n   \n   // Make sure our per-item rule is available.\n   Rule perItemRuleObj = myContext.getObjectByName(Rule.class, perItemRuleName);\n   if (null == perItemRuleObj) {\n      perItemRuleObj = myContext.getObjectById(Rule.class, perItemRuleName);\n   }  \n   if (null == perItemRuleObj) {\n      log.error(\"Could not find a Rule named: \" + perItemRuleName);\n      workerExceptionFound.set(true);\n   } else if (null == perItemRuleObj.getLanguage()) {\n      // Default to \'beanshell\' language rules if language is not specified.\n      perItemRuleObj.setLanguage(sailpoint.object.Script.LANG_BEANSHELL);\n   }\n   \n   // Each worker thread gets its own independent thread-local cache to\n   // keep \"load once, use many\" types of configuration items.\n   // This is analogous to the \"state\" of the Customizaiton rule used\n   // during account aggregation. \n   HashMap localThreadState = new HashMap();   \n\n   // Worker threads hang around blocked, waiting for an item in queue.\n   // Occasionally worker threads can pull items off of the queue faster than\n   // the prodcer can put them on.  In these cases the worker thread needs\n   // to patiently wait for more work to be put on the queue.\n   while (true) {\n  \n      String workItem = null;\n  \n      // See if another worker thread threw an exception indicating failure.\n      // if this happens then all worker threads give up and cease processing.\n      if (true == workerExceptionFound.get()) {          \n         log.debug(\"Another worker thread has failed, stopping processing.\");\n         break; // break out of the while() loop to cleanup logic below.     \n      }\n     \n      // The queue could have been cleared and completed while this thread\n      // has been yielding or off processing other work.  Check for completion\n      // of the queue builder and if we are done then break to cleanup below.\n      if ( (0 == queue.size()) && (true == queueBuilderComplete.get()) ) {     \n         log.trace(\"queue is empty, builder is complete, time to cleanup.\");\n         break;\n      }\n     \n      // If there is nothing in the queue and the queue builder / producer\n      // has not completed and is still running yield/wait for a small amount\n      // of time to allow the queue buidler to put more work on the queue. \n      if ( (0 == queue.size()) && (false == queueBuilderComplete.get()) ) {     \n         log.trace(\"queue is empty, waiting for more work to arrive.\");\n         Thread.sleep(1000);\n      }\n     \n      workItem = (String) queue.poll();\n      if (null == workItem) {\n          \n        // No work was found on the head of the queue.  It is possible that\n        // other threads adopted all of the work and the queue builder / producer\n        // is still working.  In this event do nothing for a very brief period\n        // of time by yielding and then going back to the start of the while().\n        Thread.sleep(1);\n            \n      } else {\n      \n          // A work item was found on the head of the queue!  \n         // We have a valid workItem string, pass it to the Rule.   \n              \n         HashMap ruleArgs = new HashMap();\n         ruleArgs.put(\"workItem\", workItem);  // Pass in the thing to work on.\n         ruleArgs.put(\"log\",      log);       // Pass in the local log object.\n         ruleArgs.put(\"localThreadState\", localThreadState); // Thread state.\n         ruleArgs.put(\"sharedThreadState\", sharedThreadState); // Global state.\n         \n         // This local context has to load the TaskResult in its own hibernate\n         // session.  So we load it by ID from string.\n         if ((inTaskContext) && (null != taskResultId)) {\n            //TaskResult myTaskResult = myContext.getObjectById(TaskResult.class, taskResultId);\n            ruleArgs.put(\"taskResultId\", taskResultId); \n            //taskResult = myTaskResult;\n         }  \n         \n         // Rules can explode, catch any exceptions and terminate the\n         // worker thread so the rule can stop and be debugged.  This is also\n         // used to tell the other worker threads to stop and give up.\n         try {         \n            \n            Object retObj = myContext.runRule(perItemRuleObj, ruleArgs, perItemRuleObj.getReferencedRules());\n            \n            // We successfully processed this item, increment the peg counter.\n            itemsProcessed.getAndIncrement();\n            \n         } catch (Exception e) {\n\n            // Set the workerExceptionFound flag to true so that other \n            // worker threads cease their execution as well and stop processing.\n            workerExceptionFound.set(true);\n\n            // Upon an exception \"scream and jump overvoard!\".  Or politely\n            // log the exception that happned in the rule and cleanup our\n            // conext and exit gracefully.\n            log.error(\"Item rule threw an exception\" ,e);\n            \n            // The taskResult object is shared with the parent thread and worker\n            // threads.  This means it has no native atomic/blocking protection.\n            // Allow only one worker thread to update the TaskResult at a time.\n            if (inTaskContext) synchronized (this) {\n               Map ops = new HashMap();\n               ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n               thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops);        \n               thisResult.addException(e);\n               context.saveObject(thisResult);        \n               context.commitTransaction();  \n               context.unlockObject(thisResult);               \n            }\n            \n            // Cleanup the worker thread\'s SailPoint context.\n            myContext.rollbackTransaction();\n            myContext.decache();\n            myContext.close();\n            myContext = null;\n            \n            // Cleanup any locally allocated storage.\n            localThreadState.clear();\n            localThreadState = null;\n            \n            return;            \n         }         \n     \n     } // end else() when we have a valid workItem.\n  \n  } // end the while(true) loop polling for workItems to adopt.\n  \n  // The item rules are responsible for their own committing of data to the\n  // SailPointContext handle.  Any un-commited data left at this point is \n  // purged out in the decache call.\n  try {\n    // Cleanup any locally allocated storage.\n    localThreadState.clear();\n    localThreadState = null;  \n  \n    myContext.decache();\n    myContext.close();\n    myContext = null;\n  } catch (Exception e){\n    log.error(\"Worker thread exception during cleanup\",e);\n    myContext.rollbackTransaction();\n    myContext.decache();\n  }\n  \n } catch (Exception e) {\n    log.error(e);\n    log.error(e.printStackTrace());\n }\n log.trace(\"exit run\"); \n return;  \n}\n\n//*********************************************************\n//        Main logic of Framework Rule\n//*********************************************************\n\n// Start off by launching the initializer rule.  This rule sets up the any\n// shared data that the per-item rules need already loaded in memory and/or\n// does any one-time setup.  This is an optional rule; if not specified simply\n// do not execute it.\n\nif ((null == initializerRuleName) || (0 == initializerRuleName.length())) {\n\n   log.debug(\"Empty initializerRuleName passed, skipping init rule.\");   \n\n} else {\n  /*SailPointContext myContext = SailPointFactory.createContext();\n  SailPointContext tempContext = context;\n  context = myContext;*/\n   log.trace(\"Launching init rule\");\n   Rule initRule = context.getObjectByName(Rule.class, initializerRuleName);\n   if (null == initRule) {\n      initRule = context.getObjectById(Rule.class, initializerRuleName);   \n   }\n   \n   if (null == initRule) {\n      String m = \"Could not find or load initialization rule: \" + initializerRuleName; \n      log.error(m);\n      if (inTaskContext) {\n        taskResult.setProgress(m);\n        taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n        context.saveObject(taskResult);        \n        context.commitTransaction();  \n      }\n      return \"ERROR: \" + m;         \n   }\n   \n   log.debug(\"Framework will run init rule: \" + initRule.getName());\n   \n   try {\n   \n      HashMap ruleArgs = new HashMap();\n      ruleArgs.put(\"workQueue\", queue); // Pass in reference to the work queue.\n      ruleArgs.put(\"log\",       log); // Pass in the local log object.\n      ruleArgs.put(\"sharedThreadState\", sharedThreadState); // Shared state.     \n      if (inTaskContext) ruleArgs.put(\"taskResult\", taskResult); // IIQ 6.3+.\n   \n      Object retObj = context.runRule(initRule, ruleArgs, null);\n         \n   } catch (Exception e) {\n   \n      log.error(\"Initialization rule threw exception \", e);\n      \n      if (inTaskContext) {\n        taskResult.setProgress(\"Initialization rule threw exception\");\n        taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n        context.saveObject(taskResult);        \n        context.commitTransaction();  \n      }\n      return \"ERROR: Initialization rule threw exception\";\n                        \n   } /*finally {\n       context = tempContext;       \n       myContext.decache();\n       myContext.close();\n       myContext = null;\n   }*/\n\n}\n\n// Proceed by launching the worker threads.  We do this first, that is we \n// launch the worker threads so they are ready and waiting in the background\n// for the work to be added to the queue.  This allows the worker threads\n// to be doing work while the queue builder / producer is populating new\n// items in the queue.\nlog.trace(\"Starting worker threads\");\nArrayList threadList = new ArrayList();\nint partNumber = 0;\nfor (int i = 0; i < numWorkerThreads; i++){\n    Thread thread = new Thread (this, \"BeanShellThread-\"+i);\n    threadList.add(thread);\n    thread.start();              \n}\n\nlog.trace(\"Calling queue rule\");\n// Next proceed by running the queue builder rule.\nHashMap ruleArgs = new HashMap();\nruleArgs.put(\"workQueue\", queue);  // Pass in reference to the work queue.\nruleArgs.put(\"log\",       log);    // Pass in the local log object.\nruleArgs.put(\"sharedThreadState\", sharedThreadState); // Shared state.\nif (inTaskContext) ruleArgs.put(\"taskResult\", taskResult); // IIQ 6.3+.\n         \n// Rules can explode, catch any exceptions and terminate the\n// worker thread so the rule can stop and be debugged.\n\n/*SailPointContext myContext = SailPointFactory.createContext();\nSailPointContext tempContext = context;\ncontext = myContext;\n*/\n\nlong queueBuilderStartStamp = System.currentTimeMillis(); \ntry {         \n\n   Object retObj = context.runRule(queueBuilderRule, ruleArgs, null);\n   queueBuilderComplete.set(true);\n   \n} catch (Exception e) {\n\n   // If any workers are running we need them to stop ASAP.  Tell then both\n   // that the queue builder is complete and that there was a worker thread \n   // problem.  This makes the worker threads stop on the next record.\n   queueBuilderComplete.set(true);\n   workerExceptionFound.set(true);\n   \n   // Give the worker threads a moment to shut themselves down.  They will\n   // be polling and see the workerExceptionFound flag and stop. \n   Thread.sleep(1500);   \n\n   // Upon an exception politely log the exception that happned in the rule \n   // and give up entirely.  No work queue means no work for the threads to do.\n   String msg = \"Queue builder threw exception \";\n   log.error(msg, e);\n   if (inTaskContext) {\n      taskResult.setProgress(msg);\n      taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n      context.saveObject(taskResult);        \n      context.commitTransaction();  \n   }   \n   return;\n                  \n} /*finally {\n   context = tempContext;       \n   myContext.decache();\n   myContext.close();\n   myContext = null;\n} */\nlog.trace(\"finished calling queueBuilder\");\n\nlong queueBuilderEndStamp = System.currentTimeMillis();\n\ntry {\n  if (inTaskContext) {\n\n     long queueTime = queueBuilderEndStamp - queueBuilderStartStamp;\n     String qbmsg = \"Queue builder ran for \" + (queueTime / 1000) + \" seconds.\";\n     \n     Map ops = new HashMap();\n     ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n     thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops);        \n     thisResult.addMessage(new Message(Message.Type.Info, qbmsg, null));\n     context.saveObject(thisResult);        \n     context.commitTransaction();  \n     context.unlockObject(thisResult);\n  }  \n} catch (Exception e){\n  log.error(\"Caught exception when updating taskresult after queueBuilder ran\",e);\n}\n\nlog.trace(\"Monitoring worker threads\");\n// The queue is complete and populated.  Now we sit here and watch the \n// worker threads to process the items in the queue.\nint wqSize = queue.size();\ntry {  \n  while ( (0 != wqSize) && (false == workerExceptionFound.get()) ) {\n\n     if (true == workerExceptionFound.get()) {\n        String msg = \"One or more worker threads experienced failure.\";\n        log.error(msg);\n        if (inTaskContext) {\n           Map ops = new HashMap();\n           ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n           thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops); \n           thisResult.setProgress(msg);\n           thisResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n           thisResult.addMessage(new Message(Message.Type.Error, msg, null));\n           context.saveObject(thisResult);        \n           context.commitTransaction();  \n           context.unlockObject(thisResult);  \n        }\n        return \"ERROR: \" + msg;     \n     }\n\n     String msg = \"Executing, workQueue contains \" + wqSize + \" items remaining.\"; \n     log.debug(msg);\n     if (inTaskContext) {\n        Map ops = new HashMap();\n        ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n        thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops);        \n        thisResult.setProgress(msg);\n        context.saveObject(thisResult);        \n        context.commitTransaction();  \n        context.unlockObject(thisResult);\n     }  \n     Thread.sleep(2500);\n     wqSize = queue.size();\n  }\n} catch (Exception e){\n  log.error(\"caught exception while monitoring queue\",e);\n}\n\n// The worker threads are complete.  Close out the worker threads.\nfor (Thread thisThread : threadList){\n    thisThread.join();\n}\nthreadList = null;\n\n\n// Run a cleanup rule to release any shared resources used by the threads.\nif ((null != cleanupRuleName)  && (0 != cleanupRuleName.length())) {\n   log.trace(\"Launching cleanup rule\");\n   Rule cleanupRule = context.getObjectByName(Rule.class, cleanupRuleName);\n   if (null == cleanupRule) {\n      cleanupRule = context.getObjectById(Rule.class, cleanupRuleName);   \n   }\n   \n   if (null == cleanupRule) {\n      String msg = \"Could not find or load cleanup rule: \" + cleanupRuleName; \n      log.error(m);\n      if (inTaskContext) {\n           Map ops = new HashMap();\n           ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n           thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops); \n           thisResult.setProgress(msg);\n           thisResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n           thisResult.addMessage(new Message(Message.Type.Error, msg, null));\n           context.saveObject(thisResult);        \n           context.commitTransaction();  \n           context.unlockObject(thisResult);  \n      }\n      return \"ERROR: \" + m;         \n   }\n   \n   try {\n   \n      HashMap ruleArgs = new HashMap();\n      ruleArgs.put(\"log\",       log); // Pass in the local log object.\n      ruleArgs.put(\"sharedThreadState\", sharedThreadState); // Shared state.     \n      if (inTaskContext) ruleArgs.put(\"taskResult\", taskResult); // IIQ 6.3+.\n   \n      Object retObj = context.runRule(cleanupRule, ruleArgs, null);\n         \n   } catch (Exception e) {\n   \n      log.error(\"Cleanup rule threw exception \", e);\n      \n      if (inTaskContext) {\n           String msg = \"Cleanup rule threw exception\";\n           Map ops = new HashMap();\n           ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n           thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops); \n           thisResult.setProgress(msg);\n           thisResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n           thisResult.addMessage(new Message(Message.Type.Error, msg, null));\n           context.saveObject(thisResult);        \n           context.commitTransaction();  \n           context.unlockObject(thisResult);   \n      }\n      return \"ERROR: Cleanup rule threw exception\";\n                        \n   }\n\n}\n\n// Time stamp for when all the work is officially done.\nlong endStamp = System.currentTimeMillis();\n\n// Mark the taskResult accordingly if we had a worker thread fail in processing.\nif (true == workerExceptionFound.get()) {\n   String msg = \"One or more worker threads experienced failure.\";\n   log.error(msg);\n   if (inTaskContext) {\n           Map ops = new HashMap();\n           ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n           thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops); \n           thisResult.setProgress(msg);\n           thisResult.setCompletionStatus(TaskResult.CompletionStatus.Error);\n           thisResult.addMessage(new Message(Message.Type.Error, msg, null));\n           context.saveObject(thisResult);        \n           context.commitTransaction();  \n           context.unlockObject(thisResult);\n   }\n   return \"ERROR: \" + msg;     \n}\n\n// And we are done.\nlog.debug(\"All \" + numWorkerThreads + \" worker threads completed and released.\");\n\nif (inTaskContext) {\n   Map ops = new HashMap();\n   ops.put(context.LOCK_TYPE, context.LOCK_TYPE_TRANSACTION);\n   thisResult = context.lockObjectById(TaskResult.class,taskResultId,ops); \n   \n   String msg = \"Success, all worker threads completed.\";\n   thisResult.setProgress(msg);\n   thisResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n   \n   String ipmsg = \"Total number of items processed: \" + itemsProcessed.get(); \n   thisResult.addMessage(new Message(Message.Type.Info, ipmsg, null));\n   \n   long totalTime = endStamp - startStamp;\n   String ttmsg = \"Total task ran for \" + (totalTime / 1000) + \" seconds.\";\n   thisResult.addMessage(new Message(Message.Type.Info, ttmsg, null));\n   \n   String rpsmsg = \"Total aggregate throughput was \" + \n      (itemsProcessed.get() / (totalTime / 1000)) + \" records per second (r/s).\";\n   thisResult.addMessage(new Message(Message.Type.Info, rpsmsg, null));\n   \n   String rstmsg = \"By-thread throughput was \" + \n      (itemsProcessed.get() / (totalTime / 1000) / numWorkerThreads) + \n      \" records per second per thread (r/s/t).\";\n   thisResult.addMessage(new Message(Message.Type.Info, rstmsg, null));     \n   \n   context.saveObject(thisResult);        \n   context.commitTransaction();  \n   context.unlockObject(thisResult);\n\n}  \n\nreturn \"Success\";\n   \n  ','BuildMap',' ',NULL,NULL),('a9fe0bbd94fd12518194fdd476ea003e',1739425347307,NULL,NULL,NULL,NULL,'IIQDB Performance Test','A Rule to evaluate DB Performance in the system.','beanshell','\n    // ---\n// This rule tests database transaction speed storing records of various sizes.\n// This includes records of 1k, 4k, and 8k in database size.  This will show\n// any transaction or payload size variations that show in the environment.\n\nimport java.lang.StringBuilder;\nimport java.util.*;\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\n\nimport sailpoint.api.Meter;\nimport sailpoint.api.Meter.MeterSet;\nimport sailpoint.api.Terminator;\nimport sailpoint.tools.Message;\n\nimport sailpoint.Version;\n\nimport sailpoint.object.Custom;\nimport sailpoint.object.Filter;\nimport sailpoint.object.QueryOptions;\n\nLogger log = Logger.getLogger(\"com.sailpoint.IIQDBPerformanceTest\");\n\nMeter.reset();\n\n// Note: only force this to debug when editing.  Otherwise leave it at warning.\nlog.setLevel((Level) Level.WARN);\nlog.setLevel((Level) Level.DEBUG);\n\n// Release time/date stamp for feature tracking.\nString dbPerfTestVersion = \"20151218\";\n\nlog.debug(\"Inside Rule: IIQDBPerformanceTest - \" + dbPerfTestVersion); \n\n// The number of records to test each size transaction with.  Don\'t tinker\n// with this number in the field of you want to maintain like-for-like test\n// results with other results published by SailPoint.\nint numRecords = 1000;\n\n// Keep a flag around to identify whether this rule is being run inside a Task\n// context or whether it is being run stand-alone from the console ore Debug \n// page.  For 6.3 and newer installs we can use the presence of the variable \n// \'taskResult\' to determine if we are running in task context.\nboolean inTaskContext = false;\nif ((void != taskResult) && (null != taskResult)) {   \n  inTaskContext = true;    \n}\n\n/**\n * Helper function to handle setting statuses of the TaskResult.\n */\npublic void setProgress (String progMsg) {\n\n   log.debug(progMsg);\n\n   if ( !inTaskContext ) {\n      return;  // Short circuit out of run from the console.\n   }\n   \n   taskResult.setProgress(progMsg);\n   context.saveObject(taskResult);        \n   context.commitTransaction();      \n\n}\n\n/**\n * Helper function to handle output of Info messages to the TaskResult.\n */\npublic void logOutput (String msg) {\n\n   System.out.println(msg);\n   log.debug(msg);   \n   \n   if ( !inTaskContext ) {\n      return;  // Short circuit out of run from the console.\n   }\n   \n   taskResult.addMessage(new Message(Message.Type.Info, msg , null));\n   context.saveObject(taskResult);      \n\n}\n\n/**\n * Generate a pseudo-random string of a specified length.\n * @param length\n * @return String containing the new string/password.\n */\npublic static String generateString(int length) {\n	\n	static Random r = new Random();\n	StringBuilder newPass = new StringBuilder();\n	\n	for (int i=0; i<length; i++) {\n		char c = \'x\';\n		\n		// first character of password can not be number;\n		int charTypeSeed = r.nextInt((i==0 ? 2 : 3));\n		switch (charTypeSeed) {\n		case 0:\n			// Generate a capital letter.\n			c = (char) (65 + r.nextInt(26));\n			break;\n		case 1:\n			// Generate a lower case letter\n			c = (char) (97 + r.nextInt(26));\n			break;\n		case 2:\n			// Generate a number character\n			c = (char) (48 + r.nextInt(10));\n			break;				\n		}\n		newPass.append(c);\n	}\n	\n	return newPass.toString();		\n}\n\n// Get some metadata for the performance report.\nString hostName = java.net.InetAddress.getLocalHost().getHostName();\njava.util.Date nowDate = new java.util.Date();\nString nowTimeStamp = (new java.sql.Timestamp(nowDate.getTime())).toString();\nString iiqVersion = Version.getFullVersion();\n\nlogOutput(\"IdentityIQ Database Performance Test\");\nlogOutput(\"IdentityIQ Version: \" + iiqVersion);\nlogOutput(\"DB Performance Test Rule version: \" + dbPerfTestVersion);\nlogOutput(\"Executed from Host: \" + hostName);\nlogOutput(\"Executed on Date: \" + nowTimeStamp);\n\n// HashMaps to store the data sets.\nHashMap dataSet1k = new HashMap();\nHashMap dataSet4k = new HashMap();\nHashMap dataSet8k = new HashMap();\n\nlogOutput(\"HashMap data sets allocated.\");\n\n// Generate the data sets to load.  We randomly generate strings of 1k, 4k, 8k in length.\nString dMsg = \"Populating 1k, 4k, 8k data set HashMaps for \" + numRecords + \" records...\";\nsetProgress(dMsg);\n\nMeter.enterByName(\"Generate-IIQDB-Test-DataSets\");\n\nfor (int i=0; i < numRecords; i++) {\n\n   String key1k = \"record1k-\" + i;\n   String val1k = generateString(1024);\n   dataSet1k.put(key1k, val1k);\n   \n   log.trace(\"key:\" + key1k + \" -- \" + val1k);\n   \n   String key4k = \"record4k-\" + i;\n   String val4k = generateString(4096);\n   dataSet4k.put(key4k, val4k);\n   \n   log.trace(\"key:\" + key4k + \" -- \" + val4k);\n   \n   String key8k = \"record8k-\" + i;\n   String val8k = generateString(8192);\n   dataSet8k.put(key8k, val8k);\n   \n   log.trace(\"key:\" + key8k + \" -- \" + val8k); \n\n}\n\nMeter.exitByName(\"Generate-IIQDB-Test-DataSets\");\n\nsetProgress(\"Data set HashMaps populated.\");\n\nsetProgress(\"Testing 1k data set...\");\n\nMeter.enterByName(\"IIQDB-Test-DataSet-1k-All\");\nfor (String k : dataSet1k.keySet()) {\n   Meter.enterByName(\"IIQDB-Test-DataSet-1k-Item\");\n   // A sailpoint \"Custom\" object to store items in the database under.\n   Custom dbCustom = new Custom();\n   dbCustom.setName(k);\n   dbCustom.put(k, dataSet1k.get(k));\n   context.saveObject(dbCustom);\n   context.commitTransaction();\n   Meter.exitByName(\"IIQDB-Test-DataSet-1k-Item\");\n}\nMeter.exitByName(\"IIQDB-Test-DataSet-1k-All\");\nsetProgress(\"Completed 1k data set.\");\n\nsetProgress(\"Testing 4k data set...\");\nMeter.enterByName(\"IIQDB-Test-DataSet-4k-All\");\nfor (String k : dataSet4k.keySet()) {\n   Meter.enterByName(\"IIQDB-Test-DataSet-4k-Item\");\n   Custom dbCustom = new Custom();\n   dbCustom.setName(k);\n   dbCustom.put(k, dataSet4k.get(k));\n   context.saveObject(dbCustom);\n   context.commitTransaction();\n   Meter.exitByName(\"IIQDB-Test-DataSet-4k-Item\");\n}\nMeter.exitByName(\"IIQDB-Test-DataSet-4k-All\");\nsetProgress(\"Completed 4k data set.\");\n\nsetProgress(\"Testing 8k data set...\");\nMeter.enterByName(\"IIQDB-Test-DataSet-8k-All\");\nfor (String k : dataSet8k.keySet()) { // TODO: Fix this line.\n   Meter.enterByName(\"IIQDB-Test-DataSet-8k-Item\");\n   Custom dbCustom = new Custom();\n   dbCustom.setName(k);\n   dbCustom.put(k, dataSet8k.get(k));\n   context.saveObject(dbCustom);\n   context.commitTransaction();\n   Meter.exitByName(\"IIQDB-Test-DataSet-8k-Item\");\n}\nMeter.exitByName(\"IIQDB-Test-DataSet-8k-All\");\nsetProgress(\"Completed 8k data set.\");\n\n// We need to support both newer and older IIQ versions.  The Meter API changed\n// with the 6.2 release of IdentityIQ to have a more thread vs. global control. \nboolean usingIiq62OrNewer = true;\nif ( (iiqVersion.startsWith(\"3.\"))  ||\n     (iiqVersion.startsWith(\"4.\"))  ||\n     (iiqVersion.startsWith(\"5.\"))  ||\n     (iiqVersion.startsWith(\"6.0\")) ||\n     (iiqVersion.startsWith(\"6.1\"))    ) {\n   usingIiq62OrNewer = false;\n}\n\n// We need to support older versions.  The Meter API changed in 6.4 from\n// Meter.print() to Meter.report().\nboolean usingIiq63OrOlder = false;\nif ( (iiqVersion.startsWith(\"3.\"))  ||\n     (iiqVersion.startsWith(\"4.\"))  ||\n     (iiqVersion.startsWith(\"5.\"))  ||\n     (iiqVersion.startsWith(\"6.0\")) ||\n     (iiqVersion.startsWith(\"6.1\")) ||\n     (iiqVersion.startsWith(\"6.2\")) ||\n     (iiqVersion.startsWith(\"6.3\"))    ) {\n   usingIiq63OrOlder = true;\n}       \n \nMeterSet meterSet = null;\nif (usingIiq62OrNewer) {\n   meterSet = Meter.getThreadMeters();\n} else {\n   meterSet = Meter.getEffectiveMeters();\n}\n\n// Helper function to pretty-print a meter string\'s contents.\npublic String buildMeterString(Meter m) {\n\n   StringBuilder sb = new StringBuilder();\n   \n   sb.append(\"Meter \");\n   sb.append(m.getName());\n   sb.append(\": \");\n   sb.append(m.getEntries());\n   sb.append(\" calls, \");\n   sb.append(m.getTotal());\n   sb.append(\" milliseconds, \");\n   sb.append(m.getMin());\n   sb.append(\" minimum, \");\n   sb.append(m.getMax());\n   sb.append(\" maximum, \");\n   sb.append(m.getAverage());\n   sb.append(\" average, top five \");\n   sb.append(m.getMaxDataStringValue());\n   \n   return sb.toString();\n}\n\n// The Meter.print() method was removed in IdentityIQ 6.4.\n// The method has been re-named to Meter.report().\n// Instead we roll our put report now.\nfor (Meter m : meterSet.getMeters()) {   \n   logOutput(buildMeterString(m));\n}\n\n// TODO: Build out summary line by parsing the meters.\nStringBuilder summaryLine = new StringBuilder();\n\n\n \nsetProgress(\"Cleaning up test objects in the database...\");\n\nTerminator termin = new sailpoint.api.Terminator(context);\nQueryOptions opts = new QueryOptions();\nFilter filterCustoms = Filter.like(\"name\", \"record\", Filter.MatchMode.START);\nopts.addFilter(filterCustoms);\n\nlong cleanupStart = System.currentTimeMillis();\ntermin.deleteObjects(Custom.class, opts);\nlong cleanupDone = System.currentTimeMillis();\n\nlong cleanpuDuration = cleanupDone - cleanupStart;\n\nlogOutput(\"Completed cleanup of DB Performance Test records: \" + cleanpuDuration + \" msec.\");\n\nreturn \"Success\";\n    \n// ---\n  ',NULL,' ',NULL,'RemediationItem'),('a9fe0bbd94fd12518194fdd47800003f',1739425347584,NULL,NULL,NULL,NULL,'Sailpoint Sizing Rule',NULL,'beanshell','       \n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.bsf.BSFException;\n\nimport java.util.*;\nimport java.sql.*;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.RuntimeMXBean;\n\n\n\nimport sailpoint.object.*;\nimport sailpoint.tools.GeneralException;\nimport sailpoint.tools.Message;\nimport sailpoint.api.SailPointContext;\nimport sailpoint.api.Scheduler;\nimport sailpoint.api.PersistenceManager;\nimport sailpoint.scheduler.QuartzPersistenceManager;\nimport sailpoint.Version;\nimport sailpoint.server.Environment;\nimport sailpoint.tools.Util;\nimport sailpoint.persistence.ClassPersistenceManager;\nimport sailpoint.persistence.HibernatePersistenceManager;\n\nimport org.hibernate.dialect.Dialect;\n\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\n\nimport org.json.JSONObject;\n\nimport org.quartz.Scheduler;\nimport org.quartz.SchedulerException;\nimport org.quartz.SchedulerMetaData;\nimport org.quartz.impl.StdSchedulerFactory;\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\n\nstatic String driverRuleName = \"Detect OOTB JDBC Drivers\";\n\n    \nString ruleVersion = \"version 20150528\";\n\nString iiqVersion = sailpoint.Version.getFullVersion();\n\n// We need to support both newer and older IIQ versions.  The Meter API changed\n// with the 6.2 release of IdentityIQ to have a more thread vs. global control. \n// also the Util.flushIterator() method did not appear until v6.1 of IIQ.\nboolean usingIiq61OrNewer = true;\nboolean usingIiq62OrNewer = true;\nboolean usingiiq55OrNewer = true;\nif ( (iiqVersion.startsWith(\"3.\"))  ||\n     (iiqVersion.startsWith(\"4.\"))  ||\n     (iiqVersion.startsWith(\"5.\"))  ||\n     (iiqVersion.startsWith(\"6.0\"))    ) {\n   usingIiq61OrNewer = false;\n}  \nif ( (iiqVersion.startsWith(\"3.\"))  ||\n     (iiqVersion.startsWith(\"4.\"))  ||\n     (iiqVersion.startsWith(\"5.\"))  ||\n     (iiqVersion.startsWith(\"6.0\")) ||\n     (iiqVersion.startsWith(\"6.1\"))    ) {\n   usingIiq62OrNewer = false;\n} \nif ( (iiqVersion.startsWith(\"3.\"))  ||\n     (iiqVersion.startsWith(\"4.\"))  ||\n     (iiqVersion.startsWith(\"5.0\"))  ||\n     (iiqVersion.startsWith(\"5.1\")) ||\n     (iiqVersion.startsWith(\"5.2\"))    ) {\n   usingIiq55OrNewer = false;\n}  \n\n\n    public String sizingRule(SailPointContext context, TaskResult taskResult){\n    \n        //Log logger = LogFactory.getLog(\"com.sailpoint.performance.sizingrule\");\n        Logger logger = Logger.getLogger(\"sailpoint.performance.sizingrule\");\n        HashMap jsonOutputHash = new HashMap();\n               \n        // Set up output files\n        File tempJSONfile = File.createTempFile(\"identityIQ-sizing-rule-output\", \".json\"); \n        File tempOutputFile = File.createTempFile(\"identityIQ-sizing-rule-output\", \".txt\");\n        tempJSONfile.deleteOnExit();\n        tempOutputFile.deleteOnExit();      \n       \n        StringBuffer buffOut = new StringBuffer();\n        PrintWriter fileOut = null;\n        PrintWriter jsonFileOut = null;\n\n        try{\n            fileOut = new PrintWriter(tempOutputFile);\n            jsonFileOut = new PrintWriter(tempJSONfile);\n        } catch (FileNotFoundException e) {\n            logger.error(\"FileNotFoundException in SailPoint Sizing Rule\",e);\n            return null;\n        }\n\n        buffOut.append(\"\\nExecuting SailPoint Sizing Rule: \" + ruleVersion + \"\\n\");\n\n        DatabaseVersion dbv = context.getObject(DatabaseVersion.class, \"main\");\n\n        String systemVersion = \"\";\n        String schemaVersion = \"\";\n        String dbinfo = \"\";\n\n        if (dbv != null){          \n            try{\n              systemVersion = dbv.getSystemVersion();\n              if (usingiiq55OrNewer){\n                schemaVersion = dbv.getSchemaVersion();\n              }\n            } catch (Exception e){\n               logger.warn(\"Caught exception when checking DB Version. May be expected in older IdentityIQ version\\n\",e);\n            }\n        }\n\n        Connection con = null;\n        DatabaseMetaData dm = null;\n\n        try {\n            Class.forName(\"sailpoint.api.Scheduler\");\n            con = context.getConnection();\n        } catch (ClassNotFoundException e){\n            con = context.getJdbcConnection();\n        }\n        if (con != null) {\n            dm = con.getMetaData();\n            if (dm != null)\n                dbinfo = dm.getURL();\n        }\n\n        String dbType = dm.getDatabaseProductName();\n\n        Object[] argArray = new Object[3];\n\n        // create Query objects\n\n        Filter filter = null;\n        QueryOptions qo = new QueryOptions();\n\n        // generate our numbers\n        try {\n            int count = 0;\n            Map resultMap = null;\n            int cacheCounter = 0;\n\n            buffOut.append(\"\\n\\nIIQ Installation Statistics\\n\");\n            buffOut.append(\"***************************\\n\");\n\n            \n            \n\n            //***********************************   IDENTITIES   **************************************\n            buffOut.append(\"Identity Statistics:\\n\");\n\n            // get total identities\n            count = countObj(\"sailpoint.object.Identity\",null, context, logger);\n            packArgs(argArray, \"  Total Identities:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identities\", count);           \n            \n\n            // get count of active identities\n            filter = Filter.eq(\"inactive\", false);\n            count = countObj(\"sailpoint.object.Identity\",filter, context, logger);\n            packArgs(argArray, \"  Active Identities:\", count);            \n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"activeIdentites\", count);\n\n            // get a count of inactive identities\n            filter = Filter.eq(\"inactive\", true);\n            count = countObj(\"sailpoint.object.Identity\",filter, context, logger);            \n            packArgs(argArray, \"  Inactive Identities:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"inactiveIdentities\", count);\n\n            // get a count of uncorrelated identities\n            filter = Filter.eq(\"correlated\", false);\n            count = countObj(\"sailpoint.object.Identity\",filter, context, logger);            \n            packArgs(argArray, \"  Uncorrelated Identities:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"uncorrelatedIdentities\", count);\n\n            //get a count of identity snapshots\n            count = countObj(\"sailpoint.object.IdentitySnapshot\",null, context, logger);            \n            packArgs(argArray, \"  Identity Snapshots:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identitySnapshots\", count);\n            \n            // get a count of Active and Correlated (License-applicable) Identities\n            filter = Filter.and(Filter.eq(\"correlated\", true), Filter.eq(\"inactive\", false));\n            count = countObj(\"sailpoint.object.Identity\",filter, context, logger);            \n            packArgs(argArray, \"  License Identities (active+correlated):\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"licenseIdentities\", count);    \n\n            //******************************** IDENTITY ENTITLMENTS ****************************      \n            buffOut.append(\"\\nIdentity Entitlements\\n\");\n\n            //Total IdentityEntitlements in the system\n            count = countObj(\"sailpoint.object.IdentityEntitlement\",null, context, logger);\n            packArgs(argArray, \"  Total IdentityEntitlements:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identityEntitlement\", count);      \n\n            //Get the identities with the largest number of entitlements\n            try{\n                String hqlQuery = \n                  \"select ident.name,count(ent.id) AS numEntitlements from Identity ident \"\n                  + \"inner join ident.identityEntitlements ent group by ident.name order by 2 desc\";\n\n                QueryOptions qo = new QueryOptions();\n                qo.setOrderBy(\"2\");\n                qo.setOrderAscending(false);  \n                qo.setResultLimit(5);\n                \n                Iterator it = context.search(hqlQuery, null, qo);\n                while (it.hasNext()) {\n                   Object [] results = it.next();\n                   String identityName = (String) results[0];\n                   String numEntitlements  = \"\" + results[1];     // string cast\n                   packArgs(argArray, \"  Top 5 entitlement count Identity:\", \n                            identityName +\": \" + numEntitlements);\n                   buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                   jsonOutputHash.put(\"manyLinks-\" + identityName, count);                        \n                   // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n                }\n               \n                    if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }           \n\n            //***********************************  APPLICATIONS  *************************************\n            buffOut.append(\"\\nApplication statistics:\\n\");\n\n            // get a count of applications\n            count = countObj(\"sailpoint.object.Application\",null, context, logger);            \n            packArgs(argArray, \"  Total Applications:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"applications\", count);\n\n            // get a count of applications by connector type\n            buffOut.append(\"  Application number by connector type:\" + \"\\n\");\n            appendHQLQuery(\"select type,count(*) from Application group by type\", buffOut, context, logger);\n            // TODO: maybe include apps by connector type in the JSON output.\n            // TODO: address HQL output formatting\n            \n            //QueryOptions opts = new QueryOptions();\n            ArrayList composites = new ArrayList();\n            composites.add(\"COMPOSITE\");\n            Filter isComposite = Filter.in(\"featuresString\", composites);\n            //opts.addFilter(isComposite);\n            count = countObj(\"sailpoint.object.Application\", isComposite, context, logger);            \n            packArgs(argArray, \"  Composite Applications:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"logicalapplications\", count);\n                       \n            \n\n            //***********************************  LINKS  ********************************************\n            buffOut.append(\"\\nLink statistics:\\n\");\n\n            // get total links\n            count = countObj(\"sailpoint.object.Link\",null, context, logger);            \n            packArgs(argArray, \"  Links:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"accounts\", count);\n            \n            // Find the Identities that have the highest numbers of Link objects.\n            // Identities with more than 50 to 100 links might cause performance\n            // issues.  Those with more than 1000 links will cause performance\n            // issues.\n            /*\n            String sql =\n               \"sql:SELECT idt.name name, count(link.id) numAccounts \" + \n               \"      FROM spt_link link JOIN spt_identity idt \" +\n               \"        ON link.identity_id = idt.id \" + \n               \"     GROUP BY identity_id \" +\n               \"     ORDER BY numAccounts DESC, name ASC\";\n             */\n             \n            String hqlQuery = \n              \"SELECT idt.name, count(link.id) AS numAccounts\" +\n              \"  FROM Identity AS idt JOIN idt.links AS link \" +\n              \" GROUP BY idt.name \" +  \n              \" ORDER BY 2 DESC\";\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n            \n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityName = (String) results[0];\n               String numAccounts  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 link count Identity:\", \n                        identityName +\": \" + numAccounts);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"manyLinks-\" + identityName, count);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n            //***********************************  WORKITEMS  ********************************************\n            buffOut.append(\"\\nWorkitem statistics:\\n\");\n\n            // get total links\n            count = countObj(\"sailpoint.object.WorkItem\",null, context, logger);            \n            packArgs(argArray, \"  WorkItems:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"workitems\", count);\n            \n            // Find the Identities that have the highest numbers of workitem objects.\n                                     \n            String hqlQuery = \"select work.owner.name,count(work.id) from WorkItem as work \" \n                + \"group by work.owner.name order by 2 desc\";\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n            buffOut.append(\"\\n Top 5 workitem count Identity (include workgroups):\\n\");\n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityName = (String) results[0];\n               String numItems  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 workitem count Identity:\", \n                        identityName +\": \" + numItems);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"manyItems-\" + identityName, numItems);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n             //Find the Identities that have the highest numbers of workitem objects - exlude workgroups.\n                                     \n            String hqlQuery = \"select work.owner.name,count(work.id) from WorkItem as work \" \n                + \" where work.owner.workgroup=false group by work.owner.name order by 2 desc\";\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n\n            buffOut.append(\"\\n Top 5 workitem count Identity (exclude workgroups):\\n\");\n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityName = (String) results[0];\n               String numItems  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 workitem count Identity:\", \n                        identityName +\": \" + numItems);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"manyItems-\" + identityName, numItems);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n            //************************* IDENTITY REQUESTS****************************************\n            buffOut.append(\"\\nIdentity Requests:\\n\");\n\n             // get total ldentityRequest\n            count = countObj(\"sailpoint.object.IdentityRequest\",null, context, logger);            \n            packArgs(argArray, \"  IdentityRequest:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identityRequest\", count);\n\n             // get total ldentityRequestItem\n            count = countObj(\"sailpoint.object.IdentityRequestItem\",null, context, logger);            \n            packArgs(argArray, \"  IdentityRequestItem:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identityRequest\", count);\n\n\n            //Find the Identities that have the largest Identity Requests.  \n            //for Oracle we need to use a sql query directly\n            String hqlQuery = null;\n            if (dbType.equalsIgnoreCase(\"Oracle\")){\n              buffOut.append (\"Oracle found\");\n              hqlQuery = \"sql: select req.target_display_name,count(item.id) from spt_identity_request\" \n                + \" req inner join spt_identity_request_item item on req.id=identity_request_id group by \" \n                + \" req.target_display_name order by count(item.id) desc\";\n            } else {                                   \n              buffOut.append (\"Oracle not found\");\n              hqlQuery = \"select req.targetDisplayName,count(item.id) from IdentityRequest \" \n                + \"req inner join req.items item group by req.targetDisplayName order by 2 desc\";\n            }\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n\n            buffOut.append(\"\\n Top 5 identity request size by number of request items:\\n\");\n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityDisplayName = (String) results[0];\n               String numItems  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 identity requests:\", \n                        identityDisplayName +\": \" + numItems);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"largeRequests-\" + identityDisplayName, numItems);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n            //*******************************  WORKGROUPS  ***************************************\n            buffOut.append(\"\\nWorkgroup statistics:\\n\");\n\n            //get total certification groups\n            count = countObj(\"sailpoint.object.Identity\",Filter.eq(\"workgroup\",true), context, logger);            \n            packArgs(argArray, \"  Workgroups:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"workgroups\", count);\n   \n   \n            //*******************************  CERTIFICATIONS  ***************************************\n            buffOut.append(\"\\nCertification statistics:\\n\");\n\n            //get total certification groups\n            count = countObj(\"sailpoint.object.CertificationGroup\",null, context, logger);            \n            packArgs(argArray, \"  CertificationGroups:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"certificationGroups\", count);\n          \n\n            //get total certification items\n            count = countObj(\"sailpoint.object.CertificationItem\",null, context, logger);            \n            packArgs(argArray, \"  CertificationItems:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"certificationItems\", count);\n            \n\n            try{\n\n\n                //get certification schedule names and frequencies\n                List taskList = context.getObjects(TaskSchedule.class, null);\n                buffOut.append(\"\\nTaskSchedule stats:\\n\");\n                Iterator taskItr = taskList.iterator();\n                TaskSchedule taskSchedule = null;\n                int certCount = 0;\n                int accountAggCount = 0;\n                int accountGroupAggCount = 0;\n                int sequentialCount = 0;\n                buffOut.append(\"  Scheduled Items:\\n\");\n                while (taskItr.hasNext()){\n                    Object temp = taskItr.next();\n                    boolean found = false;\n                    \n                    if (temp instanceof TaskSchedule){\n                        taskSchedule = (TaskSchedule) temp;\n                        String arg = taskSchedule.getArgument(\"executor\");\n                        String taskDefID = taskSchedule.getDefinitionId();\n                        //TaskDefinition taskDef = (TaskDefinition) context.getObjectById(TaskDefinition.class,taskDefID);\n                        List cronList = taskSchedule.getCronExpressions();\n                        TaskDefinition executor = (TaskDefinition) context.getObject(TaskDefinition.class,arg);\n\n                        if (cronList != null){\n\n                            if (executor != null){\n\n                                if (executor.getType() == TaskItemDefinition.Type.Certification){\n                                    buffOut.append(\"    Certification: \" + taskSchedule.getName());\n                                    buffOut.append(\"\\n\");\n                                    found = true;\n                                    certCount++;\n                                }                                    \n                                    \n                                if ((executor.getType() == TaskItemDefinition.Type.Generic) && (executor.getArguments().containsKey(\"taskList\"))){\n                                    buffOut.append(\"    Sequential Task: \" + taskSchedule.getName());\n                                    buffOut.append(\"\\n\");\n                                    found = true;\n                                    sequentialCount++;\n                                }\n                                else if (executor.getType() == TaskItemDefinition.Type.AccountAggregation){\n                                    buffOut.append(\"    Account Aggregation: \" + taskSchedule.getName());\n                                    buffOut.append(\"\\n\");\n                                    found = true;\n                                    accountAggCount++;\n                                }\n                                else if (executor.getType() == TaskItemDefinition.Type.AccountGroupAggregation){\n                                    buffOut.append(\"    Account Group Aggregation: \" + taskSchedule.getName());\n                                    buffOut.append(\"\\n\");\n                                    found = true;\n                                    accountGroupAggCount++;\n                                }\n                            }\n\n                            if (found){\n                                buffOut.append(\"      Cron: \");\n                                buffOut.append(cronList.toString());\n                                buffOut.append(\"\\n\");\n                            }\n                        }\n                    }\n                }\n                \n                buffOut.append(\"\\n\");\n                packArgs(argArray, \"  Total Scheduled Certifications:\", certCount);\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n\n                packArgs(argArray, \"  Total Scheduled Account Aggregations:\", accountAggCount);\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                \n                packArgs(argArray, \"  Total Scheduled Account Group Aggregations:\", accountGroupAggCount);\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                \n                packArgs(argArray, \"  Total Scheduled Sequential Tasks:\", sequentialCount);\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                \n                jsonOutputHash.put(\"scheduledCertifications\", certCount);\n                jsonOutputHash.put(\"accountAggCount\", accountAggCount);\n                jsonOutputHash.put(\"accountGroupAggCount\", accountGroupAggCount);\n                jsonOutputHash.put(\"sequentialCount\", sequentialCount);\n            }\n\n\n            catch(Exception e){\n                logger.error(\"Error in TaskSchedule Section\",e);                \n            }\n            \n            \n\n            //***********************************  ROLES  ******************************************\n            buffOut.append(\"\\nRole statistics:\\n\");\n\n            //get total roles\n            count = countObj(\"sailpoint.object.Bundle\",null, context, logger);            \n            packArgs(argArray, \"  Role number:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"totalRoles\", count);\n\n            //get roles broken out by type\n            buffOut.append(\"  Role number by role type:\" + \"\\n\");\n            appendHQLQuery(\"select type,count(*) from Bundle group by type\", buffOut, context, logger);\n\n            //get role types and if they are requestable\n            ArrayList assignableTypes = new ArrayList();\n            buffOut.append(\"  Role types and if they are requestable:\\n\");\n            ObjectConfig bundleConfig = ObjectConfig.getObjectConfig(Bundle.class);\n            Map bundleTypeMap = bundleConfig.getRoleTypesMap();\n            for (Object key  : bundleTypeMap.keySet()){\n                RoleTypeDefinition def = (RoleTypeDefinition) bundleTypeMap.get(key);                \n                packArgs(argArray,\"    \" + def.getName(), def.isAssignable());\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                if (def.isAssignable()) assignableTypes.add(def.getName());\n            }\n            \n            // For the purposes of exporting to the sizing calculator anythign that is assignable\n            // we will call a \"structuralrole\" to match the calculator\'s input.  Anything that \n            // has entitlements like an IT role we will call an \"entitlementrole\", again to match\n            // the calculator\'s input.\n            // TO Populate: structuralroles, entitlementroles \n            if (assignableTypes.size() > 0){\n	            qo = new QueryOptions();\n	            Filter onlyAssignables = Filter.in(\"type\", assignableTypes);\n	            qo.addFilter(onlyAssignables);\n	            int assignableCount = context.countObjects(Bundle.class, qo);            \n	            packArgs(argArray, \"  Assignable Roles:\", assignableCount);\n	            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n	            jsonOutputHash.put(\"structuralroles\", assignableCount);\n	            \n	            qo = new QueryOptions();\n	            Filter onlyNonAssignables = Filter.not(Filter.in(\"type\", assignableTypes));\n	            qo.addFilter(onlyNonAssignables);\n	            int nonAssignableCount = context.countObjects(Bundle.class, qo);            \n	            packArgs(argArray, \"  Non-Assignable Roles:\", nonAssignableCount);\n	            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n	            jsonOutputHash.put(\"entitlementroles\", nonAssignableCount);\n            } else {\n            	buffOut.append(\"  No Assignable Role types found\");\n            }\n            \n            //********************************* POLICIES ************************************************\n            buffOut.append(\"\\nPolicy statistics:\\n\");\n            \n            count = countObj(\"sailpoint.object.Policy\",null, context, logger);            \n            packArgs(argArray, \"  Policy number:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"totalPolicies\", count);\n            \n            Filter isActive = Filter.eq(\"state\", \"Active\");\n            count = countObj(\"sailpoint.object.Policy\", isActive, context, logger);            \n            packArgs(argArray, \"  Active policies:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"activePolicies\", count);\n            \n            Filter isInActive = Filter.not(Filter.eq(\"state\", \"Active\"));\n            count = countObj(\"sailpoint.object.Policy\", isInActive, context, logger);            \n            packArgs(argArray, \"  Inactive policies:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"inactivePolicies\", count);\n            \n            ArrayList policyTypes = new ArrayList();\n            policyTypes.add(\"SOD\");\n            policyTypes.add(\"Account\");\n            policyTypes.add(\"Activity\");\n            policyTypes.add(\"Advanced\"); \n            policyTypes.add(\"EntitlementSOD\");\n            \n            for (String policyType : policyTypes) {\n            \n               Filter polType = Filter.eq(\"type\", policyType);\n               count = countObj(\"sailpoint.object.Policy\", polType, context, logger);            \n               packArgs(argArray, \"  \" + policyType + \" policies:\", count);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(policyType + \"Policies\", count);\n            \n            }\n\n            //********************************* LCM *****************************************************\n            buffOut.append(\"\\nLCM statistics:\\n\");\n\n            //get total number of Requests\n            buffOut.append(\"  Requests: \\n\");\n            appendHQLQuery(\"select definition.name,count(*) from Request group by definition.name\",buffOut, context, logger);\n\n            // get a count of Requests          \n            count = countObj(\"sailpoint.object.Request\",null, context, logger);            \n            packArgs(argArray, \"  Total Requests:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"requests\", count);            \n\n            // get a count of IdentityRequest\n            count = countObj(\"sailpoint.object.IdentityRequest\",null, context, logger);            \n            packArgs(argArray, \"  IdentityRequest:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"identityRequests\", count);\n            \n            \n\n            //******************************* Entitlement Catalog ************************************\n            buffOut.append(\"\\nEntitlement Catalog statistics:\\n\");\n\n            //get count of items in entitlement catalog\n            count = countObj(\"sailpoint.object.ManagedAttribute\",null, context, logger);            \n            packArgs(argArray, \"  Entitlement Catalog entries:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"entitlementCatalogItems\", count);\n\n\n            //************************** System Configuration ***********************************************\n            buffOut.append(\"\\nSystem Configuration statistics:\\n\");\n            \n            // Check the ObjectConfig for Identity objects for duplicate extended nubmers.\n            // This happens from time to time when an adminsitrator manually edits the \n            // configuration file and does not take care to make certain extended \n            // numbers end up unique.\n            ObjectConfig ocId = context.getObject(ObjectConfig.class, \"Identity\");\n            HashMap seenExtendedNums = new HashMap();\n            List objAttrs = ocId.getObjectAttributes();\n            for (ObjectAttribute oAttrib : objAttrs) {\n                \n                String oaName = oAttrib.getName();\n                String oaType = oAttrib.getType();\n                \n                int extendedNumber = oAttrib.getExtendedNumber();\n                if (0 == extendedNumber) {\n                   // This extended attribute is not stored in an numbered \n                   // extended column.  Skip it for the puroposes of analysis here.\n                   continue;\n                }\n                \n                String key = oaType + \"-\" + extendedNumber;\n                String val = \"\" + oaName;\n                if (null == seenExtendedNums.get(key)) {\n                   // This is fine, this is the first time we\'ve seen this \n                   // particular key.  Put it in the map of keys we\'ve seen.\n                   seenExtendedNums.put(key, val);                   \n                } else {\n                   // Oops, we\'ve seen this one before!  That\'s bad. This means\n                   // two extended attributes try to share a column number. \n                   String prev = (String) seenExtendedNums.get(key);\n                   String newv = prev + \", \" + val;\n                   seenExtendedNums.put(key, newv);\n                   \n                   packArgs(argArray, \"WARN: IdentityAttributes share extended # \" + key, newv);\n                   buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                   jsonOutputHash.put(\"misconfiguredIdentityAttribs\", newv);                   \n                }\n               \n            }\n            \n\n            //get system configuration then output the relevant attributes\n            Configuration sysConfig = context.getObject(Configuration.class,\"SystemConfiguration\");\n            if (sysConfig != null){\n                Attributes attr = sysConfig.getAttributes();\n                String idSnapInt = attr.getString(\"identitySnapshotInterval\");\n                if (idSnapInt != null){\n                    Integer idSnapIntSec = Integer.parseInt(idSnapInt);                    \n                    packArgs(argArray, \"  identitySnapshotInterval:\", idSnapInt + \" seconds\");\n                    buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                    //convert to days for JSON output\n                    jsonOutputHash.put(\"snapshotfrequency\",idSnapIntSec/86400);\n                }\n                                \n                packArgs(argArray, \"  identitySnapshotMaxAge:\", attr.getString(\"identitySnapshotMaxAge\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"snapshotretention\",attr.getString(\"identitySnapshotMaxAge\"));\n                \n                packArgs(argArray, \"  taskResultMaxAge:\", attr.getString(\"taskResultMaxAge\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"resultretention\",attr.getString(\"taskResultMaxAge\"));\n                \n                packArgs(argArray, \"  identityIndexGranule:\", attr.getString(\"identityIndexGranule\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"idhistorygranularity\",attr.getString(\"identityIndexGranule\"));\n                \n                packArgs(argArray, \"  groupIndexGranule:\", attr.getString(\"groupIndexGranule\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"grouphistorygranularity\",attr.getString(\"groupIndexGranule\"));\n                \n                packArgs(argArray, \"  certificationArchiveMaxAge:\", attr.getString(\"certificationArchiveMaxAge\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"certarchivedeletion\",attr.getString(\"certificationArchiveMaxAge\"));\n\n                packArgs(argArray, \"  certificationMaxAge:\", attr.getString(\"certificationMaxAge\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n                jsonOutputHash.put(\"certretention\",attr.getString(\"certificationMaxAge\"));\n                \n                packArgs(argArray, \"  lcmEnabled:\", attr.getString(\"lcmEnabled\"));\n                buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            }\n\n            \n            \n\n            //*************************** Extended Attributes  *********************************************\n            buffOut.append(\"\\nExtended attribute statistics:\\n\");\n\n            //output the extended attribute count for each of the objects            \n            packArgs(argArray, \"  Extended Identity Attributes:\", getExtendedAttributeCount(Identity.class));\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n\n            packArgs(argArray, \"  Extended Bundle Attributes:\", getExtendedAttributeCount(Bundle.class));\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n\n            packArgs(argArray, \"  Extended Link Attributes:\", getExtendedAttributeCount(Link.class));\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n\n            packArgs(argArray, \"  Extended Application Attributes:\", getExtendedAttributeCount(Application.class));\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n\n            packArgs(argArray, \"  Extended ManagedAttribute Attributes:\", getExtendedAttributeCount(ManagedAttribute.class));\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            \n\n            //************************** Archived Items **********************************************\n            buffOut.append(\"\\nArchived Item Counts:\\n\");\n\n            //get counts of various archived items related to certifications\n            count = countObj(\"sailpoint.object.ArchivedCertificationEntity\",null, context, logger);            \n            packArgs(argArray, \"  Archived Certification Entities:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"ArchivedCertificationEntity\", count);\n\n            count = countObj(\"sailpoint.object.ArchivedCertificationItem\",null, context, logger);            \n            packArgs(argArray, \"  Archived Certification Items:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"ArchivedCertificationItem\", count);\n\n            count = countObj(\"sailpoint.object.CertificationArchive\",null, context, logger);            \n            packArgs(argArray, \"  Certification Archives:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"CertificationArchive\", count);\n\n            //************************** Scopes ******************************************\n            buffOut.append(\"\\nScope Counts:\\n\");\n\n            count = countObj(\"sailpoint.object.Scope\",null, context, logger);            \n            packArgs(argArray, \"  Scopes:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"Scope\", count);\n\n\n            // Find the Identities that have the highest numbers of controlled Scope objects.\n            String hqlQuery = \n              \"select ident.name,count(sc.id) from Identity ident inner join \" \n              + \"ident.controlledScopes sc group by ident.name order by 2 desc\";\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n            \n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityName = (String) results[0];\n               String numEvents  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 controlled scope count Identity:\", \n                        identityName +\": \" + numEvents);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"manyScopes-\" + identityName, numEvents);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n\n            //************************* Audit Logs ***************************************\n            buffOut.append(\"\\nAudit Counts:\\n\");\n\n            count = countObj(\"sailpoint.object.AuditEvent\",null, context, logger);            \n            packArgs(argArray, \"  Audit Events:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"AuditEvent\", count);\n\n            // Find the Identities that have the highest numbers of AuditEvent objects.    \n            \n             \n            String hqlQuery = \n              \"select audit.source,count(audit.id) from AuditEvent as audit group by audit.source order by 2 desc\";\n            \n            QueryOptions qo = new QueryOptions();\n            qo.setOrderBy(\"2\");\n            qo.setOrderAscending(false);  \n            qo.setResultLimit(5);\n            \n            Iterator it = context.search(hqlQuery, null, qo);\n            while (it.hasNext()) {\n               Object [] results = it.next();\n               String identityName = (String) results[0];\n               String numEvents  = \"\" + results[1];     // string cast\n               packArgs(argArray, \"  Top 5 AuditEvent count Identity:\", \n                        identityName +\": \" + numEvents);\n               buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n               jsonOutputHash.put(\"manyEvents-\" + identityName, numEvents);                        \n               // System.out.println(\" id:\" + identityName + \"  links:\" + numAccounts);\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n\n            //************************ SysLog ********************************************\n            buffOut.append(\"\\nSyslog Counts:\\n\");\n\n            count = countObj(\"sailpoint.object.SyslogEvent\",null, context, logger);            \n            packArgs(argArray, \"  Syslog Events:\", count);\n            buffOut.append(String.format(\"%-50s %20s%n\", argArray));\n            jsonOutputHash.put(\"SyslogEvent\", count);\n\n            //*********************** About **********************************************\n            buffOut.append(\"\\nAbout command:\\n\");\n\n            // we have to mimic the about command from iiq console since we already have a context\n\n            \n\n            //moving DB connection stuff up higher in the rule. This is necessary since we need to check if the system is Oracle\n            //and alter some queries in that case\n\n            buffOut.append(\"               Version: \" + Version.getFullVersion() + \"\\n\");\n            buffOut.append(\"        System Version: \" + systemVersion + \"\\n\");\n            buffOut.append(\"        Schema Version: \" + schemaVersion + \"\\n\");\n            buffOut.append(\"       Source Revision: \" + Version.getRevision() + \"\\n\");\n            buffOut.append(\"  Source Repo Location: \" + Version.getRepoLocation() + \"\\n\");\n            buffOut.append(\"               Builder: \" + Version.getBuilder() + \"\\n\");\n            buffOut.append(\"            Build Date: \" + Version.getBuildDate() + \"\\n\");\n            buffOut.append(\"      Application Home: \" + Util.getApplicationHome() + \"\\n\");\n            buffOut.append(\"              Database: \" + dbinfo + \"\\n\");\n            buffOut.append(\"\\n\");\n            buffOut.append(\"                  Host: \" + Util.getHostName() + \"\\n\");\n            buffOut.append(\"           Free Memory: \" +\n                           Util.memoryFormat(Runtime.getRuntime().freeMemory()) + \"\\n\");\n            buffOut.append(\"          Total Memory: \" +\n                           Util.memoryFormat(Runtime.getRuntime().totalMemory()) + \"\\n\");\n            buffOut.append(\"            Max Memory: \" +\n                           Util.memoryFormat(Runtime.getRuntime().maxMemory()) + \"\\n\");\n            buffOut.append(\"\\n\");\n            buffOut.append(\"  Available processors: \" + \n                                      Runtime.getRuntime().availableProcessors() + \"\\n\");\n\n            Environment env = Environment.getEnvironment();\n\n            // have to change this method to handle pre 6.2 vs. post\n            getSchedulerStatus(env,buffOut);\n\n            RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n            List arguments = runtimeMxBean.getInputArguments();\n            Map sysProps = runtimeMxBean.getSystemProperties();\n\n            buffOut.append(\"\\nJVM arguments:\\n\");\n            for (String line : arguments){\n              buffOut.append(\"            \" + line + \"\\n\");\n            }\n\n            buffOut.append(\"\\nSystem Properties:\\n\");\n            for (String prop : sysProps.keySet()){\n              buffOut.append(\"            \" + prop + \"=\" + sysProps.get(prop) + \"\\n\");\n            }\n\n\n            //******************* Hibernate Info **********************************************\n\n            buffOut.append(\"\\nHibernate info:\");\n\n            try{\n                PersistenceManager pMgr = context.getPersistenceManager();\n                HibernatePersistenceManager hibPMgr = null;\n\n                if (pMgr instanceof ClassPersistenceManager) {\n                   pMgr = pMgr.getManager(Class.forName(\"sailpoint.object.Identity\"));\n                   hibPMgr = (HibernatePersistenceManager) pMgr;\n                } else if (pMgr instanceof HibernatePersistenceManager) {\n                   hibPMgr = (HibernatePersistenceManager) pMgr;\n                } else {\n                   log.error(\"pMgr is not a hibernate persistence manager.\");\n                   log.error(\"pMgr:\" + pMgr.getClass().toString());                   \n                }\n\n                Dialect dialect = hibPMgr.getDialect();\n                String dialectName = dialect.toString();\n\n                buffOut.append(\"  Hibernate dialect: \" + dialectName + \"\\n\");\n                jsonOutputHash.put(\"hibernateDialect\",dialectName);\n\n            } catch (Exception e){\n                log.error(\"Caught exception when getting hibernate info\", e);\n            }\n\n            //******************* Database Info **********************************************\n\n            buffOut.append(\"\\nDatabase Info:\\n\");\n            buffOut.append(\"  Database type: \" + dm.getDatabaseProductName() + \"\\n\");\n            buffOut.append(\"  Database version: \" + dm.getDatabaseProductVersion() + \"\\n\");\n            buffOut.append(\"  Driver name: \" + dm.getDriverName() + \"\\n\");\n            buffOut.append(\"  Driver version: \" + dm.getDriverVersion() + \"\\n\");\n\n            //************************** Quartz Config *************************************************\n            try {\n                buffOut.append(\"\\nQuartz Configuration Information:\\n\");\n                Scheduler scheduler = QuartzPersistenceManager.getGlobalScheduler();\n                SchedulerMetaData qmd = scheduler.getMetaData();                \n                buffOut.append(\"  Quartz summary: \" + qmd.getSummary() + \"\\n\");\n\n            } catch (SchedulerException e){\n                logger.error(\"Unable to get quartz scheduler\",e);\n            }\n\n\n            //******************* JDBC Driver rule *******************************************\n            Rule driverRule = context.getObjectByName(Rule.class,driverRuleName);\n            if (driverRule != null){\n                String driverRuleResult = context.runRule(driverRule,null);\n\n                buffOut.append(\"\\nJDBC Driver Information:\\n\");\n                buffOut.append(driverRuleResult + \"\\n\");\n            }            \n\n            //************************* Convert and Output Results ***************************\n            \n            org.json.JSONObject jsonObj = new org.json.JSONObject ( jsonOutputHash );\n            \n            buffOut.append(\"\\n\\nSaving json file as: \" + tempJSONfile.getAbsolutePath() + \"\\n\");\n            buffOut.append(\"Saving output file as: \" + tempOutputFile.getAbsolutePath() + \"\\n\");  \n\n            String hostName = java.net.InetAddress.getLocalHost().getHostName();\n            java.util.Date nowDate = new java.util.Date();\n            String nowTimeStamp = (new java.sql.Timestamp(nowDate.getTime())).toString();     \n\n            buffOut.append(\"On host: \" + hostName + \" At time: \" + nowTimeStamp + \"\\n\"); \n\n            //write out to the files\n            fileOut.print(buffOut.toString());\n            fileOut.flush();\n            fileOut.close();\n\n            jsonFileOut.print(jsonObj.toString());\n            jsonFileOut.flush();\n            jsonFileOut.close();\n\n            if ((void != taskResult) && (null != taskResult)) { \n            	   String replaced = buffOut.toString().replace(\'\\n\',\'|\');\n            	   taskResult.addMessage(new Message(Message.Type.Info, replaced, null)); \n            	   /*String[] lineArray = buffOut.toString().split(\"\\n\");\n            	   for (int line = 0; line < lineArray.length; line++){\n                	taskResult.addMessage(new Message(Message.Type.Info, lineArray[line], null)); \n                } */               \n            }\n\n            logger.trace(buffOut.toString());\n\n            return buffOut.toString();\n\n\n        } catch (Exception e) {\n            logger.error(\"Sailpoint Sizing Rule caught an exception\",e);\n            fileOut.println(buffOut.toString());\n            fileOut.flush();\n            fileOut.close();\n            return buffOut.toString();\n        }\n    }\n\n    // getExtendedAttributeCount takes a class that has an ObjectConfig, retrieves it and counts the extended attributes\n    public int getExtendedAttributeCount(java.lang.Class aclass) {\n        int extCount = 0;\n        ObjectConfig config = ObjectConfig.getObjectConfig(aclass);\n        if (config == null)\n            return 0;\n        List objAttrList = config.getObjectAttributes();\n        if (objAttrList == null)\n            return 0;\n        for (Object objAttr : objAttrList){\n            if (objAttr instanceof ObjectAttribute){\n                objAttr = (ObjectAttribute) objAttr;\n                if (((ObjectAttribute) objAttr).isExtended())\n                    extCount++;\n            }\n\n        }\n        return extCount;\n    }\n\n\n    //appendHQLQuery performs an HQL query, parses the result and appends it to the provided buffer\n    public void appendHQLQuery(String query, StringBuffer buffOut, SailPointContext context, Logger logger) {\n        try{\n            Iterator it = context.search(query,null,null);\n            while(it != null && it.hasNext()) {\n                Object current = it.next();\n                if (current instanceof Object[]) {\n                    /*buffOut.append(\"    \");\n                    Object[] array = (Object[]) current;\n                    for (Object o : array) {\n                        if (o != null)\n                            buffOut.append(o.toString() + \"\\t\");\n                    }\n                    buffOut.append(\"\\n\");*/\n                    buffOut.append(String.format(\"    %-46s %20s\", current));\n                    buffOut.append(\"\\n\");\n                }\n            }\n            try{\n                if (usingIiq61OrNewer) Util.flushIterator(it);\n            } catch (Exception e){\n                //this did not exist in older versions of IIQ\n            }\n        }\n        catch (GeneralException e) {\n            logger.warn(\"Sailpoint Sizing Rule caught an exception in countObj method, this may be caused by an older version of IdentityIQ not having objects added to later versions: \", e);\n            return;\n        }\n    }\n\n    //Send in a filter and an class and get a count of the number of those objects that satisfy the filter\n    public int countObj(String className, Filter filter, SailPointContext context, Logger logger) {\n        try {\n            Class aClass = Class.forName(className);\n            if (filter == null)\n                return context.countObjects(aClass, new QueryOptions());\n            else{\n                QueryOptions qo = new QueryOptions();\n                qo.addFilter(filter);\n                return context.countObjects(aClass, qo);\n            }\n        }\n        catch (org.apache.bsf.BSFException e){\n            logger.error(\"Sailpoint Sizing Rule caught an exception in countObj method: \", e);\n            return -1;\n        }\n        catch (ClassNotFoundException e){\n            logger.warn(\"Sailpoint Sizing rule, countObj method, caught a ClassNotFoundException. This may be expected in some versions of IdentityIQ\", e);\n            return -1;\n        }\n        catch (GeneralException e) {\n            logger.error(\"Sailpoint Sizing Rule caught an exception in countObj method: \", e);\n            return -1;\n        }\n    }\n\n    public void packArgs(Object[] argArray, Object arg1, Object arg2 ){\n        argArray[0]=arg1;\n        argArray[1]=arg2;\n        argArray[2]=\"\\n\";\n    }\n\n    void getSchedulerStatus(Environment env, StringBuffer buffOut) {\n\n        try {\n            Class.forName(\"sailpoint.api.Scheduler\");\n\n            import sailpoint.api.Scheduler;\n\n            Scheduler taskSched = env.getTaskScheduler();\n            Scheduler requestSched = env.getRequestScheduler();\n\n            String taskStatus = \"missing\";  \n            if (taskSched != null) {\n                if (taskSched.isSchedulerRunning())\n                    taskStatus = \"running\";\n                else\n                    taskStatus = \"stopped\";\n            }\n\n            String requestStatus = \"missing\";  \n            if (taskSched != null) {\n                if (taskSched.isSchedulerRunning())\n                    requestStatus = \"running\";\n                else\n                    requestStatus = \"stopped\";\n            }\n\n            buffOut.append(\"        Task Scheduler: \" + taskStatus + \"\\n\");\n            buffOut.append(\"     Request Processor: \" + requestStatus + \"\\n\");\n\n        } catch (ClassNotFoundException e) {\n            import sailpoint.server.HeartbeatService;\n            import sailpoint.server.Service;\n\n            Service taskService = env.getTaskService();\n            Service requestService = env.getRequestService();\n\n            String taskStatus = \"Missing\";\n            if (taskService != null){\n                taskStatus = taskService.getStatusString();\n            }\n\n            String requestStatus = \"Missing\";\n            if (taskService != null){\n                requestStatus = requestService.getStatusString();\n            }\n\n            buffOut.append(\"        Task Scheduler: \" + taskStatus + \"\\n\");\n            buffOut.append(\"     Request Processor: \" + requestStatus + \"\\n\");\n            buffOut.append(\"          Task Threads: \" + HeartbeatService.getQuartzThreads() + \"\\n\");\n            buffOut.append(\"       Request Threads: \" + HeartbeatService.getRequestProcessorThreads() + \"\\n\");\n\n        }        \n    }\n\n\nif (void != taskResult && null != taskResult){	\n	return sizingRule(context,taskResult);\n} else {\n	return sizingRule(context,null);\n}\n\n    ',NULL,' ',NULL,NULL),('a9fe0bbd94fd12518194fdd478f40040',1739425347828,NULL,NULL,NULL,NULL,'Detect OOTB JDBC Drivers','\nA rule to detect if an IdentityIQ installation is still running the factory \ndefault JDBC drivers.  It also checks for certain JDBC driver versions with\nknown errata.  If any of these JDBC driver versions are found an error \nmessage is presented back to the user.  This is both logged and returned\nas a string to the caller so it can be run via the user interface.\n\nNote: SailPoint no longer ships DB2 database drivers so they are not checked. \n  ','beanshell','\n    \nimport java.io.*;\nimport java.util.*;\nimport java.lang.reflect.*;\nimport java.util.jar.Manifest;\nimport java.util.jar.Attributes;\nimport org.apache.commons.io.*;\nimport org.apache.commons.io.FileUtils;\n  \nimport sailpoint.object.Application;\nimport sailpoint.object.ResourceObject;\nimport sailpoint.object.Rule;\nimport sailpoint.object.TaskResult;\nimport sailpoint.connector.Connector;\nimport sailpoint.api.Aggregator;\n\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.Level;\n\n// Force ourselves into INFO level logging.\nLogger log = Logger.getLogger(\"sailpoint.rule.Detect-OOTB-JDBC-Drivers\");\nlog.setLevel(Level.INFO);\n\nString returnString = \"\";\n\n// Build a small in-memory table of the OOTB and Known-Bad versions.\n// Each JDBC driver has a version that we know we shipped out of the box.\n// Each JDBC driver has a List of versions that are known to be bad.\n// The values of the hash maps are in \"fileSize-md5Sum\" format.\n// This way we can compare both size and md5 for a proper match.  \nHashMap knownBadVersions = new HashMap();\nHashMap ootbVersions = new HashMap();\nootbVersions.put(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\", \"583186-002761a1a50ae52dcbc8d1fe713d1965\");\nootbVersions.put(\"com.mysql.jdbc.Driver\",                        \"848401-24a6d6cab39d9fd970e0ee00bd2f9e7c\");\nootbVersions.put(\"oracle.jdbc.driver.OracleDriver\",              \"1536554-df40bba7fa52ac4c77b0c2652172fb71\");\n\n// Put the known-bad versions in here.  Each JDBC driver may have known-buggy\n// or bad versions that were found as a result of support tickets.\n// TODO: Add more known bad JDBC driver versions here. \nArrayList badOraVers = new ArrayList();\nArrayList badSqlVers = new ArrayList();\nArrayList badMysVers = new ArrayList();\nbadOraVers.add(\"2111220-fc074b0027bc6f77a67a4c4aac2f490d\"); // Bad Oracle driver found at NT in May 2013.\n\n\nknownBadVersions.put(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\", badSqlVers);\nknownBadVersions.put(\"com.mysql.jdbc.Driver\",                        badMysVers);\nknownBadVersions.put(\"oracle.jdbc.driver.OracleDriver\",              badOraVers);\n\nArrayList driverClasses = new ArrayList();\ndriverClasses.add(\"com.mysql.jdbc.Driver\");\ndriverClasses.add(\"oracle.jdbc.driver.OracleDriver\");\ndriverClasses.add(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n// driverClasses.add(\"com.microsoft.sqlserver.jdbc.SQLServerDriverZZZ\"); // was test case of bad class.\n\nfor (String driverClass : driverClasses) {\n\n   System.out.println();\n   log.info(\"Examining JDBC driver: \" + driverClass);\n   boolean foundOOTB = false;\n   boolean foundKnownBad = false;\n   \n   try {\n   \n   Class clazz  = Class.forName(driverClass);       \n       \n   String className = clazz.getSimpleName() + \".class\";\n   String classPath = clazz.getResource(className).toString();\n   \n   if (!classPath.startsWith(\"jar\")) {\n      // Class not from JAR file.  It must be comeing from elsewhere.  Punt.\n      log.warn(\"Class not from a jar: \" + className);\n      continue; // go to the next iteration of the for() loop.\n   }\n   \n   System.out.println(\"classPath: \" + classPath);\n   // classPath looks like: jar:file:/Users/adam.hampton/apache-tomcat-6.0.36/webapps/iiq61lab/WEB-INF/lib/sqljdbc-1.2.jar!/com/microsoft/sqlserver/jdbc/SQLServerDriver.class\n   String pathLhs = classPath.split(\"!\")[0];\n   String pathRhs = pathLhs.split(\":file:\")[1];\n   String jarPath = pathRhs;\n   log.info(\"jarPath: \" + jarPath);\n   \n   // Read the size and calculate the MD5 sum for the file.\n   File jarFile = new File(jarPath);\n   long fileSize = jarFile.length();\n   \n   import org.apache.commons.io.IOUtils;\n   FileInputStream fis = new FileInputStream(jarFile);\n   String md5 = org.apache.commons.codec.digest.DigestUtils.md5Hex(IOUtils.toByteArray(fis));  \n   md5 = md5.toLowerCase();\n            \n   log.info(\"file: \" + jarFile);\n   log.info(\"size: \" + fileSize + \" md5: \" + md5);\n   \n   // Check for comparison with OOTB versions of the JDBC driver.\n   String keyString = \"\" + fileSize + \"-\" + md5;\n   \n   String ootbVersion = ootbVersions.get(driverClass);\n   if ((null != ootbVersion) && (keyString.equals(ootbVersion))) {\n      // We have an OOTB version of the JDBC driver that needs to be replaced.\n      String msg = \"WARNING: demonstration version found for \" + driverClass +\n                   \" please upgrade/replace JDBC driver. \\n\" + \n                   \"Driver file path: \" + jarPath + \" \\n\" + \n                   \"Demo driver size and md5 hash: \" + keyString;\n      System.out.println(msg);\n      log.warn(msg);\n      returnString += msg + \"\\n\";\n      foundOOTB = true;\n   }\n   \n   // Check for comparison with known bad versions of the JDBC driver.\n   List knownBads = knownBadVersions.get(driverClass);\n   if (null != knownBads) {\n      if (knownBads.contains(keyString)) {\n         // We have known bad version of the JDBC driver that needs to be replaced.\n         String msg = \"WARNING: known faulty found for \" + driverClass +\n                      \" please upgrade/replace JDBC driver. \\n\" + \n                      \"Driver file path: \" + jarPath + \" \\n\" +\n                      \"Known faulty size and md5 hash: \" + keyString;\n         System.out.println(msg);\n         log.warn(msg);\n         returnString += msg + \"\\n\";   \n         foundKnownBad = true;    \n      }   \n   }\n   \n   // In this case we have some upgraded .jar file in place.\n   if ((!foundOOTB) && (!foundKnownBad)) {\n     String msg = \"Upgraded driver in place for \" + driverClass + \n                  \"\\n   md5 hash: \" + keyString;\n     returnString += msg + \"\\n\";           \n   }\n   \n   /* \n   \n   Dormant / commented out code to dig into a Manifest file.  There is some\n   neat information in the manifest files but it turns out to be useless and\n   non deterministic for determing JDBC driver versions.\n       \n   // A class file might have different cases of manifest file name.  Sloppy, I know.\n   // We can thank the older versions of SQL Server\'s JDBC drivers for this mess.\n   List manifestsList = new ArrayList();\n   String classBase = classPath.substring(0, classPath.lastIndexOf(\"!\") + 1);\n   manifestsList.add(classBase + \"/META-INF/MANIFEST.MF\");\n   manifestsList.add(classBase + \"/META-INF/manifest.mf\");\n   manifestsList.add(classBase + \"/META-INF/Manifest.MF\");\n   manifestsList.add(classBase + \"/META-INF/Manifest.mf\");\n\n   Manifest manifest = null;\n   Attributes attr = null;\n\n   // Search for the manfiest file.\n   for (String manifestPath : manifestsList) {\n      try {        \n         manifest = new Manifest(new URL(manifestPath).openStream());\n      } catch (java.io.FileNotFoundException ex) {\n         // Fall through and try the next manifest path.\n         // System.out.println(\"Manifest not found: \" + manifestPath);\n      }\n   }\n\n   // If we found the manifest file, then do somehting useful with it.\n   if (null != manifest) {\n   \n      attr = manifest.getMainAttributes();\n      \n      for (Object key : attr.keySet()) {\n         String val = attr.getValue(key);\n         if (null != val) val = val.trim();\n         // System.out.println(\" - manifest key: [\" + key.toString() + \"] = [\"+ val + \"]\");\n      }        \n            \n  \n   } else {\n     System.out.println(\"No \'MANFIEST.MF\' file found for: \" + driverClass);\n   } \n   \n   */\n                \n   } catch (ClassNotFoundException e) {\n      log.info(\"No JDBC driver found for: \" + driverClass);\n   }\n\n}\n        \nreturn returnString;\n// ---\n    \n  ',NULL,' ',NULL,'Identity'),('a9fe0bbd94fd12518194fdd47ab70041',1739425348279,NULL,NULL,NULL,NULL,'Sailpoint Report Database Row Counts',NULL,'beanshell','\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.bsf.BSFException;\n\nimport java.util.*;\n\nimport sailpoint.object.*;\nimport sailpoint.tools.GeneralException;\nimport sailpoint.api.SailPointContext;\nimport sailpoint.api.Scheduler;\nimport sailpoint.Version;\nimport sailpoint.server.Environment;\nimport sailpoint.tools.Util;\n\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.ResultSetMetaData;\nimport java.sql.Statement;\nimport java.sql.DatabaseMetaData;\n\n// Use a StringBuilder to accumulate the large amount of output this \n// task produces.  The output is then printed at the end of the run.\nStringBuilder sb = new StringBuilder();\n\n// Keep a flag around to identify whether this rule is being run inside a Task\n// context or whether it is being run stand-alone from the console ore Debug \n// page.  For 6.3 and newer installs we can use the presence of the variable \n// \'taskResult\' to determine if we are running in task context.\nboolean inTaskContext = false;\nif ((void != taskResult) && (null != taskResult)) {   \n  inTaskContext = true;    \n}  \n\n\n// A simple function to return the row counts from a table.  \npublic int getRowCountFromTable (Connection cxn, String tableName) {\n\n	int rowCount = 0;\n	Statement stmt = cxn.createStatement();\n\n	try {	\n		ResultSet res = stmt.executeQuery(\"SELECT COUNT(*) FROM \" + tableName);\n		while (res.next()) {\n			rowCount = res.getInt(1);\n		}\n	} catch (java.sql.SQLSyntaxErrorException ex) {\n	\n	   if (ex.toString().contains(\"ORA-00942\")) {	   \n	      // Silently swallow ORA-00942 errors.\n	      // These don\'t have proper rows, so return zero to caller.	       \n	   } else if (ex.toString().contains(\"ORA-00604\")) {	   \n	      // Silently swallow ORA-00604 errors.\n	      // These don\'t have proper rows, so return zero to caller.	       \n	   } else {	   \n	      // Otherwise report the exception back to the output.\n	      sb.append(ex.toString() + \"\\n\");	   \n	   }\n	\n	} catch (Exception ex) {\n		sb.append(ex.toString() + \"\\n\");\n	} finally {\n	   // Close the SQL Statement regardless of the exceptions seen.\n	   stmt.close();\n	}\n		\n	return rowCount;	\n}\n	\nConnection jdbcConnection = context.getConnection();\nDatabaseMetaData md = jdbcConnection.getMetaData();\nString[] types = {\"TABLE\"};\nResultSet rs = md.getTables(null, null, \"%\", types);\n// ResultSet rs = md.getTables(jdbcConnection.getCatalog(), null, \"%\", types);\n// sb.append(\"Done collecting tables metadata.\\n\");\n\nResultSetMetaData rsmd = rs.getMetaData();\nint columnCount = rsmd.getColumnCount();\n\nHashMap nameToColumnNumberMap = new HashMap();\n\n// The column count starts from 1 for some odd reason here.\nfor (int i = 1; i < columnCount + 1; i++ ) {\n  String columnName = rsmd.getColumnName(i);\n  nameToColumnNumberMap.put(columnName, i);  \n  // System.out.println(\"Column name: \" + columnName);   \n}\n 	 \n// Sloppy parallel arrays, too lazy to invent a new data structure.\nArrayList tabNames    = new ArrayList();\nArrayList tabRowCount = new ArrayList();\n 	 \nwhile (rs.next()) { \n\n   String tableName    = rs.getString(nameToColumnNumberMap.get(\"TABLE_NAME\")); \n   String tableCatalog = rs.getString(nameToColumnNumberMap.get(\"TABLE_CAT\")); \n   String tableSchema  = rs.getString(nameToColumnNumberMap.get(\"TABLE_CAT\"));\n   \n   // sb.append(\"Examining table details for: \" + tableName + \"\\n\");\n   // System.out.println(\"Table : \" + tableName + \"nCatalog : \" + tableCatalog + \"nSchema : \" + tableSchema + \" \");\n	\n   tabNames.add(tableName);\n   tabRowCount.add(getRowCountFromTable(jdbcConnection, tableName));\n\n}\n\nsb.append(\"TABLE                            | ROW COUNT \\n\");\nsb.append(\"--------------------------------------------------\\n\");\nfor (int t = 0; t < tabNames.size(); t++) {\n\n	String tableName = tabNames.get(t);\n	int rowCount = tabRowCount.get(t);\n\n// for (String tableName: talbeToRowCountsHash.keySet()) {\n	//int rowCount = talbeToRowCountsHash.get(tableName);\n	\n	// Make the column widths pretty.\n	int spaceCount = 32 - tableName.length();\n	String spacePad = \"\";\n	for (int i = 0; i < spaceCount; i++) spacePad += \" \";\n	\n	sb.append(\"\" + tableName + spacePad + \" | \" + rowCount + \"\\n\");\n}\n\n\nsb.append(\"\\n\");\n\n// For now this only works for Oracle\nsb.append(\"INDEX DETAILS (Oracle Specific)\\n\");\nsb.append(\"--------------------------------------------------\\n\");\n\nString[] types = {\"INDEX\"};\nResultSet rs = md.getTables(null, null, \"%\", types);\nResultSetMetaData rsmd = rs.getMetaData();\n\n// The column count starts from 1 for some odd reason here.\nfor (int i = 1; i < columnCount + 1; i++ ) {\n  String columnName = rsmd.getColumnName(i);\n  nameToColumnNumberMap.put(columnName, i);  \n  sb.append(\"Index details column available: \" + columnName + \"\\n\");\n  // System.out.println(\"Column name: \" + columnName);   \n}\n\nsb.append(\"\\n\");\n\nwhile (rs.next()) { \n \n   String tableCatalog = rs.getString(nameToColumnNumberMap.get(\"TABLE_CAT\")); \n   String tableSchema  = rs.getString(nameToColumnNumberMap.get(\"TABLE_SCHEM\"));\n   String tableName    = rs.getString(nameToColumnNumberMap.get(\"TABLE_NAME\"));\n   String tableType    = rs.getString(nameToColumnNumberMap.get(\"TABLE_TYPE\"));\n   String remarks      = rs.getString(nameToColumnNumberMap.get(\"REMARKS\"));\n   \n   sb.append(tableName +\"|\"+ tableCatalog +\"|\"+ tableSchema +\"|\" + tableType +\"|\" + remarks +\"\\n\");\n   \n}\n\nreturn sb.toString();\n\n',NULL,' ',NULL,NULL),('a9fe0bbd957e1ec681957e8a8c47005b',1741584763975,1741680760984,NULL,NULL,NULL,'Create and Add Users to WG',NULL,'beanshell','\n	import java.io.*;\n	import java.util.*;\n	import sailpoint.object.*;\n\n\n	String tskMsg = \"\";\n	String filePath=\"\\\\\\\\E:\\\\Data\\\\test.csv\";\n\n	/**\n	if(config.get(\"filePath\") != null){\n	filePath =  config.get(\"filePath\").toString();\n	}**/\n\n	File testFile = new File(filePath);\n\n	\n	if ((!testFile.exists()) || (testFile.isDirectory())) {\n		System.out.println(\"Unable to find file: \" + filePath);\n		/**taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n		taskResult.setProgress(\"Done launching task: \"+tskMsg);\n		taskResult.setCompletionStatus(TaskResult.CompletionStatus.Error);**/\n		return;\n	}\n\n	BufferedReader fileIn = new BufferedReader(new FileReader(filePath));\n	String l=\"\";    \n	  \n	while((l=fileIn.readLine())!=null){  \n	System.out.print(l+\"\\n\"); \n\n	String user = l.split(\",\")[0];\n	String group = l.split(\",\")[1];\n	String description = l.split(\",\")[2];\n	\n	//Create WG\n	if(group != null){\n		Identity workgroupIdentity = context.getObjectByName(Identity.class,group);\n		if(workgroupIdentity == null){\n		\n			Identity wg = new Identity();\n	\n			wg.setWorkgroup(true);\n			wg.setName(group);\n			wg.setDescription(description);\n			context.saveObject(wg);\n		    context.commitTransaction();\n		} else {\n			System.out.println(\"WG \" + group + \" Already Exists!!!\");\n		}\n	}\n\n	//Add User\n	if(null != user && null != group){\n		Identity identity = context.getObjectByName(Identity.class,user);\n		Identity workgroupIdentity = context.getObjectByName(Identity.class,group);\n					\n		if(null != identity && null != workgroupIdentity){\n		  tskMsg = tskMsg + \"user: \"+user+\" to workgroup: \"+group+\"\\r\\n\";\n		  identity.add(workgroupIdentity);\n		  context.saveObject(identity);\n		  context.commitTransaction();\n		  context.decache(identity);\n		  context.decache(workgroupIdentity);\n		}\n	}\n\n	}  \n\n\n\n	fileIn.close(); \n\n\n	/**\n	taskResult.addMessage(new Message(Message.Type.Info, tskMsg, null));\n	taskResult.setProgress(\"Done launching task: \"+tskMsg);\n    taskResult.setCompletionStatus(TaskResult.CompletionStatus.Success);\n    context.saveObject(taskResult); **/	\n	\n	return \"Completed\";\n',NULL,' ',NULL,NULL),('a9fe0bbd95ea1ee6819613cc42090902',1744088875529,NULL,NULL,NULL,NULL,'Service Identity Library',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fe0bbd95ea1ee6819613cc45e20903',1744088876514,NULL,NULL,NULL,NULL,'Service Account Owner Search Allowed Values Rule','This rule can be used to generate a field value (eg - an account name) using data from the given Identity. If this rule is run in the context of a workflow step then the arguments passed into the step will also be available. Also, any field values that have been processed so far from the policy related to the Application/Role will be available.','beanshell','\n		import org.apache.commons.logging.Log;\n		import org.apache.commons.logging.LogFactory;\n		import sailpoint.object.Filter;\n		import sailpoint.object.Link;\n		import sailpoint.object.QueryOptions;\n  \n        log = LogFactory.getLog(\"com.AccountOwnerSearchAllowedValuesRule\");\n        log.info(\"Enter Service Account Owner Search Allowed Values Rule\");\n\n        List returnList = new ArrayList();\n        String fieldName = field.getName();\n\n		String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\n        if(\"nativeIdentity\".equals(currentField)){\n            QueryOptions queryOptions = new QueryOptions();\n            Filter filter = null;\n\n            if(application != void && application != null){\n                filter = Filter.eq(\"application.id\", application);\n				filter = Filter.and(filter, Filter.eq(\"identity.employeeType\", \"Service\"));\n                if(search != void && search != null && !search.isEmpty())\n                    filter = Filter.and(filter, Filter.like(\"nativeIdentity\", search.trim(), Filter.MatchMode.ANYWHERE));\n\n					queryOptions.addFilter(filter);\n\n                Iterator iterator = null;\n                try{\n                    iterator = context.search(Link.class, queryOptions, \"nativeIdentity\");\n\n                    while(iterator.hasNext()){\n                        Object[] props = (Object[])iterator.next();\n                        String nativeIdentity = props[0];\n\n                        returnList.add(nativeIdentity);\n                    }\n\n                    sailpoint.tools.Util.flushIterator(iterator);\n                }catch (Exception ex){\n                    sailpoint.tools.Util.flushIterator(iterator);\n                    throw ex;\n                }\n            }\n\n        }\n        //all other cases, log an error\n        else{\n            log.error(\"Unsupported Field Name \" + currentField);\n            returnList = null;\n        }\n\n        log.debug(\"currentField: \" + currentField + \" = \" + returnList);\n        log.info(\"Exit Service Account Owner Search Allowed Values Rule\");\n        return returnList;\n    \n  ','AllowedValues',' ',NULL,'String'),('a9fe0bbd95ea1ee6819613cc61d50904',1744088883669,1744089832631,NULL,NULL,NULL,'Service Account Owner Search Field Value Rule','This rule can be used to generate a field value (eg - an account name) using data from the given Identity. If this rule is run in the context of a workflow step then the arguments passed into the step will also be available. Also, any field values that have been processed so far from the policy related to the Application/Role will be available.','beanshell','\n\n  import java.sql.Connection;\n  import java.sql.PreparedStatement;\n  import java.sql.ResultSet;\n  import org.apache.commons.logging.Log;\n  import sailpoint.object.Filter;\n  import sailpoint.object.Identity;\n  import sailpoint.object.Link;\n  import sailpoint.object.QueryOptions;\n\n  String applicationName = field.getApplication();\n  String fieldName = field.getName();\n  Object returnValue = \"\";\n\n  //sometimes IIQ will pass over the field name as <application>:<fieldName>, so we have to remove this\n  String currentField = fieldName.substring(fieldName.lastIndexOf(\':\') + 1);\n  log.debug(\"currentField: \" + currentField);\n\n  if(\"serviceIdentity\".equals(currentField)){\n    if(application != null && !application.isEmpty()\n       && nativeIdentity != null && !nativeIdentity.isEmpty()\n      ){\n      QueryOptions queryOptions = new QueryOptions();\n      Filter filter = Filter.eq(\"application.id\", application);\n      filter = Filter.and(filter, Filter.eq(\"nativeIdentity\", nativeIdentity.trim()));\n\n      queryOptions.addFilter(filter);\n\n      Iterator iterator = null;\n      try{\n        iterator = context.search(Link.class, queryOptions, \"identity.id\");\n\n        //tell user we cannot find an account\n        if(!iterator.hasNext()){\n          returnValue = \"Cannot find account\";\n        }\n        else{\n          Object[] props = (Object[])iterator.next();\n\n          //tell user we cannot find a unique account\n          if(iterator.hasNext()){\n            returnValue = \"Cannot find unique account\";\n          }\n          //other wise get the identity\n          else{\n            String id = (String)props[0];\n            Identity serviceIdentity = context.getObject(Identity.class, id);\n\n            //tell user this is not a service identity\n            if(!\"Service\".equals(serviceIdentity.getAttribute(\"employeeType\"))){\n              returnValue = \"Account is not correlated to a Service Identity [\" + serviceIdentity.getName() + \"]\";\n            }\n            //else return the service identity name\n            else{\n              returnValue = serviceIdentity.getName();\n            }\n          }\n        }\n        sailpoint.tools.Util.flushIterator(iterator);\n      }catch (Exception ex){\n        sailpoint.tools.Util.flushIterator(iterator);\n        throw ex;\n      }\n    }\n\n\n  }\n  else if(\"manager\".equals(currentField)){\n    if(serviceIdentity != null){\n      Identity identity = null;\n      if (serviceIdentity != null) {\n        identity = context.getObjectByName(Identity.class, serviceIdentity);\n        if(identity != null){\n          returnValue = identity.getManager().getDisplayName();\n          if(returnValue == null || \"\".equals(returnValue)){\n            returnValue = \"Could not find Service Identity owner\";\n          }\n        }\n      }\n    }\n\n  }\n\n  //all other cases, log an error\n  else{\n    log.error(\"Unsupported Field Name \" + currentField);\n    returnValue = null;\n  }\n\n  log.debug(currentField + \" = \" + returnValue);\n\n  log.info(\"Exit rule Service Account Owner Search Field Value Rule\");\n  return returnValue;\n\n  ','FieldValue',' ',NULL,'String'),('a9fe0bbd9657128e8196570ad8970019',1745217050775,NULL,NULL,NULL,NULL,'BeanShell Intro',NULL,'beanshell','\n  //Import\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  private static Log log = LogFactory.getLog(\"rule.TestRule\");\n\n  log.info(\"printing message 1\");\n  log.info(\"printing message 2\");\n  log.info(\"printing message 3\");\n\n  System.out.println(\"Simple Beanshell...\");\n  \n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  \n\n  return identityName;\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd9657128e8196570b4045001a',1745217077318,1745217119914,NULL,NULL,NULL,'BeanShell Variable',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  \n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  System.out.println(\"User: \"+identity);\n  //Object obj = context.getObjectByName(Object.class, objectName);\n  //Object obj = context.getObjectById(Object.class, objectId);\n \n  QueryOptions options = new QueryOptions();\n  List identityList = context.getObjects(Identity.class, options);\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd9657128e8196583ccac8017b',1745237101256,1745237103153,NULL,NULL,NULL,'BeanShell Control System',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n\n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  //Condtion ex1\n  if(identity == null){\n    System.out.println(\"No User Found... \");\n    log.error(\"No User Found...\");\n    return;\n  }\n\n  //Condtion ex2\n  if(identity != null && identity.getLinks() != void){\n    System.out.println(\"User Links: \"+identity.getLinks());\n\n    //loop ex1\n    for(Link link : identity.getLinks()){\n      System.out.println(\"User Link: \"+link.getApplication());\n\n    }\n\n    return identity.getLinks();\n\n  }\n\n	if(identity.getName().equals(\"12345\")){\n	} else {\n	}\n	\n	\n  /*if(identity != null @and identity.getLinks() @lt 0){\n  }*/\n  \n  \n  /*if(identity != null  && identity.getLinks() < 0){\n  }*/\n\n  //loop ex2\n  QueryOptions options = new QueryOptions();\n  List identityList = context.getObjects(Identity.class, options);\n  List idList = new ArrayList();\n  if (null != identityList) {\n\n    for (Identity id : identityList) {\n      idList.add(id.getDisplayName());\n    }\n\n  }\n\n  return idList;\n  //return identity.getDisplayName();\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd9657128e8196583de89b017c',1745237174427,1745237717567,NULL,NULL,NULL,'BeanShell Control Structure',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n\n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  //Condtion ex1\n  if(identity == null){\n    System.out.println(\"No User Found... \");\n    log.error(\"No User Found...\");\n    return;\n  }\n\n  //Condtion ex2\n  /**\n  if(identity != null && identity.getLinks() != void){\n    System.out.println(\"User Links: \"+identity.getLinks());\n\n    //loop ex1\n    for(Link link : identity.getLinks()){\n      System.out.println(\"User Link: \"+link.getApplication());\n\n    }\n\n    //return identity.getLinks();\n\n  }\n  **/\n\n	if(identity.getName().equals(\"12345\")){\n	} else {\n	}\n	\n	\n  /*if(identity != null @and identity.getLinks() @lt 0){\n  }*/\n  \n  \n  /*if(identity != null  && identity.getLinks() < 0){\n  }*/\n\n  //loop ex2\n  QueryOptions options = new QueryOptions();\n  List identityList = context.getObjects(Identity.class, options);\n  List idList = new ArrayList();\n  if (null != identityList) {\n\n    for (Identity id : identityList) {\n      idList.add(id.getDisplayName());\n    }\n\n  }\n  \n  for(String str: idList){\n  System.out.println(\"User: \"+str);\n  }\n\n  return idList;\n  //return identity.getDisplayName();\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd965b1be581965befac3c0029',1745299156028,1745306626485,NULL,NULL,NULL,'BeanShell Function',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n   System.out.println(\"Simple Beanshell...\");\n  \n    public void function1(){\n    	//do something\n    }\n   //function();\n    public String function2(){\n    	//do something\n    \n    	return \"\";\n    }\n    \n    public String function3(String str){\n    	//do something\n    \n    	return \"\";\n    }\n    \n    public String updateUser(String user, String attr, String value){\n    	if(null != user && null != value){\n	      	Identity identity = context.getObjectByName(Identity.class, user);\n	      	\n	      	System.out.println(\"identity...\"+identity);\n	\n	      	if(null != identity){\n	        	identity.setAttribute(attr, value);\n	        	context.saveObject(identity);\n	        	context.commitTransaction();\n	        	context.decache(identity);\n	      	}\n    	}\n\n  		return \"Updated\";\n    }\n    \n    return updateUser(\"2020021\", \"email\", \"Rahul.Dravid@swe.com\");\n\n	public Map executeAPI(List listOfEntIds)\n    {\n      \n        Map resultMap = new HashMap();\n\n        try{\n        Custom  accessReccCustomObject = context.getObjectByName(Custom.class, \"Access Recommendation Custom Object\");\n        String baseUrl = (String) accessReccCustomObject.get(\"accessRecommendationUrl\");\n        String acceptHeader = (String) accessReccCustomObject.get(\"acceptHeader\");\n\n        HttpPost post = new HttpPost(baseUrl + \"/private\");\n\n        HttpUtil httpUtil = new HttpUtil();\n        HttpEntity strUserEntity = new StringEntity(buildJsonStringEntity(listOfEntIds));\n        DefaultHttpClient httpClient = new DefaultHttpClient();\n        post.addHeader(\"Content-Type\", \"application/json\");\n        post.addHeader(\"ACCEPT\", acceptHeader);\n        post.addHeader(\"Authorization\", getExchangeBearerToken());\n        post.addHeader(\"client-correlation-id\", getExchangeClientID());\n        post.setEntity(strUserEntity);\n\n        HttpResponse httpResponse = httpClient.execute(post);\n        if(httpResponse != null)\n        {\n        resultMap = getResultMap(httpResponse);\n        }\n        }\n        catch (Exception e) {\n        log.error(\"Error in executeAPI method from Access Automation Approval Rule Library \"+e.getMessage());\n        }\n\n       \n        return resultMap;\n    }\n    \n    \n    private ProvisioningPlan buildAccountDeletionPlan(String eid, String app, Identity id,String nativeIden){\n    List acctReqs = new ArrayList();\n    ProvisioningPlan plan = new ProvisioningPlan();\n    AccountRequest acctReq = new ProvisioningPlan.AccountRequest();\n    acctReq.setOperation(AccountRequest.Operation.Delete);\n    acctReq.setApplication(app);\n    acctReq.setNativeIdentity(nativeIden);\n    Attributes attr = new Attributes();\n    attr.put(\"comments\", \"Auto Revoke\");\n    acctReq.setArguments(attr);\n    acctReqs.add(acctReq);\n    plan.setIdentity(id);\n    plan.setSource(\"LCM\");\n    plan.setAccountRequests(acctReqs);\n    return plan;\n\n  }\n  \n  \n  		return idList;\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd965b1be581965c0500690048',1745300553833,NULL,NULL,NULL,NULL,'BeanShell Save Commit',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  	private static Log log = LogFactory.getLog(\"rule.TestRule\");\n\n  	System.out.println(\"Simple Beanshell...\");\n	String user = \"2020009\";\n	String attr = \"email\";	  \n	String value = \"Rahul.Dravid@swe.com\";\n	System.out.println(\"Searching User: \"+user);\n\n\n	if(null != user && null != value){\n		Identity identity = context.getObjectByName(Identity.class, user);\n	\n		if(null != identity){\n	        	identity.setAttribute(attr, value);\n	        	context.saveObject(identity);\n	        	context.commitTransaction();\n	        	context.decache(identity);\n	    }\n    }\n    \n    \n    /***\n	Get new UID\n	***/\n	Custom custom = (Custom) ObjectUtil.lockObject(context, Custom.class, null, \"UID Custom Object\", PersistenceManager.LOCK_TYPE_TRANSACTION);\n		\n		String prefix = custom.getString(\"prefix\");\n		String suffix = custom.getString(\"suffix\");\n		\n		Integer suf = Integer.valueOf(suffix);\n		\n		if(suf == 9999){\n			suf = 1;\n			incrementPrefix(prefix);\n		} else {\n			suf++;\n		}\n		\n		String suffix = String.format(\"%04d\", new Object[] {suf});\n		custom.put(\"prefix\", prefix);\n		custom.put(\"suffix\", suffix);\n		\n		context.saveObject(custom);\n		context.commitTransaction();\n		\n		return prefix + suffix;\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd965b1be581966105fc8401fb',1745384504452,NULL,NULL,NULL,NULL,'BeanShell Rule Reference',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n \n\n  System.out.println(\"Simple Beanshell...\");\n\n  return getNewUID(context);\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd965b1be58196610b2be60203',1745384844262,1745385689593,NULL,NULL,NULL,'BeanShell Querying',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.tools.Util;\n  import sailpoint.tools.GeneralException;\n\n  System.out.println(\"Simple Beanshell...\");\n  String identityName = \"2020009\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n  Identity identity1 = context.getObjectById(Identity.class, identity.getId());\n\n	System.out.println(\"User: \"+identity);\n	System.out.println(\"User: \"+identity1);\n	\n	public void getApp(String appType)\n	{\n	\n		QueryOptions qo = new QueryOptions();\n	    qo.addFilter(Filter.eq(\"type\", appType));\n	    Iterator appItr = context.search(Application.class, qo);\n	    List appList = new ArrayList();   \n	    // Iterate through each app and write its attributes to the properties file\n	    while(appItr.hasNext()){\n			Application curApp = (Application) appItr.next();\n			String curAppName = curApp.getName();\n			appList.add(curAppName);\n		}\n		\n		System.out.println(appList);\n	\n	}\n\n	getApp(\"DelimitedFile\");\n\n 	public void removeOldDummyTasks()\n	{\n	//The taskDefinition and taskResult can only be delete only if the task result is done.\n	//Otherwise deleting taskdefinition will remove any pending tasks.\n	QueryOptions qo = new QueryOptions();\n	Filter f1 = Filter.like(\"name\",\"Monitoring Task\", Filter.MatchMode.START);\n	qo.addFilter(f1);\n	List dummySequentialTasks = context.getObjects(TaskResult.class, qo);\n	if(dummySequentialTasks!= null && !dummySequentialTasks.isEmpty())\n	{\n		for (TaskResult tasResult : dummySequentialTasks)\n		{\n			if(tasResult.isComplete())\n			{\n			TaskDefinition taskDef = context.getObject(TaskDefinition.class, tasResult.getName());\n			Terminator term = new Terminator(context);\n			term.deleteObject(tasResult);\n			if(taskDef!=null)\n			{				\n				term.deleteObject(taskDef);\n			}\n				context.commitTransaction();\n			}\n		}\n	\n	}\n	}\n	\n	public void querySQL()\n	{\n	//SQL Query\n	//String query = \"sql: SELECT name, extended1 FROM IDENTITYIQ.SPT_IDENTITY\";\n\n	//HQL Query\n	String query = \"select name, displayName FROM Identity\";\n	Iterator results = null;\n   \n	try{\n\n		QueryOptions qo = new QueryOptions();\n		qo.setCloneResults(true);\n		qo.setQuery(query);\n		results = context.search(query, null, qo);\n\n		while(results.hasNext()){\n\n			Object[] resultValues = results.next();\n\n			String val1 = resultValues[0];\n			String val2 = resultValues[1];\n			\n			System.out.println(\"ID: \"+val1);\n			System.out.println(\"Full Name: \"+val2);\n\n		}\n	}  catch(GeneralException ex){\n		System.out.println(\"GeneralException occured \" + ex.getMessage());\n	} catch(Exception ex){\n		System.out.println(\"Exception occured \" + ex.getMessage());\n	}finally {\n		if(null!=results) Util.flushIterator(results);\n	}\n	\n	}\n\n	querySQL();\n  ',NULL,' ',NULL,NULL),('a9fe0bbd965b1be58196a48cff3c1930',1746517425988,NULL,NULL,NULL,NULL,'WebService Sample After Rule','This rule is used by the  Web Services connector to update parsed resource object. Create List of Objects  which will later converted to Resource object','beanshell','System.out.println(\"requestEndPoint\"+requestEndPoint);\r\nSystem.out.println(\"rawResponseObject\"+rawResponseObject);','WebServiceAfterOperationRule',' ',NULL,'Object'),('a9fe0bbd965b1be58196a48de6301931',1746517485104,NULL,NULL,NULL,NULL,'Web Service Sample Before Rule','This rule is used by the  Web Services connector before performing any operation like testconnection, aggregation etc .','beanshell','System.out.println(\"Before op requestEndPoint \"+requestEndPoint);','WebServiceBeforeOperationRule',' ',NULL,'EndPoint'),('a9fe0bbd965b1be58196b3ae88d024c2',1746771282128,1747294920039,NULL,NULL,NULL,'Web App Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import sailpoint.object.ProvisioningPlan;\n  import sailpoint.object.ProvisioningPlan.AccountRequest;\n  import sailpoint.object.ProvisioningPlan.AttributeRequest;\n  import sailpoint.object.ProvisioningPlan.Operation;\n  import sailpoint.object.ProvisioningPlan.AccountRequest.Operation;\n\n  String identityName = \"2020009\";\n  String app = \"Web App\"; //Web App\n  String nativeidentity = \"aaa0011\";\n\n\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  ProvisioningPlan plan = new ProvisioningPlan();\n  // Set identity to the plan\n  plan.setIdentity(identity);\n\n  /** \n  AccountRequest acctReq = new AccountRequest();\n  acctReq.setOperation(AccountRequest.Operation.Enable);\n  acctReq.setApplication(app);\n  acctReq.setNativeIdentity(nativeidentity);\n  //acctReq.add(new AttributeRequest(\"id\", ProvisioningPlan.Operation.Set, 1));**/\n  \n  \n  /** \n  AccountRequest acctReq = new AccountRequest();\n  acctReq.setOperation(AccountRequest.Operation.Modify);\n  acctReq.setApplication(app);\n  acctReq.setNativeIdentity(nativeidentity);\n  acctReq.add(new AttributeRequest(\"group\", ProvisioningPlan.Operation.Add, \"Tester\"));**/\n  \n  \n  AccountRequest acctReq = new AccountRequest();\n  acctReq.setOperation(AccountRequest.Operation.Create);\n  acctReq.setApplication(app);\n  acctReq.setNativeIdentity(nativeidentity);\n  \n  /**AccountRequest acctReq2 = new AccountRequest();\n  acctReq2.setOperation(AccountRequest.Operation.Modify);\n  acctReq2.setApplication(app);\n  acctReq2.setNativeIdentity(nativeidentity);\n  acctReq2.add(new AttributeRequest(\"group\", ProvisioningPlan.Operation.Add, \"Admin\"));*/\n\n  plan.add(acctReq);\n  //plan.add(acctReq2);\n  \n  \n  Provisioner p = new Provisioner(context);\n  p.execute(plan);\n\n  System.out.println(\"Plan \"+plan.toXml());\n  \n\n  return plan.toXml();\n\n  ',NULL,' ',NULL,NULL),('a9fe0bbd97a01e0b8197ab41b39c0946',1750924899228,1750924969621,NULL,NULL,NULL,'SupportPlugin - SupportRuleIDXCK',NULL,'beanshell','\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\nimport oracle.jdbc.driver.OracleConnection;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport sailpoint.tools.Message;\nimport sailpoint.Version;\n\nLog log = LogFactory.getLog(\"sailpoint.rule.SupportRuleIDXCK\");\nStringWriter stringWriter = new StringWriter();\nPrintWriter output = new PrintWriter(stringWriter);\n\n///\n/// for tracing purposes, add line to \"log4j.properites\" file \n/// log4j trace: log4j.logger.sailpoint.rule.SupportRuleIDXCK=all\n///\n/// @version: $Revision: 52889 $; $Date: 2017-10-09 10:27:18 -0500 (Mon, 09 Oct 2017) $;\n/////////////////////////////////////////////////////////////////////////////////////\n/// TOUCH ABOVE THIS LINE AT OWN PERIL!!!\n\n///\n/// OPTION 1) flag to control read-only mode\n/// false - scan only, do NOT build SQL Update statments to fix errors (default)\n/// true - build SQL Update statments to modify DB (proabably run them too)\n///\n\nboolean flagFix = false; // true updates IIQ tables !!!\n\n///\n/// OPTION 2) flag to select table coverage\n/// false - process \"usual suspects\", subset of tables w/IDX column (default)\n/// true - process all tables w/IDX column\n///\n\nboolean flagAllTbls = false; // true processes all IDX tables\n\n///\n/// OPTION 3) flag to override table coverage\n/// false - use tbl info from rule (default)\n/// true - use (user-cfged) table\n/// (optional \"strValueOverride\" to scan only rows w/parent-column value)\n///\n\nboolean flagOverrideTbl = false; // true uses \"override\" strings\nString strTblOverride = \"SPT_TABLENAME\";\nString strValueOverride = \"\"; // empty checks all parent values\n\n///\n/// OPTION 4) flag to fix all tbl entries (w/single SQL stmt)\n/// false - only fix parent-rows w/mis-ordered idx-values (default)\n/// true - recompute all rows when finding any mis-ordered row\n///\n\nboolean flagFixAllRows = false; // true recalculates all IDX values\n\n///\n/// OPTION 5) flag to not run SQL stmts\n/// false - execute SQL Select,Update stmts (default)\n/// true - do NOT execute SQL stmts\n///\n/// log4j-level INFO outputs SQL stmts (for DBA review/execution)\n///\n\nboolean flagNoRunSQL = false; // true doesn\'t execute SQL stmts\n\n///\n/// OPTION 6) string to use in place of runtime IIQ version\n/// empty string gets version from runtime IIQ env (default)\n/// \"7.1\",\"7.2\",\"7.3\",\"8.0\",\"8.1\",\"8.2\"\n///\n\nString strIIQVerOverride = \"\"; // non-empty string skips getVersion() call\n\n///\n/// OPTION 7) string to use in place of runtime DB vendor\n/// flavors SQL \"UPDATE\" syntax to suit RDBMS taste\n///\n/// empty string pulls DB vendor from runtime IIQ env (default)\n/// \"mysql\",\"sqlserver\",\"oracle\",\"db2\"\n///\n\nString strSQLSyntaxOverride = \"\"; // non-empty string skips SQL meta-data\n\n///\n/// OPTION 8) flag to process null-parent-key, non-null-idx columns\n///\n/// false - do not scan for rows w/null-valued \"parent\" key-column\n/// true - find \"suspect\" rows w/null-valued \"parent\" key-column\n/// WARNING: fix to null-valued \"parent\" column deletes table entry (ie DATA-LOSS)\n///\n\nboolean flagParentCol = false; // true processes \"parent\" column values\n\n///\n///\n/// TOUCH BELOW THIS LINE AT OWN PERIL!!!\n/////////////////////////////////////////////////////////////////////////////////////\n///\n\n///\n/// (private) global flag for executions with TaskResult (vs rule\'s direct invocation)\n///\nboolean flagTaskResult = ((void != taskResult) && (null != taskResult)) ? true : false;\n\n///\n/// IIQ 8.2 lacks Oracle driver, so kludge to avoid ClassNotFound scenarios\n///\nvoid funcVoid_TweakDBConnection(Connection argConn) { if (argConn instanceof OracleConnection) ((OracleConnection)argConn).setStatementCacheSize(0); }\n\n///\n///\n/// funcALst_CfgTblIDX()\n/// check to build array with \"override\" settings\n/// else build array of IDX table,key,column triples for many IIQ versions\n/// return array\n///\n/// arraylist holds (version-specific) table,column names w/IDX feature\n/// always add table,primary-key,column names as ordered triplets !!!\n/// BeanShell barfs on ArrayList<String,String,String> or Arrays.asArrayList() !!!\n///\nArrayList funcALst_CfgTblIDX(String argVer) {\n  ArrayList tmpArray = new ArrayList();\n\n  log.debug(\"IIQ version [\" +argVer+ \"]\");\n\n  if ((void != flagAllTbls) && !flagAllTbls && (void != flagOverrideTbl) && !flagOverrideTbl) {\n    tmpArray.add(\"spt_certification\"); tmpArray.add(\"id\"); tmpArray.add(\"parent\");\n    tmpArray.add(\"spt_certification_item\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_entity_id\");\n    tmpArray.add(\"spt_mitigation_expiration\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_remediation_item\"); tmpArray.add(\"id\"); tmpArray.add(\"work_item_id\");\n    if (argVer.equals(\"6.4\") || argVer.equals(\"7.0\") || argVer.equals(\"7.1\") || argVer.equals(\"7.2\")) {\n      tmpArray.add(\"spt_certification_entity\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_id\");\n      if (argVer.equals(\"6.4\") || argVer.equals(\"7.0\")) {\n      tmpArray.add(\"spt_link\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n    }}\n  } else if (argVer.equals(\"6.4\") || argVer.equals(\"7.0\") || argVer.equals(\"7.1\") || argVer.equals(\"7.2\") || argVer.equals(\"7.3\") || argVer.equals(\"8.0\") || argVer.equals(\"8.1\")  || argVer.equals(\"8.2\")) {\n    tmpArray.add(\"spt_account_group_inheritance\"); tmpArray.add(\"account_group\"); tmpArray.add(\"account_group\");\n    tmpArray.add(\"spt_account_group_perms\"); tmpArray.add(\"accountgroup\"); tmpArray.add(\"accountgroup\");\n    tmpArray.add(\"spt_account_group_target_perms\"); tmpArray.add(\"accountgroup\"); tmpArray.add(\"accountgroup\");\n    tmpArray.add(\"spt_activity_constraint\"); tmpArray.add(\"id\"); tmpArray.add(\"policy\");\n    tmpArray.add(\"spt_activity_data_source\"); tmpArray.add(\"id\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_activity_time_periods\"); tmpArray.add(\"application_activity\"); tmpArray.add(\"application_activity\");\n    tmpArray.add(\"spt_app_dependencies\"); tmpArray.add(\"application\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_app_secondary_owners\"); tmpArray.add(\"application\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_application_remediators\"); tmpArray.add(\"application\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_application_schema\"); tmpArray.add(\"id\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_arch_cert_item_apps\"); tmpArray.add(\"arch_cert_item_id\"); tmpArray.add(\"arch_cert_item_id\");\n    tmpArray.add(\"spt_archived_cert_item\"); tmpArray.add(\"id\"); tmpArray.add(\"parent_id\");\n    tmpArray.add(\"spt_authentication_answer\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_batch_request_item\"); tmpArray.add(\"id\"); tmpArray.add(\"batch_request_id\");\n    tmpArray.add(\"spt_bundle_children\"); tmpArray.add(\"bundle\"); tmpArray.add(\"bundle\");\n    tmpArray.add(\"spt_bundle_permits\"); tmpArray.add(\"bundle\"); tmpArray.add(\"bundle\");\n    tmpArray.add(\"spt_bundle_requirements\"); tmpArray.add(\"bundle\"); tmpArray.add(\"bundle\");\n    tmpArray.add(\"spt_capability_children\"); tmpArray.add(\"capability_id\"); tmpArray.add(\"capability_id\");\n    tmpArray.add(\"spt_capability_rights\"); tmpArray.add(\"capability_id\"); tmpArray.add(\"capability_id\");\n    tmpArray.add(\"spt_cert_action_assoc\"); tmpArray.add(\"parent_id\"); tmpArray.add(\"parent_id\");\n    tmpArray.add(\"spt_cert_item_applications\"); tmpArray.add(\"certification_item_id\"); tmpArray.add(\"certification_item_id\");\n    tmpArray.add(\"spt_certification\"); tmpArray.add(\"id\"); tmpArray.add(\"parent\");\n    tmpArray.add(\"spt_certification_def_tags\"); tmpArray.add(\"cert_def_id\"); tmpArray.add(\"cert_def_id\");\n    tmpArray.add(\"spt_certification_groups\"); tmpArray.add(\"certification_id\"); tmpArray.add(\"certification_id\");\n    tmpArray.add(\"spt_certification_item\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_entity_id\");\n    tmpArray.add(\"spt_certification_tags\"); tmpArray.add(\"certification_id\"); tmpArray.add(\"certification_id\");\n    tmpArray.add(\"spt_certifiers\"); tmpArray.add(\"certification_id\"); tmpArray.add(\"certification_id\");\n    tmpArray.add(\"spt_child_certification_ids\"); tmpArray.add(\"certification_archive_id\"); tmpArray.add(\"certification_archive_id\");\n    tmpArray.add(\"spt_dictionary_term\"); tmpArray.add(\"id\"); tmpArray.add(\"dictionary_id\");\n    tmpArray.add(\"spt_dynamic_scope_exclusions\"); tmpArray.add(\"dynamic_scope_id\"); tmpArray.add(\"dynamic_scope_id\");\n    tmpArray.add(\"spt_dynamic_scope_inclusions\"); tmpArray.add(\"dynamic_scope_id\"); tmpArray.add(\"dynamic_scope_id\");\n    tmpArray.add(\"spt_entitlement_group\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_entitlement_snapshot\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_item_id\");\n    tmpArray.add(\"spt_generic_constraint\"); tmpArray.add(\"id\"); tmpArray.add(\"policy\");\n    tmpArray.add(\"spt_group_permissions\"); tmpArray.add(\"entitlement_group_id\"); tmpArray.add(\"entitlement_group_id\");\n    tmpArray.add(\"spt_identity_assigned_roles\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_identity_bundles\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_identity_capabilities\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_identity_controlled_scopes\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_identity_request_item\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_request_id\");\n    tmpArray.add(\"spt_identity_role_metadata\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_identity_workgroups\"); tmpArray.add(\"identity_id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_jasper_files\"); tmpArray.add(\"result\"); tmpArray.add(\"result\");\n    tmpArray.add(\"spt_managed_attr_inheritance\"); tmpArray.add(\"managedattribute\"); tmpArray.add(\"managedattribute\");\n    tmpArray.add(\"spt_managed_attr_perms\"); tmpArray.add(\"managedattribute\"); tmpArray.add(\"managedattribute\");\n    tmpArray.add(\"spt_managed_attr_target_perms\"); tmpArray.add(\"managedattribute\"); tmpArray.add(\"managedattribute\");\n    tmpArray.add(\"spt_mitigation_expiration\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n    tmpArray.add(\"spt_password_policy_holder\"); tmpArray.add(\"id\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_profile\"); tmpArray.add(\"id\"); tmpArray.add(\"bundle_id\");\n    tmpArray.add(\"spt_profile_constraints\"); tmpArray.add(\"profile\"); tmpArray.add(\"profile\");\n    tmpArray.add(\"spt_profile_permissions\"); tmpArray.add(\"profile\"); tmpArray.add(\"profile\");\n    tmpArray.add(\"spt_remediation_item\"); tmpArray.add(\"id\"); tmpArray.add(\"work_item_id\");\n    tmpArray.add(\"spt_request_arguments\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_request_definition_rights\"); tmpArray.add(\"request_definition_id\"); tmpArray.add(\"request_definition_id\");\n    tmpArray.add(\"spt_request_returns\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_rule_dependencies\"); tmpArray.add(\"rule_id\"); tmpArray.add(\"rule_id\");\n    tmpArray.add(\"spt_rule_signature_arguments\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_rule_signature_returns\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_schema_attributes\"); tmpArray.add(\"applicationschema\"); tmpArray.add(\"applicationschema\");\n    tmpArray.add(\"spt_scope\"); tmpArray.add(\"id\"); tmpArray.add(\"parent_id\");\n    tmpArray.add(\"spt_sign_off_history\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_id\");\n    tmpArray.add(\"spt_snapshot_permissions\"); tmpArray.add(\"snapshot\"); tmpArray.add(\"snapshot\");\n    tmpArray.add(\"spt_sodconstraint\"); tmpArray.add(\"id\"); tmpArray.add(\"policy\");\n    tmpArray.add(\"spt_sodconstraint_left\"); tmpArray.add(\"sodconstraint\"); tmpArray.add(\"sodconstraint\");\n    tmpArray.add(\"spt_sodconstraint_right\"); tmpArray.add(\"sodconstraint\"); tmpArray.add(\"sodconstraint\");\n    tmpArray.add(\"spt_sync_roles\"); tmpArray.add(\"config\"); tmpArray.add(\"config\");\n    tmpArray.add(\"spt_target_sources\"); tmpArray.add(\"application\"); tmpArray.add(\"application\");\n    tmpArray.add(\"spt_task_definition_rights\"); tmpArray.add(\"task_definition_id\"); tmpArray.add(\"task_definition_id\");\n    tmpArray.add(\"spt_task_signature_arguments\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_task_signature_returns\"); tmpArray.add(\"signature\"); tmpArray.add(\"signature\");\n    tmpArray.add(\"spt_work_item\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_ref_id\");\n    tmpArray.add(\"spt_work_item_comments\"); tmpArray.add(\"work_item\"); tmpArray.add(\"work_item\");\n    tmpArray.add(\"spt_work_item_owners\"); tmpArray.add(\"config\"); tmpArray.add(\"config\");\n    tmpArray.add(\"spt_workflow_rule_libraries\"); tmpArray.add(\"rule_id\"); tmpArray.add(\"rule_id\");\n    tmpArray.add(\"spt_workflow_target\"); tmpArray.add(\"id\"); tmpArray.add(\"workflow_case_id\");\n\n    if (argVer.equals(\"8.1\") || argVer.equals(\"8.2\")) {\n    	tmpArray.add(\"spt_identity_req_item_attach\"); tmpArray.add(\"identity_request_item_id\"); tmpArray.add(\"identity_request_item_id\");\n    } else if (!argVer.equals(\"8.0\")) {\n      tmpArray.add(\"spt_dashboard_content_rights\"); tmpArray.add(\"dashboard_content_id\"); tmpArray.add(\"dashboard_content_id\");\n      tmpArray.add(\"spt_dashboard_reference\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_dashboard_id\");\n      if (!argVer.equals(\"7.3\")) {\n      	tmpArray.add(\"spt_certification_entity\"); tmpArray.add(\"id\"); tmpArray.add(\"certification_id\");\n        if (!argVer.equals(\"7.2\")) {\n          tmpArray.add(\"spt_process_application\"); tmpArray.add(\"process\"); tmpArray.add(\"process\");\n          tmpArray.add(\"spt_process_bundles\"); tmpArray.add(\"process\"); tmpArray.add(\"process\");\n          if (!argVer.equals(\"7.1\")) { tmpArray.add(\"spt_link\"); tmpArray.add(\"id\"); tmpArray.add(\"identity_id\");\n            if (!argVer.equals(\"7.0\")) { tmpArray.add(\"spt_quick_link_dynamic_scopes\"); tmpArray.add(\"quick_link_id\"); tmpArray.add(\"quick_link_id\"); }\n          }\n        }\n      }\n    }\n  } else { log.error(\"IIQ version unmatched [\" +argVer+ \"]\"); }\n\n\n  if ((void != flagOverrideTbl) && flagOverrideTbl) {\n    ArrayList tmpArrayOverride = new ArrayList();\n    if ((void != strTblOverride) && (null != strTblOverride) && (0 < strTblOverride.length())) {\n      strTblOverride = strTblOverride.trim().toLowerCase();\n      for (int i = 0; i+2 < tmpArray.size(); i+=3) {\n        if (strTblOverride.equals(tmpArray.get(i))) {\n          tmpArrayOverride.add(strTblOverride);\n          tmpArrayOverride.add(tmpArray.get(i+1));\n          tmpArrayOverride.add(tmpArray.get(i+2));\n          break;\n        }\n      }\n    }\n    tmpArray = tmpArrayOverride;\n  }\n\n  return tmpArray;\n}\n\n\n///\n///\n/// funcStr_SetSQLSyntax()\n/// build DB connection to use metadata to find vendor\n/// return stringname of RDBMS vendor\n///\nString funcStr_SetSQLSyntax() {\n\n  String tmpDB = \"\";\n  Connection tmpConn;\n\n    if ((void != strSQLSyntaxOverride) && (0 < strSQLSyntaxOverride.length()))\n      tmpDB = strSQLSyntaxOverride;\n    else {\n      try {\n          log.debug(\"connecting to SQL metadata\");\n          tmpConn = context.getConnection(); // when running in \"direct\" datasource envs (sailpointcontext)\n          DatabaseMetaData tmpDBinfo = tmpConn.getMetaData();\n          String tmpStr = tmpDBinfo.getDriverName();\n\n          log.debug(\"finding SQL metadata [\" +tmpStr+ \"]\");\n\n          /// assign SQL Syntax based on initial company name\n          if (tmpStr.startsWith(\"MySQL\")) tmpDB = \"mysql\";\n          else if (tmpStr.startsWith(\"Microsoft\")) tmpDB = \"sqlserver\";\n          else if (tmpStr.startsWith(\"Oracle\")) tmpDB = \"oracle\";\n          else tmpDB = \"db2\";\n\n      } catch(java.sql.SQLException e) {\n        log.error(\"finding SQL metadata failed: \", e);\n        throw e;\n      }\n  }\n\n  log.debug(\"using SQL syntax: \" +tmpDB);\n  return tmpDB;\n}\n\n\n///\n///\n/// funcInt_CountNullParentCols()\n/// run SQL stmt to count rows w/null-valued parent AND non-null idx columns\n///\n/// SELECT COUNT(+strKey+) FROM +strTbl+ WHERE (+strCol+ IS null)\n///\nint funcInt_CountNullParentCols(String argTbl, String argKey, String argCol) {\n\n  Connection tmpConn;\n  ArrayList tmpLst = new ArrayList();\n  String tmpSQL = \"\";\n  String tmpRet = \"-1\";\n\n  tmpSQL = \"SELECT COUNT(\"+argKey+\") FROM \"+argTbl+\" WHERE (\"+argCol+\" IS null) AND idx IS NOT null\";\n\n  try {\n    log.info(\"executing parent COUNT on [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n\n    if ((void != flagNoRunSQL) && flagNoRunSQL) {\n      log.debug(\"skipping parent COUNT\");\n      if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Info, tmpSQL, null));\n    } else {\n      log.debug(\"connecting parent COUNT\");\n      tmpConn = context.getConnection(); if (\"oracle\".equals(tmpDB)) funcVoid_TweakDBConnection(tmpConn);\n\n      log.debug(\"preparing parent COUNT\");\n      PreparedStatement tmpStmt = tmpConn.prepareStatement(tmpSQL);\n\n      try {\n        log.debug(\"executing parent COUNT\");\n        ResultSet tmpRS = tmpStmt.executeQuery();\n        if (tmpRS.next()) tmpRet = tmpRS.getString(1);		\n        try { tmpRS.close(); } catch(Exception ignore) {}\n      } finally { try { tmpStmt.close(); } catch(Exception ignore) {} }\n    }\n  } catch(java.sql.SQLException e) {\n    log.error(\"executing parent COUNT failed: \", e);\n    throw e;\n  }\n\n  log.info(\"returning parent COUNT: \" +tmpRet);\n  return Integer.parseInt(tmpRet);\n}\n\n\n///\n///\n/// funcALst_SelectBadIDXCols()\n/// run first SQL stmt to find (non-null) columns w/null IDX-values\n/// run second SQL stmt to find columns w/(non-null) IDX-value having duplicates\n/// run third SQL stmt to find columns w/(non-null) IDX-value having gaps\n/// union merges results (String-valued) column w/bad IDX values\n///\n/// notes: ignore entries w/null values in both column,idx (ala spt_entitlement_snapshot)\n/// yoohoo ANSI!!! DB2,MySQL,MS-MySQL,Oracle execute same SELECT stmts\n///\n/// SELECT +strCol+ FROM +strTbl+\n///   WHERE ((+strCol+ IS not null)\n///     AND ( +strCol+  = \' +strValueOverride+ \')  <<<< optional specific idx-set\n///     AND (idx IS null))\n/// UNION SELECT +strCol+ FROM +strTbl+\n///   WHERE ( +strCol+  = \' +strValueOverride+ \')  <<<< optional specific idx-set\n///   GROUP BY +strCol+, idx HAVING (COUNT(*) <> 1)\n/// UNION SELECT +strCol+ FROM +strTbl+\n///   WHERE ( +strCol+  = \' +strValueOverride+ \')  <<<< optional specific idx-set\n///   GROUP BY +strCol+ HAVING (MIN(idx) <> 0) OR ((COUNT(+strCol+) - MAX(idx))<>1)\n///\nArrayList funcALst_SelectBadIDXCols(String argTbl, String argKey, String argCol) {\n\n  String tmpSQL = \"\";\n  ArrayList tmpLst = new ArrayList();\n  PreparedStatement tmpStmt = null;\n  ResultSet tmpRS = null;\n\n  if ((void == flagOverrideTbl) || (false == flagOverrideTbl) || (void == strValueOverride) || (null == strValueOverride) || (0 == strValueOverride.length())) {\n    tmpSQL = \"SELECT \"+argCol+\" FROM \"+argTbl+\" WHERE ((\"+argCol+\" IS NOT null) AND (idx IS null))\";\n    tmpSQL += \" UNION SELECT \"+argCol+\" FROM \"+argTbl+\" GROUP BY \"+argCol+\", idx HAVING (COUNT(*)<>1)\";\n    tmpSQL += \" UNION SELECT \"+argCol+\" FROM \"+argTbl+\" GROUP BY \"+argCol+\" HAVING (MIN(idx)<>0) OR ((COUNT(\"+argCol+\") - MAX(idx))<>1)\";\n  } else {\n    tmpSQL = \"SELECT \"+argCol+\" FROM \"+argTbl+\" WHERE ((\"+argCol+\" IS NOT null) AND (\"+argCol+\" = \'\"+strValueOverride+\"\') AND (idx IS null))\";\n    tmpSQL += \" UNION SELECT \"+argCol+\" FROM \"+argTbl+\" WHERE (\"+argCol+\" = \'\"+strValueOverride+\"\') GROUP BY \"+argCol+\", idx HAVING (COUNT(*)<>1)\";\n    tmpSQL += \" UNION SELECT \"+argCol+\" FROM \"+argTbl+\" WHERE (\"+argCol+\" = \'\"+strValueOverride+\"\') GROUP BY \"+argCol+\" HAVING (MIN(idx)<>0) OR ((COUNT(\"+argCol+\") - MAX(idx))<>1)\";\n  }\n\n  try {\n    log.info(\"executing idx SELECT [\" +tmpSQL+ \"] on [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n\n    if ((void != flagNoRunSQL) && flagNoRunSQL) {\n      log.debug(\"skipping idx SELECT [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n      if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Info, tmpSQL, null));\n    } else {\n      log.debug(\"connecting idx SELECT\");\n      Connection tmpConn = context.getConnection(); if (\"oracle\".equals(tmpDB)) funcVoid_TweakDBConnection(tmpConn);\n\n      log.debug(\"preparing idx SELECT\");\n      tmpStmt = tmpConn.prepareStatement(tmpSQL);\n\n      log.debug(\"executing idx SELECT\");\n      tmpRS = tmpStmt.executeQuery();\n\n      if (null != tmpRS) while (tmpRS.next()) {\n        String tmpCol = (String) tmpRS.getString(1);\n        if ((null != tmpCol) && (0 < tmpCol.length())) tmpLst.add(tmpCol);\n      }\n    }\n  } catch(Exception e) { log.error(\"executing idx SELECT failed: \", e); throw e; \n  } finally {\n    try { tmpRS.close(); } catch(Exception ignore) {}\n    try { tmpStmt.close(); } catch(Exception ignore) {}\n  }\n\n  log.info(\"returning SQL select: \" +tmpLst.toString());\n  return tmpLst;\n}\n\n///\n///\n/// funcVoid_UpdateIDXVals()\n/// run SQL stmt to fix mis-ordered columns\n/// ALL) single SQL stmt to re-calculate IDX on all entries\n/// ONE) extra WHERE clause to filter by specific column\n///\n/// DB2,Oracle allows reference in assignment, yet no JOINS\n/// MySQL blocks table reference inside assignment, so must JOIN new idxvalues\n/// java.sql.SQLException: You can\'t specify target table \'tblB\' for update in FROM clause\n/// SQLServer requires worst parts from MySQL,Oracle\n///\n/// SQL stmts for tables w/(non-composite) primary-key \"id\"\n///\n/// \"UPDATE +strTbl+ tblB SET tblB.idx = (\n///       SELECT COUNT(*) FROM +strTbl+ tblA\n///         WHERE ((tblA.+strCol+ = tblB.+strCol+) AND (tblA.id < tblB.id))\n///     )\n///     WHERE (tblB.+strCol+ = \'+strColVal+\')\" <<< difference btwn (ALL),(ONE)\n///\n/// \"UPDATE +strTbl+ tblD\n///   JOIN (SELECT tblB.id,\n///       ( SELECT COUNT(*) FROM +strTbl+ tblA\n///         WHERE ((tblA.+strCol+ = tblB.\" +strCol+) AND (tblA.id < tblB.id))\n///       ) AS idxValue\n///       FROM +strTbl+ tblB\n///       WHERE (tblB.+strCol+ = \'+strColVal+\') <<< difference btwn (ALL),(ONE)\n///     ) tblC ON tblD.id = tblC.id\n///   SET tblD.idx = tblC.idxValue\"\n///\n/// \"UPDATE tblD SET tblD.idx = tblC.idxValue\n///   FROM +strTbl+ tblD\n///   JOIN (SELECT tblB.id,\n///       ( SELECT COUNT(*) FROM +strTbl+ tblA\n///         WHERE ((tblA.+strCol+ = tblB.\" +strCol+) AND (tblA.id < tblB.id))\n///       ) AS idxValue\n///       FROM +strTbl+ tblB\n///       WHERE (tblB.+strCol+ = \'+strColVal+\') <<< difference btwn (ALL),(ONE)\n///     ) tblC ON tblD.id = tblC.id\"\n///\n/// SQL stmts for tables w/composite primary-key \"parent\",\"idx\"\n/// note: IDX issues only w/gaps (no nulls,duplicates)\n///\n/// \"UPDATE +strTbl+ tblB SET tblB.idx = (\n///       SELECT COUNT(*) FROM +strTbl+ tblA\n///         WHERE ((tblA.+strCol+ = tblB.+strCol+) AND (tblA.idx < tblB.idx))\n///     )\n///     WHERE (tblB.+strCol+ = \'+strColVal+\')\" <<< difference btwn (ALL),(ONE)\n///\n/// \"UPDATE +strTbl+ tblD\n///   JOIN (\n///     SELECT tblB.+strCol+, tblB.idx, (\n///         SELECT COUNT(*) FROM +strTbl+ tblA\n///           WHERE ((tblA.+strCol+ = tblB.+strCol+) AND (tblA.idx < tblB.idx))\n///       ) AS idxNew\n///       FROM +strTbl+ tblB\n///       WHERE (tblB.+strCol+ = \'+strColVal+\') <<< difference btwn (ALL),(ONE)\n///   ) tblC ON tblD.+strCol+ = tblC.+strCol+ AND tblD.idx = tblC.idx\n///   SET tblD.idx = tblC.idxNew\"\n///\n/// \"UPDATE tblD\n///   SET tblD.idx = tblC.idxNew\n///   FROM +strTbl+ tblD\n///   JOIN (\n///     SELECT tblB.+strCol+, tblB.idx, (\n///         SELECT COUNT(*) FROM +strTbl+ tblA\n///           WHERE ((tblA.+strCol+ = tblB.+strCol+) AND (tblA.idx < tblB.idx))\n///       ) AS idxNew\n///       FROM +strTbl+ tblB\n///       WHERE (tblB.+strCol+ = \'+strColVal+\') <<< difference btwn (ALL),(ONE)\n///   ) tblC ON tblD.+strCol+ = tblC.+strCol+ AND tblD.idx = tblC.idx\"\n///\nvoid funcVoid_UpdateIDXVals(String argDB, String argTbl, String argKey, String argCol, String argColVal) {\n  String tmpSQL = \"\";\n  boolean tmpFlagAutoCommit = true;\n\n///\n/// table w/\"id\" as (simple) primary-key (basic SQL UPDATE stmt)\n/// nulls or dups or gaps could occur among idx values\n/// assign SQL UPDATE stmt based on RDBMS setting (or cross fingers w/Oracle)\n///\n  if (argKey.equals(\"id\")) {\n    if (argDB.equals(\"mysql\")) {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE \" +argTbl+ \" tblD JOIN (SELECT tblB.id, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) AS idxValue FROM \" +argTbl+ \" tblB) tblC ON tblD.id = tblC.id SET tblD.idx = tblC.idxValue\")\n        : (\"UPDATE \" +argTbl+ \" tblD JOIN (SELECT tblB.id, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) AS idxValue FROM \" +argTbl+ \" tblB WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\')) tblC ON tblD.id = tblC.id SET tblD.idx = tblC.idxValue\") ;\n    } else if (argDB.equals(\"sqlserver\")) {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE tblD SET tblD.idx = tblC.idxValue FROM \" +argTbl+ \" tblD JOIN (SELECT tblB.id, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) AS idxValue FROM \" +argTbl+ \" tblB) tblC ON tblD.id = tblC.id\")\n        : (\"UPDATE tblD SET tblD.idx = tblC.idxValue FROM \" +argTbl+ \" tblD JOIN (SELECT tblB.id, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) AS idxValue FROM \" +argTbl+ \" tblB WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\')) tblC ON tblD.id = tblC.id\") ;\n    }\n    else {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE \" +argTbl+ \" tblB SET tblB.idx = ( SELECT COUNT(tblA.id) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) \")\n        : (\"UPDATE \" +argTbl+ \" tblB SET tblB.idx = ( SELECT COUNT(tblA.id) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.id < tblB.id))) WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\') \") ;\n    }\n  }\n///\n/// table w/\"idx\" in (composite) primary-key (alternate SQL UPDATE stmt)\n/// only gaps occur (no nulls or dups) when IDX in primary key\n/// assign SQL UPDATE stmt based on RDBMS vendor (or cross fingers w/Oracle)\n///\n  else {\n    if (argDB.equals(\"mysql\")) {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE \" +argTbl+ \" tblD JOIN ( SELECT tblB.\" +argCol+ \", tblB.idx, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx))) AS idxNew FROM \" +argTbl+ \" tblB) tblC ON tblD.\" +argCol+ \" = tblC.\" +argCol+ \" AND tblD.idx = tblC.idx SET tblD.idx = tblC.idxNew\")\n        : (\"UPDATE \" +argTbl+ \" tblD JOIN ( SELECT tblB.\" +argCol+ \", tblB.idx, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx))) AS idxNew FROM \" +argTbl+ \" tblB WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\')) tblC ON tblD.\" +argCol+ \" = tblC.\" +argCol+ \" AND tblD.idx = tblC.idx SET tblD.idx = tblC.idxNew\");\n    } else if (argDB.equals(\"sqlserver\")) {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE tblD SET tblD.idx = tblC.idxNew FROM \" +argTbl+ \" tblD JOIN ( SELECT tblB.\" +argCol+ \", tblB.idx, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx))) AS idxNew FROM \" +argTbl+ \" tblB) tblC ON tblD.\" +argCol+ \" = tblC.\" +argCol+ \" AND tblD.idx = tblC.idx\")\n        : (\"UPDATE tblD SET tblD.idx = tblC.idxNew FROM \" +argTbl+ \" tblD JOIN ( SELECT tblB.\" +argCol+ \", tblB.idx, ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx))) AS idxNew FROM \" +argTbl+ \" tblB WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\')) tblC ON tblD.\" +argCol+ \" = tblC.\" +argCol+ \" AND tblD.idx = tblC.idx\");\n    }\n    else {\n      tmpSQL = (null == argColVal)\n        ? (\"UPDATE \" +argTbl+ \" tblB SET tblB.idx = ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx)))\")\n        : (\"UPDATE \" +argTbl+ \" tblB SET tblB.idx = ( SELECT COUNT(*) FROM \" +argTbl+ \" tblA WHERE ((tblA.\" +argCol+ \" = tblB.\" +argCol+ \") AND (tblA.idx < tblB.idx))) WHERE (tblB.\" +argCol+ \" = \'\" +argColVal+ \"\')\");\n    }\n  }\n\n  log.info(\"using idx UPDATE [\" +tmpSQL+ \"]\");\n  try {\n    if ((void != flagNoRunSQL) && flagNoRunSQL) {\n      log.debug(\"skipping idx UPDATE [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n      if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Info, tmpSQL, null));\n      output.println(tmpSQL);\n    } else {\n      log.debug(\"connecting idx UPDATE [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n      Connection tmpConn = context.getConnection();\n\n//\n// handle special DB cfgs (enable auto-commit, zero-out Oracle stmt-cache)\n//\n      tmpFlagAutoCommit = tmpConn.getAutoCommit();\n      if (!tmpFlagAutoCommit) tmpConn.setAutoCommit(true);\n      if (\"oracle\".equals(tmpDB)) funcVoid_TweakDBConnection(tmpConn);\n\n      log.debug(\"preparing idx UPDATE [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n      PreparedStatement tmpStmt = tmpConn.prepareStatement(tmpSQL);\n\n      log.debug(\"executing idx UPDATE [\" +argTbl+ \":\" +argKey+ \":\" +argCol+ \"]\");\n      tmpStmt.executeUpdate();\n    }\n  } catch(java.sql.SQLException e) {\n    log.error(\"executing idx UPDATE failed: \", e);\n    throw e;\n  } finally {\n//\n// restore DB cfgs (optionally disable auto-commit)\n//\n      if (!tmpFlagAutoCommit) tmpConn.setAutoCommit(false);\n  }\n  log.debug(\"exiting idx UPDATE\");\n}\n\n\n///\n///\n/// funcVoid_HandleRunRuleExec()\n/// detect ruleexecutor invocation and update options\n/// note: \"sailpoint.task.RuleExecutor\" passes \"config\" as built-in map\n/// note: option0 confirms \"config\" type\n///\nvoid funcVoid_HandleRunRuleExec() {\n  if ((void != config) && (config instanceof Map)) {\n    String UI_CFG_KEY_0 = \"SupportRuleIDXCK\";\n    String UI_CFG_KEY_1 = \"flagFix\";\n    String UI_CFG_KEY_2 = \"flagAllTbls\";\n    String UI_CFG_KEY_3 = \"strTblOverride\";\n    String UI_CFG_KEY_4 = \"flagFixAllRows\";\n    String UI_CFG_KEY_5 = \"flagNoRunSQL\";\n    String UI_CFG_KEY_6 = \"strIIQVerOverride\";\n    String UI_CFG_KEY_7 = \"strSQLSyntaxOverride\";\n    String UI_CFG_KEY_8 = \"flagParentCol\";\n\n    log.debug(\"ruleconfig = \" + config.toString());\n\n    if ((null == config.get(UI_CFG_KEY_0)) || !Boolean.parseBoolean((String) config.get(UI_CFG_KEY_0))) return;\n\n    if (null != config.get(UI_CFG_KEY_1)) flagFix = Boolean.parseBoolean((String) config.get(UI_CFG_KEY_1));\n    if (null != config.get(UI_CFG_KEY_2)) flagAllTbls = Boolean.parseBoolean((String) config.get(UI_CFG_KEY_2));\n    if (null != config.get(UI_CFG_KEY_3)) {\n      String tmpTblOverride = ((String) config.get(UI_CFG_KEY_3)).trim().toLowerCase();\n      if (null != tmpTblOverride && (0 < tmpTblOverride.length())) {\n         flagOverrideTbl = true; strValueOverride = \"\"; strTblOverride = tmpTblOverride;\n      }\n    }\n    if (null != config.get(UI_CFG_KEY_4)) flagFixAllRows = Boolean.parseBoolean((String) config.get(UI_CFG_KEY_4));\n    if (null != config.get(UI_CFG_KEY_5)) flagNoRunSQL = Boolean.parseBoolean((String) config.get(UI_CFG_KEY_5));\n    if (null != config.get(UI_CFG_KEY_6)) strIIQVerOverride = ((String) config.get(UI_CFG_KEY_6)).trim();\n    if (null != config.get(UI_CFG_KEY_7)) strSQLSyntaxOverride = ((String) config.get(UI_CFG_KEY_7)).trim().toLowerCase();\n    if (null != config.get(UI_CFG_KEY_8)) flagParentCol = Boolean.parseBoolean((String) config.get(UI_CFG_KEY_8));\n  }\n}\n\n///\n///\n/// main()\n///\n/// initialize options\n/// build list of tables to check\n/// scan/repair tables in list (give progress/results along the way)\n///\n/// uncomment following line to output stack trace\n/// new Exception().printStackTrace(System.out);\n///\n    funcVoid_HandleRunRuleExec();\n\n    String tmpDB =  funcStr_SetSQLSyntax();\n    String tmpVer = ((void != strIIQVerOverride) && (0 < strIIQVerOverride.length())) ? strIIQVerOverride : Version.getVersion();\n    ArrayList tmpLstTblIDX = funcALst_CfgTblIDX(tmpVer);\n    int tmpTblCnt = 0;\n\n    try  {\n      if (flagTaskResult) { taskResult.setProgress(\"starting\"); context.saveObject(taskResult); context.commitTransaction(); }\n\n      if ((null != tmpLstTblIDX) && (2 < tmpLstTblIDX.size())) {\n        for (int i = 0; i+2 < tmpLstTblIDX.size(); i+=3, tmpTblCnt++) {\n          String tmpTbl = (String) tmpLstTblIDX.get(i);\n          String tmpKey = (String) tmpLstTblIDX.get(i+1);\n          String tmpCol = (String) tmpLstTblIDX.get(i+2);\n\n            String tmpMsg = \"scanning table \'\" + tmpTbl + \"\' column \'idx\'\";\n          log.info(tmpMsg); if (flagTaskResult) { taskResult.setProgress(tmpMsg); context.saveObject(taskResult); context.commitTransaction(); }\n\n          ArrayList tmpLstBadCols = funcALst_SelectBadIDXCols(tmpTbl, tmpKey, tmpCol);\n          if ((null != tmpLstBadCols) && (0 < tmpLstBadCols.size())) {\n            tmpMsg = \"Table \'\" +tmpTbl+ \"\' holds \" + tmpLstBadCols.size()+ \" row-set(s) with non-sequential values in \'idx\' column\";\n            log.warn(tmpMsg); if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Error, tmpMsg, null));\n            output.println(\"WARN: \" + tmpMsg);\n          }\n\n          if ((void != flagFix) && flagFix) {\n            if ((void != flagNoRunSQL) && flagNoRunSQL) { funcVoid_UpdateIDXVals(tmpDB, tmpTbl, tmpKey, tmpCol, null); }\n            else if ((null != tmpLstBadCols) && (0 < tmpLstBadCols.size())) {\n              tmpMsg = \"resequencing table \'\" + tmpTbl + \"\' column \'idx\'\";\n              log.info(tmpMsg); if (flagTaskResult) { taskResult.setProgress(tmpMsg); context.saveObject(taskResult); context.commitTransaction(); }\n\n              if ((void != flagFixAllRows) && flagFixAllRows)\n                funcVoid_UpdateIDXVals(tmpDB, tmpTbl, tmpKey, tmpCol, null);\n              else\n                for (String tmpValue : tmpLstBadCols) if (null != tmpValue) funcVoid_UpdateIDXVals(tmpDB, tmpTbl, tmpKey, tmpCol, tmpValue);\n\n              tmpMsg = \"Table \'\" +tmpTbl+ \"\'  column \'idx\' re-sequenced\";\n              log.warn(tmpMsg); if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Info, tmpMsg, null));\n              output.println(\"WARN: \" + tmpMsg);\n            }\n          }\n\n          if ((void != flagParentCol) && flagParentCol) {\n            tmpMsg = \"scanning table \'\" + tmpTbl + \"\' column \'\" +tmpCol+ \"\'\";\n            log.info(tmpMsg); if (flagTaskResult) { taskResult.setProgress(tmpMsg); context.saveObject(taskResult); context.commitTransaction(); }\n\n            int tmpCntNullCols = funcInt_CountNullParentCols(tmpTbl, tmpKey, tmpCol);\n            if (0 < tmpCntNullCols) {\n              tmpMsg = \"Table \'\" +tmpTbl+ \"\' holds \" +tmpCntNullCols+ \" row(s) with null values in \'\" +tmpCol+ \"\' column\";\n              log.warn(tmpMsg); if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Warn, tmpMsg, null));\n              output.println(\"WARN: \" + tmpMsg);\n            }\n          }\n          \n          output.println(\"INFO: table \'\" + tmpTbl + \"\' processed\");\n        }\n      }\n      if (flagTaskResult) { taskResult.setProgress(\"completed\"); context.saveObject(taskResult); context.commitTransaction(); }\n    } catch(Exception e) {\n      log.error(\"IDX exception: \", e);\n      if (flagTaskResult) taskResult.addMessage(new Message(Message.Type.Error, \"Exception thrown during rule execution\", null)); \n      output.println(\"ERROR: Exception thrown during rule execution\");\n      e.printStackTrace(output);\n      log.error(\"IDX rule exception: \", e);\n    }\n\n    output.println( ((null != tmpLstTblIDX) ? ((tmpLstTblIDX.size()/3).toString()) : \"0\") + \" \" +tmpDB+ \" table(s) processed for \" +tmpVer+ \" release\" );\n    return stringWriter.toString();\n\n   ',NULL,' ',NULL,NULL),('a9fedb6691791889819182cb88a7017b',1724476262568,1739425338465,NULL,NULL,NULL,'User Correlation',NULL,'beanshell','\n	import sailpoint.object.Identity;\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory; \n	import sailpoint.object.Filter;\n	import sailpoint.object.Filter.FilterCompiler;\n	import java.util.Map;\n	import java.util.List;\n	import java.util.ArrayList;\n	import java.util.Iterator;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Link;\n	\n	import sailpoint.api.Correlator;\n	import sailpoint.object.Application;\n	\n	/**\n	shortname = AD (Active Director)\n	userName = 12345\n	\n	name= AD-12345\n	\n	**/\n\n	Map correlationMap = new HashMap();\n	//get System Account Indicator from feed\n	String indicator = account.getAttribute(\"System Account Indicator\");\n	\n	String appShortName = application.getStringAttributeValue(\"ShortName\");\n	String correlationKey = account.getStringAttribute(\"CorrelationKey\");\n	String uid = account.getStringAttribute(\"uid\");\n\n	List filterList = new ArrayList();\n	\n	if(appShortName != null){\n		filterList.add(filter.ignoreCase(Filter.eq(\"name\", appShortName + \"-\" + uid.trim())));\n	}\n	\n	if(correlationKey != null){\n		filterList.add(filter.ignoreCase(Filter.eq(\"uid\", correlationKey)));\n		filterList.add(filter.ignoreCase(Filter.eq(\"employeeNumber\", correlationKey)));\n		filterList.add(filter.ignoreCase(Filter.eq(\"email\", correlationKey)));\n		\n		/*\n		set correlation for secondary account\n		*/\n		int corrKeyLen = correlationKey.length();\n		if(corrKeyLen > 1){\n			String  corrKeyLastChar = correlationKey.subString(corrKeyLen - 1);\n			if(corrKeyLastChar != null && (corrKeyLastChar.equalsIgnoreCase(\"p\") || corrKeyLastChar.equalsIgnoreCase(\"A\"))){\n				filterList.add(filter.ignoreCase(Filter.eq(\"uid\", correlationKey.subString(0, correlationKey.length()-1))));\n			}\n		}\n	}\n	\n	QueryOptions options = new QueryOptions();\n	\n	if(filterList.size() > 0){\n		options.addFilter(Filter.or(filterList));\n		Iterator iterator = context.search(Identity.class, options);\n		if(null != iterator && iterator.hasNext()){\n			targetIdentity = (Iterator) iterator.next();\n			correlationMap.put(\"identity\", targetIdentity);\n		}\n	}\n	\n	\n	//return map\n	return correlationMap;\n	','Correlation',' ',NULL,'Map'),('a9fedb6691bb1afa8191bbabe6120079',1725430490642,1739425312338,NULL,NULL,NULL,'Build Map Rule','This rule is used by the delimited file connector to build a map representation of the delimited data.','beanshell','\n  \n	import sailpoint.object.Schema;\n	import sailpoint.connector.Connector;\n	import sailpoint.connector.DelimitedFileConnector;\n	import sailpoint.connector.AbstractConnector;\n	import sailpoint.object.*;\n	import sailpoint.tools.*;\n	import sailpoint.api.*;\n	import java.util.*;\n	import sailpoint.tools.GeneralException;\n	import java.lang.*;\n	import java.io.*;\n	import java.util.List;\n\n \n		//Set the map with the next iterator for account/group\n		Map map = DelimitedFileConnector.defaultBuildMap(cols, record); \n		\n		//name,Group\n		//12345,group1-group2-group3\n \n        //Process Accounts\n        if ( schema.getObjectType().compareTo(Connector.TYPE_ACCOUNT) == 0 ) {\n			\n			//Get all of the string values we want to manipulate\n            String groupname = (String)map.get(\"Group\");\n			\n			//Split up the groups\n            List groups = new ArrayList();\n            if (groupname != null && !groupname.equals(\"\") ) {\n               String[] items = groupname.split(\"-\");\n               for (int i = 0; i < items.length ; i++ ) {\n                    String item = items[i].trim();\n                    if ((item != null) && (! item.equals(\"\"))) {\n                          groups.add(item);\n                      }          \n               }\n            }\n            map.put(\"Group\", groups);\n                 \n		}  \n        \n		//Return the resulting \"map\"\n		return map;\n  \n  ','BuildMap',' ',NULL,'Map'),('a9fedb6691bb1afa8191d55b9208059b',NULL,1733482658489,NULL,NULL,NULL,'Test Adhoc Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import org.apache.commons.logging.Log;\n  import org.apache.commons.logging.LogFactory;\n\n  String identityName = \"2020013\";\n  System.out.println(\"Searching User: \"+identityName);\n  Identity identity = context.getObjectByName(Identity.class, identityName);\n\n  return identity.getLinks();\n  return identity.getLinks().get(1).getApplication();\n  System.out.println(\"Result Identity: \"+identity.getManager());\n  System.out.println(\"Result Full Name: \"+identity.getFullName());\n\n\n\n  ',NULL,' ',NULL,NULL),('a9fedb6691da14b48191db3479100090',1725959534864,NULL,NULL,NULL,NULL,'COF ServiceDog IncidentCreate Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fedb6691da14b48191db347c3d0091',1725959535677,NULL,NULL,NULL,NULL,'COF CyberArk PAM Server password retrieval rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fedb6691da14b48191db347d430092',1725959535940,NULL,NULL,NULL,NULL,'COF CyberArk SCIM API Rule Library',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fedb6691da14b48191db347e0a0093',1725959536139,NULL,NULL,NULL,NULL,'COF CyberArk Password Vault Rule',NULL,'beanshell',NULL,NULL,' ',NULL,NULL),('a9fedb6691da14b48191db347efa0094',1725959536378,1739425307653,NULL,NULL,NULL,'After Provisioning Rule.xml','An IdentityIQ server-side rule that is executed after the connector\'s provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan AFTER it has been sent out to the specific applications.\n    This rule will be called for any application found in a plan that also has a configured \'afterProvisioningRule\' configured.','beanshell','\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	import sailpoint.object.Application;\n	import sailpoint.object.Attributes;\n	import sailpoint.object.Identity;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.ProvisioningResult;\n	import sailpoint.object.EmailOptions;\n	import sailpoint.object.EmailTemplate;\n\n	boolean isPassPost;\n	String passwordValue=null;\n	String sendEmailTo=null;\n	String passwordAttribute= \"pwd\";\n	String emailAttribute=\"email\";\n\n	//The email template for the email which will be sent to end user\n	EmailTemplate template = context.getObjectByName(EmailTemplate.class, \"Account Create Notification\");\n\n	EmailOptions emailOptions;\n\n	//The email will only be sent if the result is committed.\n	if((result.isCommitted() || result.isSubmitted()) && plan!=null && application!=null)\n	{\n\n		List accountRequestList=plan.getAccountRequests(application.getName());\n\n		if(accountRequestList!=null && !accountRequestList.isEmpty())\n		{\n\n		for(AccountRequest accountRequestValue:accountRequestList)\n		{\n\n			String nativeIdentityName=accountRequestValue.getNativeIdentity();\n\n			if(accountRequestValue.getOperation().toString().equalsIgnoreCase(\"Create\"))\n			{\n\n			if(accountRequestValue.getAttributeRequest(passwordAttribute)!=null)\n			{\n\n				passwordValue= accountRequestValue.getAttributeRequest(passwordAttribute).getValue();\n				String identityRequestId = null;\n\n				if(plan.getArguments()!=null) {\n					Map arguments = plan.getArguments();\n\n					if(arguments != null && arguments.get(\"identityRequestId\") != null) {\n						identityRequestId = (String) arguments.get(\"identityRequestId\");\n					}\n				}\n			\n				Identity identity = plan.getIdentity();\n				String identityName = identity.getName();\n  \n				String appName = application.getName();\n				Identity sendToIdentity=context.getObjectByName(Identity.class,nativeIdentityName.toUpperCase());\n\n				sendEmailTo= accountRequestValue.getAttributeRequest(emailAttribute).getValue();\n				if(sendEmailTo!=null && sendToIdentity!=null)\n				{\n\n					Map argument = new HashMap();\n\n					//Set the arguments for email template\n					argument.put(\"To\", sendEmailTo);\n					argument.put(\"owner\",sendToIdentity);\n					argument.put(\"appName\",application.getName());\n					argument.put(\"password\",passwordValue);\n\n					//Setting the arguments and email receiver for email template\n					emailOptions = new EmailOptions(sendEmailTo, argument);\n\n					//Send out the email\n					context.sendEmailNotification(template, emailOptions);\n\n				}\n				else\n				{\n                //if we were not able to find email id, add a warning to the ProvisioningResult\n                result.addWarning(\"Unable to send email for \" + nativeIdentityName);\n				}\n            }\n          }\n        }\n      }\n    }\n  }\n\n  ','AfterProvisioning',' ',NULL,NULL),('a9fedb6691da14b48191db34b1fa0095',1725959549434,1739434204623,NULL,NULL,NULL,'Before Provisioning Rule','An IdentityIQ server-side rule that is executed before the connector\'s provisioning method is called. This gives the customer the ability to customize or react to anything in the ProvisioningPlan BEFORE it is sent to the underlying connectors used in provisioning. This rule will be called for any application found in a plan that also has a configured \'beforeProvisioningRule\' configured.  \n\n	The plan can be updated directly in the rule by reference and does not need to return the plan.','beanshell','\n  \n	import org.apache.log4j.Logger;\n	import org.apache.log4j.Level;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.Identity;\n\n\n	if(plan != null){\n\n	String identityName = plan.getNativeIdentity().toString();\n\n	Identity identity = context.getObjectByName(Identity.class, identityName);\n\n	List acctRequests = plan.getAccountRequests(\"Application Name\");\n\n	for(AccountRequest accountRequest:acctRequests ){\n		AccountRequest.Operation op = accountRequest.getOperation();\n\n		if(op == AccountRequest.Operation.Modify || op == AccountRequest.Operation.Disable || op == AccountRequest.Operation.Enable || op == AccountRequest.Operation.Delete){\n\n\n			AttributeRequest email = accountRequest.getAttributeRequest(\"emails.primary.value\");\n			AttributeRequest givenName= accountRequest.getAttributeRequest(\"givenName\");\n			AttributeRequest familyName= accountRequest.getAttributeRequest(\"familyName\");\n			AttributeRequest group= accountRequest.getAttributeRequest(\"Group\");\n\n			if(group != null && group.getOperation() != null && group.getOperation().equals(ProvisioningPlan.Operation.Remove))\n			{\n				accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Disable);\n			}\n			if(op == AccountRequest.Operation.Delete){\n	             accountRequest.setOperation(ProvisioningPlan.AccountRequest.Operation.Disable);\n	        }\n			if(email == null)\n			{\n				AttributeRequest attremail = new AttributeRequest(\"emails.primary.value\", ProvisioningPlan.Operation.Add, identity.getEmail());\n\n				accountRequest.add(attremail);\n			}\n\n\n			if(givenName== null)\n			{\n				AttributeRequest attrgivenName = new AttributeRequest(\"givenName\", ProvisioningPlan.Operation.Add, identity.getLastname());\n				accountRequest.add(attrgivenName);\n			}\n\n			if(familyName== null)\n			{\n				AttributeRequest attrfamilyName = new AttributeRequest(\"familyName\", ProvisioningPlan.Operation.Add, identity.getFirstname());\n				accountRequest.add(attrfamilyName );\n			}\n		}\n	}\n}\n\n\n','BeforeProvisioning',' ',NULL,NULL),('a9fedb6691da14b48191e0a47f25026f',1726050762533,1739425315080,NULL,NULL,NULL,'Certification Predelegation Rule','Rule to reasign Access Reviews for inactive certifiers, certifiers without email, and C-Level executives to the Certification Admin Workgroup.','beanshell','\n  \n	import sailpoint.api.SailPointContext;\n	import sailpoint.api.ObjectUtil;\n\n	import sailpoint.object.Certification;\n	import sailpoint.object.CertificationEntity;\n	import sailpoint.object.Identity;\n	import sailpoint.object.Attributes;\n	  \n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n\n	/**\n	 * System configuration entry for the certification admin workgroup name.  This entry needs to be on SystemConfiguration\n	 * in the format <entry key=\"cofCertificationAdminWorkgroup\" value=\"Certification Admin Workgroup\"/>\n	 */\n	String SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP = \"CertificationAdminWorkgroup\";\n\n	Map returnMap = new HashMap();\n	String certificationName = certification.getName();\n	List certifierNames = certification.getCertifiers();\n	String certifierName = (String) certifierNames.get(0);\n	Identity certifier = context.getObjectByName(Identity.class, certifierName);\n\n\n	if (certifier != null) {\n\n		boolean flagForReassignment = false;\n		boolean isInactive = certifier.isInactive();\n		boolean missingEmail = false;\n		boolean isCLevel = false;\n		String identityCLevel = (String)certifier.getAttribute(\"ManagerLevel\");\n		String identityEmail = certifier.getEmail();\n		String inactiveComment = \"This Access Review has been reassigned because the original certifier [\" + certifierName + \"] was inactive\";\n		String cLevelComment = \"This Access Review has been reassigned because the original certifier [\" + certifierName + \"] is a C-Level Executive\";\n		String noEmailComment = \"This Access Review has been reassigned because the original certifier [\" + certifierName + \"] did not have an email address\";\n		String certificationAdminWorkgroupName = (String) state.get(\"certificationAdminWorkgroupName\");\n\n		//if certificationAdminWorkgroupName was not on the state Map, get it from sys config and add it to the state Map\n		if (certificationAdminWorkgroupName == null) {\n			certificationAdminWorkgroupName = context.getConfiguration().getString(SYS_CONFIG_CERTIFICATION_ADMIN_WORKGROUP);\n			state.put(\"certificationAdminWorkgroupName\", certificationAdminWorkgroupName);\n		}\n\n		//initialize missingEmail and isCLevel\n		if(!(identityEmail instanceof String) || identityEmail.isEmpty()){\n			\n			//if the certifier is a workgroup, check if there are any effective email addresses\n			if(certifier.isWorkgroup()){\n				Identity.WorkgroupNotificationOption notificationOption = certifier.getNotificationOption();\n\n				//if workgroup does not have emails disabled and there are no effective emails, set missingEmail to true\n				if(!Identity.WorkgroupNotificationOption.Disabled.equals(notificationOption)){\n					List emails = ObjectUtil.getEffectiveEmails(context, certifier);\n					if(emails == null || emails.isEmpty()){\n						missingEmail = true;\n					}\n				}\n			} else{\n				missingEmail = true;\n			}\n		}\n		if(identityCLevel != null){\n			int managerLevel = 0;\n			try{\n				managerLevel = Integer.parseInt(identityCLevel);\n				if(managerLevel >= 95){\n					isCLevel = true;\n				}\n			} catch (NumberFormatException nfe){\n				isCLevel = false;\n			}\n		}\n\n		/*\n		 * If identity is inactive, identity is c-level executive, or identity does not have an email, set the\n		 * appropriate comment for the certification and flag for reassignemnt\n		 */\n		if (isInactive) {\n			flagForReassignment = true;\n			returnMap.put(\"comments\", inactiveComment);\n		}\n		/*\n		 * removing C-Level check due to change in requirements\n		 *\n		if (isCLevel) {\n			flagForReassignment = true;\n			returnMap.put(\"comments\", cLevelComment);\n		}\n		*/\n		if (missingEmail) {\n			flagForReassignment = true;\n			returnMap.put(\"comments\", noEmailComment);\n		}\n\n		if (flagForReassignment) {\n			//send this certification to the certificationAdminWorkgroup\n			returnMap.put(\"recipient\", context.getObjectByName(Identity.class, certificationAdminWorkgroupName));\n\n			//set this as a reassignment, not a delegation\n			returnMap.put(\"reassign\", true);\n\n			//add the original certification name\n			//returnMap.put(\"certificationName\", certificationName);\n		}\n		else{\n			//certificaiton does not need to be reassigned so return an empty Map\n			returnMap = new HashMap();\n		}\n\n	}\n\n	return returnMap;\n  ','CertificationPreDelegation',' ',NULL,'Map'),('a9fedb6691da14b48191e0a4a6e10270',1726050772705,1739425318307,NULL,NULL,NULL,'Exclude Composite Accounts','\n  This rule splits the certifiables in the items and itemsToExclude list based on\n whether the certifiable is an \"Exception\" on an account that is a part of a\n composite account.  If we determine that the account is part of a composite\n account, the item is removed from the items list and added to the\n itemsToExclude list.\n  ','beanshell','\n      import sailpoint.object.Application;\n      import sailpoint.object.Certifiable;\n      import sailpoint.object.Entitlements;\n      import sailpoint.object.Link;\n\n      StringBuffer explanation = new StringBuffer();\n      Collection explainedAccounts = new HashSet();\n\n      for (Iterator it = items.iterator(); it.hasNext(); ) {\n          Certifiable certifiable = (Certifiable) it.next();\n          if (certifiable instanceof Entitlements) {\n              Entitlements ents = (Entitlements) certifiable;\n              Application app = ents.getApplicationObject(context);\n              String nativeIdentity = ents.getNativeIdentity();\n\n              Link composite = identity.getOwningCompositeLink(app, nativeIdentity);\n\n              // Non-null means that this is a component of a composite\n              // link, so we will exclude it.\n              if (null != composite) {\n                  it.remove();\n                  itemsToExclude.add(certifiable);\n\n                  String acct = app.getName() + \"-\" + nativeIdentity;\n                  if (!explainedAccounts.contains(acct)) {\n                      explainedAccounts.add(acct);\n\n                      if (explanation.length() > 0) {\n                          explanation.append(\"  \");\n                      }\n                      explanation.append(\"Account \" + nativeIdentity + \" on \" + app.getName() +\n                                         \" excluded because it is part of a composite account.\");\n                  }\n              }\n          }\n      }\n\n      return (0 != explanation.length()) ? explanation.toString() : null;\n  ','CertificationExclusion',' ',NULL,NULL),('a9fedb6691da14b48191e0a4c1be0271',1726050779582,1739425318555,NULL,NULL,NULL,'Exclude Inactive Identities','\n    This rule is an example Certification Exclusion rule that removes all\n    of the certifiable items from a certification if the identity being\n    certified is marked as inactive.\n  ','beanshell','\n	// if the identity is inactive, then add all of the items to the\n    // exclude list\n    if ( identity.isInactive() ) {\n      itemsToExclude.addAll(items);\n      items.clear();\n    }\n\n    // No explanation.\n    return null;\n  ','CertificationExclusion',' ',NULL,'String'),('a9fedb6691da14b48191e0a4dc2a0272',1726050786346,1739425317721,NULL,NULL,NULL,'Entitlement Certification Exclusion Rule','This rule is an example Certification Exclusion rule that removes all of the certifiable items from a certification if the identity being certified is marked as inactive.','beanshell','\n	import java.util.ArrayList;\n	import java.util.HashMap;\n	import java.util.Iterator;\n	import java.util.List;\n	import java.util.Map;\n\n	import sailpoint.object.Certifiable;\n	import sailpoint.object.Custom;\n	import sailpoint.object.EntitlementSnapshot;\n\n	import org.apache.commons.logging.Log;\n	import org.apache.commons.logging.LogFactory;\n\n	Certifiable certifiable = null;\n	Custom excludedEntitlementCustom = new Custom();\n	EntitlementSnapshot entitlementSnap = new EntitlementSnapshot();  \n	List entitlementNameList = new ArrayList();\n	List excludedEntitlementList=new ArrayList();        \n	Map excludedEntitlementMap = new HashMap();\n	Map excludedEntitlementMapFinal = new HashMap();\n	String applicationName = null;\n	String attributeNameFromCustom = null;\n	String explanation = \"No Entitlement Excluded\";\n	String name = null;\n\n	String APPLICATION_NAME = \"application\";\n	String EXCLUSION_CUSTOM = \"Entitlement Certification Exclusion Rule Custom\";\n	String ENTITLEMENTS_TO_BE_EXCLUDED = \"entitlementsToBeExcluded\";\n  \n  \n	Custom certExclusionCustomObject = (Custom) state.get(\"certExclusionCustomObject\");  \n	if(certExclusionCustomObject == null){    \n		certExclusionCustomObject = context.getObjectByName(Custom.class,EXCLUSION_CUSTOM);\n		if(certExclusionCustomObject != null){	\n		\n			state.put(\"certExclusionCustomObject\",certExclusionCustomObject); \n			\n		}else{\n			throw new GeneralException(\"Exclusion Custom Object Not Found: \"+EXCLUSION_CUSTOM);\n		}\n	}\n    \n  	excludedEntitlementMap = certExclusionCustomObject.get(ENTITLEMENTS_TO_BE_EXCLUDED);				 \n    \n  \n    Iterator it = items.iterator();\n    while(it.hasNext()){    \n        certifiable = (Certifiable) it.next();   \n        if (certifiable instanceof sailpoint.api.certification.DataOwnerCertificationBuilder$DataOwnerCertifiable && excludedEntitlementMap != null && excludedEntitlementMap.size()>0) {						\n            entitlementSnap = certifiable.getEntitlements();\n			\n			if(entitlementSnap != null && entitlementSnap.getApplicationName() != null && excludedEntitlementMap.containsKey(entitlementSnap.getApplicationName())){\n				applicationName = entitlementSnap.getApplicationName();\n\n				Set keyset  = excludedEntitlementMap.get(applicationName).keySet();\n				Iterator iter=keyset.iterator();\n				while(iter.hasNext()){\n					attributeNameFromCustom=(String)iter.next();\n				}                    \n				name = entitlementSnap.getAttributes().getString(attributeNameFromCustom);    \n                excludedEntitlementMapFinal = (Map)excludedEntitlementMap.get(applicationName);\n				excludedEntitlementList=(List)excludedEntitlementMapFinal.get(attributeNameFromCustom);		\n				if(excludedEntitlementList != null && excludedEntitlementList.contains(name)){				\n					it.remove();\n					itemsToExclude.add(certifiable);\n					explanation = \"Items are excluded due to Generic behaviour\";					\n				}\n			}\n		}\n	}\n\n	return explanation;\n\n','CertificationExclusion',' ',NULL,'String'),('a9fedb6691ff1f888192039591f00108',1726636986864,1739425334301,NULL,NULL,NULL,'QueryOptions Rule',NULL,'beanshell','\n  import java.util.*;\n  import sailpoint.object.*;\n  import sailpoint.api.Provisioner;\n  import sailpoint.api.*;\n  import sailpoint.object.QueryOptions;\n  import sailpoint.object.Filter;\n\n\n  /* QueryOptions ops = new QueryOptions();\n  Application app = null;\n  //#1\n  Filter myFilter = Filter.eq(\"name\", \"LDAP\");\n  //ops.addFilter(myFilter);\n\n\n  //#2\n  ops.addFilter(Filter.eq(\"name\", \"LDAP\"));\n\n  Iterator iterator = context.search(Application.class, ops);\n  if(null != iterator && iterator.hasNext()){\n    app = (Application) iterator.next();\n  }\n\n // return app.getName();*/\n\n  //#3\n  Identity identity = null;\n  List filterList = new ArrayList();\n\n\n  filterList.add(Filter.ignoreCase(Filter.eq(\"uid\", \"aaa0011\")));\n  filterList.add(Filter.ignoreCase(Filter.eq(\"employeenumber\", \"2020009\")));\n  filterList.add(Filter.ignoreCase(Filter.eq(\"email\", \"tlconn001@sweinc.com\")));\n\n  QueryOptions options = new QueryOptions();\n\n  if(filterList.size() > 0){\n    //options.addFilter(Filter.or(filterList));\n    Iterator iterator = context.search(Identity.class, options);\n    if(null != iterator && iterator.hasNext()){\n      identity = (Identity) iterator.next();\n    }\n  }\n\n  //return identity.getDisplayName();\n\n  //#4\n  //options.addFilter(Filter.and(filterList));\n  List identityList = context.getObjects(Identity.class, options);\n  List idList = new ArrayList();\n  if (null != identityList) {\n\n    for (Identity id : identityList) {\n      idList.add(id.getDisplayName());\n    }\n\n  }\n\n  //return idList;\n\n  //#5\n  int count = context.countObjects(Identity.class, options);\n  //return count;\n\n\n  QueryOptions ops = new QueryOptions();\n  ops.addFilter(Filter.isnull(\"manager\"));\n  //ops.addFilter(Filter.notnull(\"manager\"));\n  List identityList = context.getObjects(Identity.class, ops);\n  List idList = new ArrayList();\n  if (null != identityList) {\n    for (Identity id : identityList) {\n      idList.add(id.getDisplayName());\n    }\n\n  }\n  \n\n  return idList;\n\n\n  ',NULL,' ',NULL,NULL),('a9fedb66920d10508192228fa641037e',1727156692546,1739425326214,NULL,NULL,NULL,'Launch Workflow','A rule used by a Workflow to determine a step action or variable value.\n	Note that an Attributes map of all variables from the current WorkflowContext, merged with the arguments from the Step, is also passed into the workflow rule.','beanshell','\n	import java.util.ArrayList;\n	import java.util.Collections;\n	import java.util.HashMap;\n	import java.util.List;\n\n	import org.apache.log4j.Logger;\n\n	import sailpoint.api.Workflower;\n	import sailpoint.object.Attributes;\n	import sailpoint.object.Identity;\n	import sailpoint.object.ProvisioningPlan;\n	import sailpoint.object.Workflow;\n	import sailpoint.object.WorkflowLaunch;\n	import sailpoint.object.ProvisioningPlan.AccountRequest;\n	import sailpoint.object.ProvisioningPlan.AttributeRequest;\n	import sailpoint.object.Filter;\n	import sailpoint.object.QueryOptions;\n	import sailpoint.object.Link;\n	import sailpoint.object.Application;\n	import sailpoint.api.IdentityService;		  \n\n	String identityName = \"\";\n	String workflow = \"\";\n	HashMap 	launchArgsMap = new HashMap();\n	launchArgsMap.put(\"identityName\", identityName);\n	launchArgsMap.put(\"launcher\", \"spadmin\"); \n	launchArgsMap.put(\"flow\", \"Leaver\");\n	\n	//Create WorkflowLaunch and set values\n	WorkflowLaunch wfLaunch = new WorkflowLaunch();\n	Workflow wf = (Workflow)context.getObjectByName(Workflow.class, workflow);\n	wfLaunch.setWorkflowName(wf.getName());\n	wfLaunch.setWorkflowRef(wf.getName());\n	//wfLaunch.setCaseName(\"LCM Leaver for \"+ identityName));\n	wfLaunch.setVariables(launchArgsMap);\n\n	//Create Workflower and launch workflow from WorkflowLaunch\n	Workflower workflower = new Workflower(context);\n	WorkflowLaunch launch = workflower.launch(wfLaunch); \n	','Workflow',' ',NULL,'Object'),('ff8080816403081601640dc9b02a0097',1529239679019,1739425317003,NULL,NULL,NULL,'Creation_SetPassword','Identity creation rules are used to set attributes on new Identity objects when they are created.  New identities may be created during the aggregation of application accounts, or optionally created after pass-through authentication.\n\nOne common operation is to change the name property of the identity when the default application name is complex (such as a directory DN).\n\nAnother common operation is to assign a set of initial capabilities based on the attributes pulled from the application account.','beanshell','import sailpoint.object.Identity;\nimport sailpoint.object.Capability;\nimport sailpoint.object.ResourceObject;\n\n// change the name to a combination of firstname and lastname\nString firstname = account.getStringAttribute(\"givenName\");\nString lastname = account.getStringAttribute(\"sn\");\nString name = firstname + \".\" + lastname;\n\nidentity.setName(name);\nidentity.setPassword(\"Smile@123\");','IdentityCreation',' ',NULL,'void'),('ff8080816403081601640dd25500009e',1529240245504,1739425342983,NULL,NULL,NULL,'creation.SetPassword','Identity Correlation Rules are used to find identities to which new accounts can be attached.\n\nA correlation rule must return a Map with one of the specified Return arguments.','beanshell','import sailpoint.object.identity\n\nidentity.setPassword(\"Welcome@123\")','Correlation',' ',NULL,'Map'),('ff8080816403081601640deecac904ec',1529242110665,1739425323062,NULL,NULL,NULL,'Identity_Attribute_Employee','Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.\n\nThis rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the \"link\" argument which is not passed in global mapping rules.','beanshell','return \"Employee\"','IdentityAttribute',' ',NULL,'String'),('ff8080816403081601640df03c0804f1',1529242205192,1744089478200,NULL,NULL,NULL,'Identity_Attribute_Contractor','Identity attribute rules are used when the value is not simply a copy of an application account attribute value.  A transformation may be necessary on the account attribute, or several account attributes may need to be combined to produce the identity attribute.\n\nThis rule can be called in two ways: as a global mapping rule and an application mapping rule.  A global mapping rule is called whenever the identity is refreshed.  The rule can look at any account attributes.  An application mapping rule is called only when the identity contains an account link for that application, this link is passed in the \"link\" argument which is not passed in global mapping rules.','beanshell','\n  \n\n  return link.getAttribute(\"info\");\n    \n    \n    ','IdentityAttribute',' ',NULL,'String');
/*!40000 ALTER TABLE `spt_rule` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2025-08-18 12:49:51
